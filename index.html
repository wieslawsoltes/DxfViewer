<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Improved Web DXF Viewer – Enhanced MTEXT & HATCH Rendering</title>
    <style>
      /* Fullscreen canvas and toolbar styling */
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        user-select: none;
      }
      #toolbar {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 110;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
      }
      #toolbar button,
      #toolbar input {
        margin: 4px 0;
      }
      .optionsOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.3);
        z-index: 200;
      }
      .popupContent {
        position: absolute;
        top: 50px;
        left: 10px;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
        max-height: 400px;
        overflow-y: auto;
      }
      canvas {
        display: block;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="toolbar">
      <div>
        <input type="file" id="dxfFile" accept=".dxf" />
      </div>
      <div>
        <button id="resetView">Reset View</button>
        <button id="toggleGrid">Toggle Grid</button>
      </div>
      <div style="margin-top:8px;">
        <button id="toggleEntityOptions">Entity Options</button>
        <button id="toggleOtherOptions">Other Options</button>
      </div>
      <div style="margin-top:8px;">
        <small>Pan with mouse/touch; wheel or pinch to zoom.</small>
      </div>
    </div>

    <!-- Overlays for popups -->
    <div id="entityOptionsOverlay" class="optionsOverlay">
      <div id="entityOptionsPopup" class="popupContent">
        <div><strong>Entity Types</strong></div>
        <div style="margin:8px 0;">
          <button id="selectAllEntities">Select All</button>
          <button id="deselectAllEntities">Select None</button>
        </div>
        <label>
          <input type="checkbox" class="entity-toggle" data-type="LINE" checked /> LINE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="CIRCLE" checked /> CIRCLE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="ARC" checked /> ARC
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="POLYLINE" checked /> POLYLINE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="LWPOLYLINE" checked /> LWPOLYLINE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="HATCH" checked /> HATCH
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="DIMENSION" checked /> DIMENSION
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="MTEXT" checked /> MTEXT
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="SPLINE" checked /> SPLINE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="INSERT" checked /> INSERT
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="TEXT" checked /> TEXT
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="ATTRIB" checked /> ATTRIB
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="ELLIPSE" checked /> ELLIPSE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="3DFACE" checked /> 3DFACE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="SOLID" checked /> SOLID
        </label><br />
      </div>
    </div>

    <div id="otherOptionsOverlay" class="optionsOverlay">
      <div id="otherOptionsPopup" class="popupContent">
        <div><strong>Rendering Options</strong></div>
        <label>
          <input type="checkbox" id="toggleLinetype" /> Disable Linetype Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleColor" /> Disable Color Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleThickness" /> Disable Thickness Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleWidth" /> Disable Width Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleTransparency" /> Disable Transparency Rendering
        </label><br />
      </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
      // ─────────────────────────────────────────────────────────────
      // GLOBAL RENDER SETTINGS
      // ─────────────────────────────────────────────────────────────
      const renderSettings = {
        entity: {
          LINE: true,
          CIRCLE: true,
          ARC: true,
          POLYLINE: true,
          LWPOLYLINE: true,
          HATCH: true,
          DIMENSION: true,
          MTEXT: true,
          SPLINE: true,
          INSERT: true,
          TEXT: true,
          ATTRIB: true,
          ELLIPSE: true,
          "3DFACE": true,
          SOLID: true
        },
        renderLinetype: true,
        renderColor: true,
        renderThickness: true,
        renderWidth: true,
        renderTransparency: true
      };

      // ─────────────────────────────────────────────────────────────
      // UTILS
      // ─────────────────────────────────────────────────────────────

      class DXFUtils {
        static degToRad(deg) {
          return (deg * Math.PI) / 180;
        }
        static rotatePoint(x, y, angle) {
          return {
            x: x * Math.cos(angle) - y * Math.sin(angle),
            y: x * Math.sin(angle) + y * Math.cos(angle)
          };
        }
      }

      // Basic geometry helpers
      function getDistance(p1, p2) {
        return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
      }
      function getCenter(p1, p2) {
        return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      }
      function computeBBox(pointsOrLoops) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        if (!pointsOrLoops || pointsOrLoops.length === 0) return { minX, minY, maxX, maxY };
        if (Array.isArray(pointsOrLoops[0])) {
          pointsOrLoops.forEach(loop => {
            loop.forEach(pt => {
              minX = Math.min(minX, pt.x);
              minY = Math.min(minY, pt.y);
              maxX = Math.max(maxX, pt.x);
              maxY = Math.max(maxY, pt.y);
            });
          });
        } else {
          pointsOrLoops.forEach(pt => {
            minX = Math.min(minX, pt.x);
            minY = Math.min(minY, pt.y);
            maxX = Math.max(maxX, pt.x);
            maxY = Math.max(maxY, pt.y);
          });
        }
        return { minX, minY, maxX, maxY };
      }
      function getNiceGridSpacing(viewport) {
        const desiredSpacingScreen = 50;
        let spacingWorld = desiredSpacingScreen / viewport.viewScale;
        let exponent = Math.floor(Math.log10(spacingWorld));
        let fraction = spacingWorld / Math.pow(10, exponent);
        let niceFraction;
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
        return niceFraction * Math.pow(10, exponent);
      }

      // ─────────────────────────────────────────────────────────────
      // MTEXT Parsing Helpers
      // ─────────────────────────────────────────────────────────────

      function parseMTEXTContent(rawText, defaultSize, defaultFont, defaultColor) {
        rawText = rawText.replace(/%%d/g, "°").replace(/%%c/g, "Ø");
        let defaultStyle = {
          scale: 1,
          font: defaultFont,
          underline: false,
          overline: false,
          bold: false,
          italic: false,
          color: defaultColor
        };
        let result = parseFormattedText(rawText, 0, defaultStyle);
        return result.segments;
      }
function parseFormattedText(text, pos, currentStyle) {
  let segments = [];
  let currentSegment = { text: "", style: Object.assign({}, currentStyle) };
  while (pos < text.length) {
    let ch = text[pos];
    if (ch === '{') {
      if (currentSegment.text) {
        segments.push(currentSegment);
        currentSegment = { text: "", style: Object.assign({}, currentStyle) };
      }
      let groupResult = parseGroup(text, pos + 1, Object.assign({}, currentStyle));
      segments.push(...groupResult.segments);
      pos = groupResult.pos;
    } else if (ch === '}') {
      if (currentSegment.text) segments.push(currentSegment);
      return { segments: segments, pos: pos + 1 };
    }
    // ── Handle caret codes per documentation ──
    else if (ch === '^') {
      pos++;
      if (pos < text.length) {
        let nextChar = text[pos];
        if (nextChar === 'I') {
          currentSegment.text += '\t';
        } else if (nextChar === 'J') {
          if (currentSegment.text) segments.push(currentSegment);
          segments.push({ paragraphBreak: true });
          currentSegment = { text: "", style: Object.assign({}, currentStyle) };
        } else if (nextChar === 'M') {
          // ^M is ignored
        } else {
          // Any other character: render a replacement square plus the char.
          currentSegment.text += '▯' + nextChar;
        }
        pos++;
      }
    }
    // ── Handle backslash escape and inline commands ──
    else if (ch === '\\') {
      if (text.substr(pos, 2) === '\\P') {
        if (currentSegment.text) segments.push(currentSegment);
        segments.push({ paragraphBreak: true });
        pos += 2;
        currentSegment = { text: "", style: Object.assign({}, currentStyle) };
        continue;
      } else if (text.substr(pos, 2) === '\\L') {
        currentStyle.underline = true;
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\l') {
        currentStyle.underline = false;
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\O') {
        currentStyle.overline = true;
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\o') {
        currentStyle.overline = false;
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\B') {
        currentStyle.bold = true;
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\b') {
        currentStyle.bold = false;
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\I') {
        currentStyle.italic = true;
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\i') {
        currentStyle.italic = false;
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\C') {
        pos += 2;
        let colorCode = "";
        while (pos < text.length && text[pos] !== ';') {
          colorCode += text[pos];
          pos++;
        }
        if (text[pos] === ';') pos++;
        currentStyle.color = DXFStyle.getACIColor(parseInt(colorCode, 10));
        continue;
      } else if (text.substr(pos, 2) === '\\S') {
        pos += 2;
        let stackedStr = "";
        while (pos < text.length && text[pos] !== ';') {
          stackedStr += text[pos];
          pos++;
        }
        if (text[pos] === ';') pos++;
        let parts = stackedStr.split('^');
        let topText = parts[0] || "";
        let bottomText = parts[1] || "";
        if (currentSegment.text) {
          segments.push(currentSegment);
          currentSegment = { text: "", style: Object.assign({}, currentStyle) };
        }
        segments.push({
          stacked: { top: topText, bottom: bottomText },
          style: Object.assign({}, currentStyle)
        });
        continue;
      } else if (text.substr(pos, 2) === '\\{') {
        currentSegment.text += '{';
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\}') {
        currentSegment.text += '}';
        pos += 2;
        continue;
      } else if (text.substr(pos, 2) === '\\~') {
        currentSegment.text += "\u00A0";
        pos += 2;
        continue;
      }
      // ── New inline commands based on the MTEXT docs ──
      else if (text.substr(pos, 2) === '\\A') {
        pos += 2;
        let arg = "";
        while (pos < text.length && /[0-9\-]/.test(text[pos])) {
          arg += text[pos];
          pos++;
        }
        if (text[pos] === ';') pos++;
        // Save the inline alignment (0, 1 or 2) in the style.
        currentStyle.inlineAlignment = parseInt(arg, 10) || 0;
        continue;
      } else if (text.substr(pos, 2) === '\\W') {
        pos += 2;
        let arg = "";
        while (pos < text.length && /[0-9eE\.\+\-]/.test(text[pos])) {
          arg += text[pos];
          pos++;
        }
        if (text[pos] === 'x') pos++;
        if (text[pos] === ';') pos++;
        currentStyle.widthScale = parseFloat(arg) || 1;
        continue;
      } else if (text.substr(pos, 2) === '\\T') {
        pos += 2;
        let arg = "";
        while (pos < text.length && /[0-9eE\.\+\-]/.test(text[pos])) {
          arg += text[pos];
          pos++;
        }
        if (text[pos] === ';') pos++;
        currentStyle.tracking = parseFloat(arg) || 0;
        continue;
      } else if (text.substr(pos, 2) === '\\Q') {
        pos += 2;
        let arg = "";
        while (pos < text.length && /[0-9eE\.\+\-]/.test(text[pos])) {
          arg += text[pos];
          pos++;
        }
        if (text[pos] === ';') pos++;
        currentStyle.oblique = parseFloat(arg) || 0;
        continue;
      } else if (text.substr(pos, 2) === '\\F') {
        pos += 2;
        let fontName = "";
        while (pos < text.length && text[pos] !== ';') {
          fontName += text[pos];
          pos++;
        }
        if (text[pos] === ';') pos++;
        currentStyle.font = fontName;
        continue;
      } else {
        currentSegment.text += ch;
        pos++;
      }
    } else {
      currentSegment.text += ch;
      pos++;
    }
  }
  if (currentSegment.text) segments.push(currentSegment);
  return { segments: segments, pos: pos };
}
      function parseGroup(text, pos, currentStyle) {
        if (text.substr(pos, 2) === '\\H') {
          pos += 2;
          let multiplierStr = "";
          while (pos < text.length && text[pos] !== 'x') {
            multiplierStr += text[pos];
            pos++;
          }
          let multiplier = parseFloat(multiplierStr);
          pos++; // skip 'x'
          if (text[pos] === ';') pos++;
          let newStyle = Object.assign({}, currentStyle);
          newStyle.scale = currentStyle.scale * multiplier;
          let result = parseFormattedText(text, pos, newStyle);
          return { segments: result.segments, pos: result.pos };
        } else if (text.substr(pos, 2) === '\\F') {
          pos += 2;
          let fontName = "";
          while (pos < text.length && text[pos] !== ';') {
            fontName += text[pos];
            pos++;
          }
          if (text[pos] === ';') pos++;
          let newStyle = Object.assign({}, currentStyle);
          newStyle.font = fontName;
          let result = parseFormattedText(text, pos, newStyle);
          return { segments: result.segments, pos: result.pos };
        } else {
          return parseFormattedText(text, pos, currentStyle);
        }
      }
function measureSegment(segment, defaultSize, viewport) {
  let size = defaultSize * (segment.style.scale || 1) * viewport.viewScale;
  let font = segment.style.font || "sans-serif";
  let weight = segment.style.bold ? "bold " : "";
  let italic = segment.style.italic ? "italic " : "";
  let ctx = measureSegment.ctx || (measureSegment.ctx = document.createElement("canvas").getContext("2d"));
  ctx.font = italic + weight + size + "px " + font;
  let measured = ctx.measureText(segment.text).width;
  if (segment.style.tracking) {
    measured += segment.text.length > 0 ? segment.style.tracking * (segment.text.length - 1) : 0;
  }
  if (segment.style.widthScale) {
    measured *= segment.style.widthScale;
  }
  return measured;
}
      function wrapMTEXTSegments(segments, maxWidth, defaultSize, viewport) {
        let lines = [];
        let currentLine = [];
        let currentLineWidth = 0;
        segments.forEach(seg => {
          if (seg.paragraphBreak) {
            lines.push(currentLine);
            currentLine = [];
            currentLineWidth = 0;
            return;
          }
          let tokens = seg.text.split(/(\s+)/);
          tokens.forEach(token => {
            if (token === "") return;
            let tokenSegment = { text: token, style: seg.style };
            let tokenWidth = measureSegment(tokenSegment, defaultSize, viewport);
            if (currentLineWidth + tokenWidth > maxWidth && currentLine.length > 0) {
              lines.push(currentLine);
              currentLine = [];
              currentLineWidth = 0;
            }
            currentLine.push(tokenSegment);
            currentLineWidth += tokenWidth;
          });
        });
        if (currentLine.length > 0) lines.push(currentLine);
        return lines;
      }

      // ─────────────────────────────────────────────────────────────
      // DXF Style Helpers
      // ─────────────────────────────────────────────────────────────

      class DXFStyle {
        static ACI_COLORS = {
          0: "#000000", 1: "#FF0000", 2: "#FFFF00", 3: "#00FF00", 4: "#00FFFF",
          5: "#0000FF", 6: "#FF00FF", 7: "#FFFFFF", 8: "#808080", 9: "#C0C0C0",
          10: "#FF6600", 11: "#FF9900", 12: "#FFCC00", 13: "#CCFF00", 14: "#99FF00",
          15: "#66FF00", 16: "#33FF00", 17: "#00FF33", 18: "#00FF66", 19: "#00FF99"
        };
        static getACIColor(aci) {
          if (DXFStyle.ACI_COLORS.hasOwnProperty(aci)) {
            return DXFStyle.ACI_COLORS[aci];
          }
          return DXFStyle.ACI_COLORS[7] || "#FFFFFF";
        }
        static getEntityColor(entity, dxfDoc) {
          if (!renderSettings.renderColor) return DXFStyle.ACI_COLORS[7];
          if (entity.raw["420"]) {
            let tc = parseInt(entity.raw["420"]);
            let hex = tc.toString(16).padStart(6, "0");
            return "#" + hex;
          }
          let colorIndex = parseInt(entity.raw["62"]);
          if (isNaN(colorIndex)) colorIndex = 256;
          if (colorIndex === 257) colorIndex = 7;
          if (colorIndex === 0 || colorIndex === 256) {
            let layerName = entity.raw["8"];
            if (layerName && dxfDoc.layers && dxfDoc.layers[layerName] && dxfDoc.layers[layerName]["62"]) {
              colorIndex = parseInt(dxfDoc.layers[layerName]["62"]);
              if (colorIndex === 257) colorIndex = 7;
            } else {
              colorIndex = 7;
            }
          }
          return DXFStyle.getACIColor(colorIndex);
        }
        static getLineWidth(entity, viewport) {
          if (!renderSettings.renderThickness) return 1 / viewport.viewScale;
          let width;
          if (entity.raw["39"] && parseFloat(entity.raw["39"]) !== 0) {
            let thickness = parseFloat(entity.raw["39"]);
            width = Math.max(1, thickness * 3.78);
          } else if (entity.raw["370"]) {
            let lw_mm = parseInt(entity.raw["370"]) / 100;
            width = Math.max(1, lw_mm * 3.78);
          } else {
            width = 1;
          }
          return renderSettings.renderWidth ? width / viewport.viewScale : width;
        }
        static getEntityLineDash(entity, viewport, dxfDoc) {
          if (!renderSettings.renderLinetype) return [];
          let linetypeName = entity.raw["6"];
          if (!linetypeName || linetypeName.toUpperCase() === "BYLAYER") {
            let layerName = entity.raw["8"];
            if (layerName && dxfDoc.layers && dxfDoc.layers[layerName] && dxfDoc.layers[layerName]["6"]) {
              linetypeName = dxfDoc.layers[layerName]["6"];
            }
          }
          if (!linetypeName) return [];
          linetypeName = linetypeName.toUpperCase();
          let patternScale = 1.0;
          if (entity.raw["48"]) patternScale = parseFloat(entity.raw["48"]) || 1.0;
          if (dxfDoc.linetypes && dxfDoc.linetypes[linetypeName]) {
            let ltype = dxfDoc.linetypes[linetypeName];
            if (ltype.pattern && ltype.pattern.length > 0) {
              const dashArray = ltype.pattern.map(d => {
                const absValue = Math.abs(d);
                const dashLength = (absValue === 0 ? 0.5 : absValue);
                return dashLength * viewport.viewScale * patternScale;
              });
              return dashArray;
            }
          }
          return [];
        }
      }

      // ─────────────────────────────────────────────────────────────
      // Base DXF Entity Class
      // ─────────────────────────────────────────────────────────────
      class DXFEntity {
        constructor(type) {
          this.type = type;
          this.raw = {};
        }
        getColor(dxfDoc) {
          return DXFStyle.getEntityColor(this, dxfDoc);
        }
        getLineWidth(viewport) {
          return DXFStyle.getLineWidth(this, viewport);
        }
        getLineDash(viewport, dxfDoc) {
          return DXFStyle.getEntityLineDash(this, viewport, dxfDoc);
        }
        applyStyle(ctx, viewport, dxfDoc) {
          ctx.setLineDash([]);
          ctx.lineWidth = this.getLineWidth(viewport);
          let color = this.getColor(dxfDoc);
          ctx.strokeStyle = color;
          ctx.fillStyle = color;
          let dash = this.getLineDash(viewport, dxfDoc);
          if (dash && dash.length > 0) ctx.setLineDash(dash);
          if (renderSettings.renderTransparency && this.raw["440"] !== undefined) {
            let transpValue = parseInt(this.raw["440"], 10);
            ctx.globalAlpha = 1 - (transpValue / 255);
          } else {
            ctx.globalAlpha = 1;
          }
        }
      }

      // ─────────────────────────────────────────────────────────────
      // DXF Entity Classes (Most remain unchanged)
      // ─────────────────────────────────────────────────────────────

      class DXFLine extends DXFEntity {
        constructor() {
          super("LINE");
          this.x1 = 0; this.y1 = 0;
          this.x2 = 0; this.y2 = 0;
        }
        static parse(lines, i) {
          let line = new DXFLine();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": line.x1 = parseFloat(value); break;
              case "20": line.y1 = parseFloat(value); break;
              case "11": line.x2 = parseFloat(value); break;
              case "21": line.y2 = parseFloat(value); break;
              default: line.raw[code] = value; break;
            }
            i += 2;
          }
          return { entity: line, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["LINE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.moveTo(this.x1, this.y1);
          ctx.lineTo(this.x2, this.y2);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFCircle extends DXFEntity {
        constructor() {
          super("CIRCLE");
          this.cx = 0; this.cy = 0; this.r = 0;
        }
        static parse(lines, i) {
          let circle = new DXFCircle();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": circle.cx = parseFloat(value); break;
              case "20": circle.cy = parseFloat(value); break;
              case "40": circle.r = parseFloat(value); break;
              default: circle.raw[code] = value; break;
            }
            i += 2;
          }
          return { entity: circle, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["CIRCLE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.arc(this.cx, this.cy, this.r, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFArc extends DXFEntity {
        constructor() {
          super("ARC");
          this.cx = 0; this.cy = 0; this.r = 0;
          this.startAngle = 0; this.endAngle = 0;
        }
        static parse(lines, i) {
          let arc = new DXFArc();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": arc.cx = parseFloat(value); break;
              case "20": arc.cy = parseFloat(value); break;
              case "40": arc.r = parseFloat(value); break;
              case "50": arc.startAngle = parseFloat(value); break;
              case "51": arc.endAngle = parseFloat(value); break;
              default: arc.raw[code] = value; break;
            }
            i += 2;
          }
          return { entity: arc, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["ARC"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let startRad = DXFUtils.degToRad(this.startAngle);
          let endRad = DXFUtils.degToRad(this.endAngle);
          if (endRad < startRad) endRad += 2 * Math.PI;
          ctx.beginPath();
          ctx.arc(this.cx, this.cy, this.r, startRad, endRad);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFPolyline extends DXFEntity {
        constructor() {
          super("POLYLINE");
          this.vertices = [];
          this.closed = false;
        }
        static parse(lines, i) {
          let polyline = new DXFPolyline();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0" && (lines[i + 1] || "").trim() === "VERTEX") break;
            if (code === "0" && (lines[i + 1] || "").trim() === "SEQEND") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "70") {
              let flag = parseInt(value);
              polyline.closed = (flag & 1) !== 0;
            } else {
              polyline.raw[code] = value;
            }
            i += 2;
          }
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "SEQEND") {
              i += 2;
              break;
            }
            if (code === "0" && value === "VERTEX") {
              i += 2;
              let vx = 0, vy = 0;
              while (i < lines.length) {
                let vCode = lines[i].trim();
                if (vCode === "0") break;
                let vValue = (lines[i + 1] || "").trim();
                if (vCode === "10") vx = parseFloat(vValue);
                else if (vCode === "20") vy = parseFloat(vValue);
                i += 2;
              }
              polyline.vertices.push({ x: vx, y: vy });
            } else {
              i += 2;
            }
          }
          return { entity: polyline, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["POLYLINE"]) return;
          if (this.vertices.length === 0) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
          for (let j = 1; j < this.vertices.length; j++) {
            ctx.lineTo(this.vertices[j].x, this.vertices[j].y);
          }
          if (this.closed) ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFLwPolyline extends DXFEntity {
        constructor() {
          super("LWPOLYLINE");
          this.vertices = [];
          this.closed = false;
        }
        static parse(lines, i) {
          let lwpoly = new DXFLwPolyline();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "70":
                lwpoly.closed = (parseInt(value, 10) & 1) !== 0;
                break;
              case "10": {
                let x = parseFloat(value);
                let y = 0;
                let oldI = i;
                i += 2;
                if (i < lines.length && lines[i].trim() === "20") {
                  y = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                } else {
                  i = oldI + 2;
                }
                let bulge = 0;
                if (i < lines.length && lines[i].trim() === "42") {
                  bulge = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                }
                lwpoly.vertices.push({ x, y, bulge });
                continue;
              }
              default:
                lwpoly.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: lwpoly, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["LWPOLYLINE"]) return;
          if (this.vertices.length === 0) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          for (let j = 0; j < this.vertices.length; j++) {
            let curr = this.vertices[j];
            let next = this.vertices[(j + 1) % this.vertices.length];
            if (j === 0) ctx.moveTo(curr.x, curr.y);
            if (!this.closed && j === this.vertices.length - 1) break;
            let bulge = curr.bulge || 0;
            if (Math.abs(bulge) > 1e-9) {
              let chord = getDistance(curr, next);
              let theta = 4 * Math.atan(Math.abs(bulge));
              let midpoint = getCenter(curr, next);
              let dx = (next.x - curr.x), dy = (next.y - curr.y);
              let chordAngle = Math.atan2(dy, dx);
              let radius = chord / (2 * Math.sin(theta / 2));
              let ccw = bulge > 0;
              let startAngle = Math.atan2(curr.y - midpoint.y, curr.x - midpoint.x);
              let endAngle = Math.atan2(next.y - midpoint.y, next.x - midpoint.x);
              ctx.arc(midpoint.x, midpoint.y, radius, startAngle, endAngle, !ccw);
            } else {
              ctx.lineTo(next.x, next.y);
            }
          }
          if (this.closed) ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // ─────────────────────────────────────────────────────────────
      // Updated HATCH with Improved DXF/AutoCAD Compliance
      // ─────────────────────────────────────────────────────────────

      // Helper functions for sampling arcs and ellipses
      function sampleArc(center, radius, startAngle, endAngle, numSegments = 20) {
        let points = [];
        for (let i = 0; i <= numSegments; i++) {
          let t = startAngle + (endAngle - startAngle) * (i / numSegments);
          points.push({ x: center.x + radius * Math.cos(t), y: center.y + radius * Math.sin(t) });
        }
        return points;
      }
      function sampleEllipse(center, major, minor, rotation, startParam, endParam, numSegments = 20) {
        let points = [];
        if (endParam < startParam) endParam += 2 * Math.PI;
        for (let i = 0; i <= numSegments; i++) {
          let t = startParam + (endParam - startParam) * (i / numSegments);
          let x = center.x + major * Math.cos(t) * Math.cos(rotation) - minor * Math.sin(t) * Math.sin(rotation);
          let y = center.y + major * Math.cos(t) * Math.sin(rotation) + minor * Math.sin(t) * Math.cos(rotation);
          points.push({ x, y });
        }
        return points;
      }

      class DXFHatch extends DXFEntity {
        constructor() {
          super("HATCH");
          this.boundaryLoops = [];
          this.isSolid = false;
          this.patternName = "";
          // New hatch pattern properties (default values)
          this.patternAngle = 0; // in degrees
          this.patternScale = 1;
          this.patternOffset = { x: 0, y: 0 }; // available for future use
        }

        static parse(lines, i) {
          let hatch = new DXFHatch();
          i += 2;
          let loopCount = 0;
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0") break;
            switch (code) {
              case "70":
                hatch.isSolid = (parseInt(value, 10) & 1) !== 0;
                break;
              case "2":
                hatch.patternName = value.toUpperCase();
                break;
              case "91":
                loopCount = parseInt(value, 10);
                break;
              case "92": {
                let edgeCount = parseInt(value, 10);
                let loopPoints = [];
                for (let j = 0; j < edgeCount; j++) {
                  i += 2;
                  if (i >= lines.length) break;
                  let edgeTypeCode = lines[i - 2].trim();
                  let edgeTypeVal = lines[i - 1].trim();
                  let edgeType = (edgeTypeCode === "72") ? parseInt(edgeTypeVal, 10) : 1;
                  let edgePoints = [];
                  if (edgeType === 1) {
                    // Straight line edge
                    let start = { x: 0, y: 0 }, end = { x: 0, y: 0 };
                    while (i < lines.length) {
                      let c = lines[i].trim();
                      let v = (lines[i + 1] || "").trim();
                      if (c === "10") { start.x = parseFloat(v); }
                      else if (c === "20") { start.y = parseFloat(v); }
                      else if (c === "11") { end.x = parseFloat(v); }
                      else if (c === "21") { end.y = parseFloat(v); }
                      else break;
                      i += 2;
                    }
                    edgePoints = [start, end];
                  } else if (edgeType === 2) {
                    // Circular arc edge
                    let center = { x: 0, y: 0 }, radius = 0, startAngle = 0, endAngle = 0;
                    while (i < lines.length) {
                      let c = lines[i].trim();
                      let v = (lines[i + 1] || "").trim();
                      if (c === "10") { center.x = parseFloat(v); }
                      else if (c === "20") { center.y = parseFloat(v); }
                      else if (c === "40") { radius = parseFloat(v); }
                      else if (c === "50") { startAngle = DXFUtils.degToRad(parseFloat(v)); }
                      else if (c === "51") { endAngle = DXFUtils.degToRad(parseFloat(v)); }
                      else break;
                      i += 2;
                    }
                    if (endAngle < startAngle) endAngle += 2 * Math.PI;
                    edgePoints = sampleArc(center, radius, startAngle, endAngle);
                  } else if (edgeType === 3) {
                    // Elliptical arc edge
                    let center = { x: 0, y: 0 },
                      majorVec = { x: 0, y: 0 },
                      ratio = 1,
                      startParam = 0,
                      endParam = 0;
                    while (i < lines.length) {
                      let c = lines[i].trim();
                      let v = (lines[i + 1] || "").trim();
                      if (c === "10") { center.x = parseFloat(v); }
                      else if (c === "20") { center.y = parseFloat(v); }
                      else if (c === "11") { majorVec.x = parseFloat(v); }
                      else if (c === "21") { majorVec.y = parseFloat(v); }
                      else if (c === "40") { ratio = parseFloat(v); }
                      else if (c === "50") { startParam = parseFloat(v); }
                      else if (c === "51") { endParam = parseFloat(v); }
                      else break;
                      i += 2;
                    }
                    let majorLength = Math.sqrt(majorVec.x * majorVec.x + majorVec.y * majorVec.y);
                    let minorLength = majorLength * ratio;
                    let rotation = Math.atan2(majorVec.y, majorVec.x);
                    edgePoints = sampleEllipse(center, majorLength, minorLength, rotation, startParam, endParam);
                  } else if (edgeType === 4) {
                    // Spline edge (minimal approximation)
                    let splinePoints = [];
                    while (i < lines.length) {
                      let c = lines[i].trim();
                      if (["0", "92", "93"].includes(c)) break;
                      if (c === "10") {
                        let x = parseFloat(lines[i + 1].trim());
                        i += 2;
                        let y = 0;
                        if (i < lines.length && lines[i].trim() === "20") {
                          y = parseFloat(lines[i + 1].trim());
                          i += 2;
                        }
                        splinePoints.push({ x, y });
                      } else {
                        i += 2;
                      }
                    }
                    edgePoints = splinePoints;
                  } else {
                    // Unhandled edge type: skip until a recognizable code
                    while (i < lines.length) {
                      let c = lines[i].trim();
                      if (c === "0" || c === "92" || c === "93") break;
                      i += 2;
                    }
                    edgePoints = [];
                  }
                  // Remove duplicate point if necessary
                  if (loopPoints.length > 0 && edgePoints.length > 0) {
                    let last = loopPoints[loopPoints.length - 1];
                    let first = edgePoints[0];
                    if (Math.abs(last.x - first.x) < 1e-6 && Math.abs(last.y - first.y) < 1e-6) {
                      edgePoints.shift();
                    }
                  }
                  loopPoints.push(...edgePoints);
                }
                hatch.boundaryLoops.push(loopPoints);
                break; // done with this boundary loop
              }
              default:
                // For any other group codes, store them in the raw object.
                hatch.raw[code] = value;
                break;
            }
            i += 2;
          }
          // Extract hatch pattern properties from raw data if available.
          if (hatch.raw["52"]) {
            hatch.patternAngle = parseFloat(hatch.raw["52"]);
          }
          if (hatch.raw["41"]) {
            hatch.patternScale = parseFloat(hatch.raw["41"]);
          }
          return { entity: hatch, nextIndex: i };
        }

        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["HATCH"]) return;
          if (this.boundaryLoops.length === 0) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let fillColor = this.getColor(dxfDoc);
          ctx.save();
          if (this.isSolid || (this.patternName && this.patternName.includes("SOLID"))) {
            // Solid fill hatch: fill and stroke the hatch boundaries.
            ctx.fillStyle = fillColor;
            this.drawLoopsPath(ctx);
            ctx.fill();
            ctx.strokeStyle = fillColor;
            ctx.lineWidth = 1 / viewport.viewScale;
            ctx.stroke();
          } else {
            // Pattern hatch: first clip to the hatch boundary.
            this.drawLoopsPath(ctx);
            ctx.clip();

            let bbox = computeBBox(this.boundaryLoops);
            let patternAngleRad = DXFUtils.degToRad(this.patternAngle);
            let spacing = (this.patternScale || 1) * 10;

            // Use the lower–left corner of the bounding box as the pattern origin.
            let origin = { x: bbox.minX, y: bbox.minY };

            // Compute the rotated bounding box in pattern space (relative to the origin).
            let corners = [
              { x: bbox.minX, y: bbox.minY },
              { x: bbox.maxX, y: bbox.minY },
              { x: bbox.maxX, y: bbox.maxY },
              { x: bbox.minX, y: bbox.maxY }
            ].map(pt => {
              // Translate to origin then rotate
              return DXFUtils.rotatePoint(pt.x - origin.x, pt.y - origin.y, -patternAngleRad);
            });
            let rMinX = Math.min(...corners.map(p => p.x));
            let rMaxX = Math.max(...corners.map(p => p.x));
            let rMinY = Math.min(...corners.map(p => p.y));
            let rMaxY = Math.max(...corners.map(p => p.y));

            // Snap the starting Y value to a multiple of spacing.
            let startY = Math.floor(rMinY / spacing) * spacing;

            ctx.beginPath();
            // Draw horizontal lines in pattern space, then rotate back and translate by origin.
            for (let rY = startY; rY <= rMaxY + spacing; rY += spacing) {
              let startPt = DXFUtils.rotatePoint(rMinX, rY, patternAngleRad);
              let endPt   = DXFUtils.rotatePoint(rMaxX, rY, patternAngleRad);
              startPt.x += origin.x; startPt.y += origin.y;
              endPt.x   += origin.x; endPt.y   += origin.y;
              ctx.moveTo(startPt.x, startPt.y);
              ctx.lineTo(endPt.x, endPt.y);
            }
            ctx.strokeStyle = fillColor;
            ctx.lineWidth = 1 / viewport.viewScale;
            ctx.stroke();
          }
          ctx.restore();
          ctx.globalAlpha = 1;
        }

        drawLoopsPath(ctx) {
          ctx.beginPath();
          this.boundaryLoops.forEach(loop => {
            if (loop.length > 0) {
              ctx.moveTo(loop[0].x, loop[0].y);
              for (let i = 1; i < loop.length; i++) {
                ctx.lineTo(loop[i].x, loop[i].y);
              }
              ctx.closePath();
            }
          });
        }
      }

      class DXFDimension extends DXFEntity {
        constructor() {
          super("DIMENSION");
          this.p1 = { x: 0, y: 0 };
          this.p2 = { x: 0, y: 0 };
          this.defPt = null;
          this.text = "";
        }
        static parse(lines, i) {
          let dim = new DXFDimension();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": dim.p1.x = parseFloat(value); break;
              case "20": dim.p1.y = parseFloat(value); break;
              case "11": dim.p2.x = parseFloat(value); break;
              case "21": dim.p2.y = parseFloat(value); break;
              case "13":
              case "23":
                if (!dim.defPt) dim.defPt = { x: 0, y: 0 };
                if (code === "13") dim.defPt.x = parseFloat(value);
                else dim.defPt.y = parseFloat(value);
                break;
              case "1":
                dim.text = value;
                break;
              default:
                dim.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: dim, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["DIMENSION"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let p1 = this.p1, p2 = this.p2;
          let dx = p2.x - p1.x, dy = p2.y - p1.y;
          let baselineLength = Math.sqrt(dx * dx + dy * dy);
          if (baselineLength < 1e-9) {
            ctx.globalAlpha = 1;
            return;
          }
          let u = { x: dx / baselineLength, y: dy / baselineLength };
          let v = { x: -u.y, y: u.x };
          let mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
          let offsetDistance = 5;
          if (this.defPt) {
            let mx = mid.x, my = mid.y;
            offsetDistance = (this.defPt.x - mx) * v.x + (this.defPt.y - my) * v.y;
          }
          let p1_dim = { x: p1.x + v.x * offsetDistance, y: p1.y + v.y * offsetDistance };
          let p2_dim = { x: p2.x + v.x * offsetDistance, y: p2.y + v.y * offsetDistance };
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p1_dim.x, p1_dim.y);
          ctx.moveTo(p2.x, p2.y);
          ctx.lineTo(p2_dim.x, p2_dim.y);
          ctx.moveTo(p1_dim.x, p1_dim.y);
          ctx.lineTo(p2_dim.x, p2_dim.y);
          ctx.stroke();
          function drawArrow(pt, direction) {
            const arrowSize = 3;
            const arrowAngle = Math.PI / 6;
            let leftAngle = Math.atan2(direction.y, direction.x) + arrowAngle;
            let rightAngle = Math.atan2(direction.y, direction.x) - arrowAngle;
            let left = { x: pt.x - arrowSize * Math.cos(leftAngle), y: pt.y - arrowSize * Math.sin(leftAngle) };
            let right = { x: pt.x - arrowSize * Math.cos(rightAngle), y: pt.y - arrowSize * Math.sin(rightAngle) };
            ctx.beginPath();
            ctx.moveTo(pt.x, pt.y);
            ctx.lineTo(left.x, left.y);
            ctx.lineTo(right.x, right.y);
            ctx.closePath();
            ctx.fill();
          }
          let arrowDir = { x: p2_dim.x - p1_dim.x, y: p2_dim.y - p1_dim.y };
          let arrowLen = Math.sqrt(arrowDir.x * arrowDir.x + arrowDir.y * arrowDir.y);
          if (arrowLen > 1e-9) {
            arrowDir.x /= arrowLen; arrowDir.y /= arrowLen;
            drawArrow(p1_dim, arrowDir);
            drawArrow(p2_dim, { x: -arrowDir.x, y: -arrowDir.y });
          }
          let dimText = this.text.trim();
          if (!dimText || dimText === "<>") {
            dimText = baselineLength.toFixed(2);
          }
          let dimLineMid = { x: (p1_dim.x + p2_dim.x) / 2, y: (p1_dim.y + p2_dim.y) / 2 };
          let angle = Math.atan2(u.y, u.x);
          if (angle > Math.PI / 2 || angle < -Math.PI / 2) angle += Math.PI;
          ctx.save();
          ctx.translate(dimLineMid.x, dimLineMid.y);
          ctx.rotate(angle);
          ctx.font = "12px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(dimText, 0, 0);
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      }

      class DXFMTEXT extends DXFEntity {
        constructor() {
          super("MTEXT");
          this.position = { x: 0, y: 0 };
          this.height = 12;
          this.rotation = 0;
          this.rawText = "";
          this.font = "sans-serif";
          this.maxWidth = 0;
          this.align = 1;
        }
        static parse(lines, i) {
          let mtext = new DXFMTEXT();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": mtext.position.x = parseFloat(value); break;
              case "20": mtext.position.y = parseFloat(value); break;
              case "40": mtext.height = parseFloat(value); break;
              case "50": mtext.rotation = parseFloat(value); break;
              case "1":
              case "3":
                mtext.rawText += value;
                break;
              case "7": mtext.font = value; break;
              case "41": mtext.maxWidth = parseFloat(value); break;
              case "71": mtext.align = parseInt(value); break;
              default:
                mtext.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: mtext, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["MTEXT"]) return;
          let { x, y } = this.position;
          let defaultSize = this.height;
          let rotation = this.rotation ? DXFUtils.degToRad(this.rotation) : 0;
          let rawText = this.rawText || "";
          let defaultFont = this.font || "sans-serif";
          let defaultColor = this.getColor(dxfDoc);
          this.applyStyle(ctx, viewport, dxfDoc);
          let parsedSegments = parseMTEXTContent(rawText, defaultSize, defaultFont, defaultColor);
          let paragraphs = [], currentParagraph = [];
          parsedSegments.forEach(seg => {
            if (seg.paragraphBreak) {
              paragraphs.push(currentParagraph);
              currentParagraph = [];
            } else {
              currentParagraph.push(seg);
            }
          });
          if (currentParagraph.length > 0) paragraphs.push(currentParagraph);
          let maxWidth = this.maxWidth || 0;
          let wrappedLines = [];
          let maxWidthScreen = maxWidth * viewport.viewScale;
          if (maxWidth > 0) {
            paragraphs.forEach(para => {
              let lines = wrapMTEXTSegments(para, maxWidthScreen, defaultSize, viewport);
              wrappedLines.push(...lines);
            });
          } else {
            wrappedLines = paragraphs;
          }
          let align = this.align || 1;
          let hAlign = align % 3; 
          if (hAlign === 0) hAlign = 3; 
          let vAlign = Math.floor((align - 1) / 3);
          let lineHeight = defaultSize * viewport.viewScale * 1.2;
          let totalHeight = wrappedLines.length * lineHeight;
          let lineWidths = [];
          let maxLineWidth = 0;
          wrappedLines.forEach(line => {
            let width = line.reduce((sum, seg) => sum + measureSegment(seg, defaultSize, viewport), 0);
            lineWidths.push(width);
            if (width > maxLineWidth) maxLineWidth = width;
          });
          let offsetY = 0;
          if (vAlign === 1) offsetY = -totalHeight / 2;
          else if (vAlign === 2) offsetY = -totalHeight;
          ctx.save();
          let screenPos = viewport.worldToScreen(x, y);
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(-rotation);
          ctx.translate(0, offsetY);
          for (let i = 0; i < wrappedLines.length; i++) {
            let line = wrappedLines[i];
            let lw = lineWidths[i];
            let offsetX = 0;
            if (hAlign === 2) offsetX = (maxLineWidth - lw) / 2;
            else if (hAlign === 3) offsetX = (maxLineWidth - lw);
            ctx.save();
            ctx.translate(offsetX, i * lineHeight);
            let xPos = 0;
line.forEach(seg => {
  ctx.save();
  let segSize = defaultSize * (seg.style.scale || 1) * viewport.viewScale;
  let segFont = seg.style.font || defaultFont;
  let segWeight = seg.style.bold ? "bold " : "";
  let segItalic = seg.style.italic ? "italic " : "";
  ctx.font = segItalic + segWeight + segSize + "px " + segFont;
  ctx.fillStyle = seg.style.color || defaultColor;
  ctx.textBaseline = "alphabetic";
  let tracking = seg.style.tracking || 0;
  let widthScale = seg.style.widthScale || 1;
  let oblique = seg.style.oblique || 0;
  // If an oblique angle is set, apply a horizontal skew:
  if (oblique !== 0) {
    let tanOblique = Math.tan(oblique * Math.PI / 180);
    ctx.transform(1, 0, tanOblique, 1, 0, 0);
  }
  // Draw the text; if tracking or widthScale is in effect, do character‐by‐character:
  if (tracking !== 0 || widthScale !== 1 || oblique !== 0) {
    for (let j = 0; j < seg.text.length; j++) {
      let ch = seg.text[j];
      ctx.fillText(ch, xPos, 0);
      let charWidth = ctx.measureText(ch).width;
      xPos += (charWidth + tracking) * widthScale;
    }
  } else {
    ctx.fillText(seg.text, xPos, 0);
    xPos += ctx.measureText(seg.text).width;
  }
  // (Underline/overline drawing remains essentially the same.)
  if (seg.style.underline) {
    let metrics = ctx.measureText(seg.text);
    let underlineY = (metrics.actualBoundingBoxDescent !== undefined)
      ? metrics.actualBoundingBoxDescent + 2 : segSize * 0.3;
    ctx.beginPath();
    ctx.moveTo(xPos - ctx.measureText(seg.text).width, underlineY);
    ctx.lineTo(xPos, underlineY);
    ctx.lineWidth = Math.max(1, segSize / 15);
    ctx.strokeStyle = ctx.fillStyle;
    ctx.stroke();
  }
  if (seg.style.overline) {
    let metrics = ctx.measureText(seg.text);
    let overlineY = -(metrics.actualBoundingBoxAscent !== undefined
      ? metrics.actualBoundingBoxAscent : segSize * 0.3);
    ctx.beginPath();
    ctx.moveTo(xPos - ctx.measureText(seg.text).width, overlineY);
    ctx.lineTo(xPos, overlineY);
    ctx.lineWidth = Math.max(1, segSize / 15);
    ctx.strokeStyle = ctx.fillStyle;
    ctx.stroke();
  }
  ctx.restore();
});
            ctx.restore();
          }
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      }

      class DXFSpline extends DXFEntity {
        constructor() {
          super("SPLINE");
          this.degree = null;
          this.knots = [];
          this.controlPoints = [];
          this.fitPoints = [];
        }
        static parse(lines, i) {
          let spline = new DXFSpline();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "70": spline.raw["70"] = value; break;
              case "71": spline.degree = parseInt(value, 10); break;
              case "72": spline.raw["72"] = value; break;
              case "73": spline.raw["73"] = value; break;
              case "74": spline.raw["74"] = value; break;
              case "40":
                spline.knots.push(parseFloat(value));
                break;
              case "10": {
                let pt = { x: parseFloat(value) };
                i += 2;
                if (i < lines.length && lines[i].trim() === "20") {
                  pt.y = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                } else {
                  pt.y = 0;
                  i -= 2;
                }
                spline.controlPoints.push(pt);
                continue;
              }
              case "11": {
                let pt = { x: parseFloat(value) };
                i += 2;
                if (i < lines.length && lines[i].trim() === "21") {
                  pt.y = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                } else {
                  pt.y = 0;
                  i -= 2;
                }
                spline.fitPoints.push(pt);
                continue;
              }
              default:
                spline.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: spline, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["SPLINE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let samplePoints = [];
          if (this.controlPoints.length >= (this.degree + 1) && this.knots.length > 0 && this.degree != null) {
            let k = this.degree;
            let cp = this.controlPoints;
            let knots = this.knots;
            let t_min = knots[k];
            let t_max = knots[knots.length - k - 1];
            let numSamples = 50;
            for (let i = 0; i <= numSamples; i++) {
              let t = t_min + (t_max - t_min) * (i / numSamples);
              let pt = deBoor(k, cp, knots, t);
              samplePoints.push(pt);
            }
          } else if (this.fitPoints && this.fitPoints.length >= 2) {
            samplePoints = this.fitPoints;
          } else {
            return;
          }
          ctx.beginPath();
          ctx.moveTo(samplePoints[0].x, samplePoints[0].y);
          for (let i = 1; i < samplePoints.length; i++) {
            ctx.lineTo(samplePoints[i].x, samplePoints[i].y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }
      function deBoor(k, cp, knots, t) {
        let n = cp.length - 1;
        let i = k;
        for (; i <= n; i++) {
          if (t < knots[i + 1]) break;
        }
        if (i > n) i = n;
        let d = [];
        for (let j = 0; j <= k; j++) {
          d[j] = { x: cp[i - k + j].x, y: cp[i - k + j].y };
        }
        for (let r = 1; r <= k; r++) {
          for (let j = k; j >= r; j--) {
            let idx = i - k + j;
            let denom = knots[idx + k - r + 1] - knots[idx];
            let alpha = (denom === 0) ? 0 : (t - knots[idx]) / denom;
            d[j].x = (1 - alpha) * d[j - 1].x + alpha * d[j].x;
            d[j].y = (1 - alpha) * d[j - 1].y + alpha * d[j].y;
          }
        }
        return d[k];
      }

      class DXFInsert extends DXFEntity {
        constructor() {
          super("INSERT");
          this.blockName = "";
          this.insertionPoint = { x: 0, y: 0 };
          this.scale = { x: 1, y: 1 };
          this.rotation = 0;
          this.attribs = [];
        }
        static parse(lines, i) {
          let insert = new DXFInsert();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "2": insert.blockName = value; break;
              case "10": insert.insertionPoint.x = parseFloat(value); break;
              case "20": insert.insertionPoint.y = parseFloat(value); break;
              case "41": insert.scale.x = parseFloat(value); break;
              case "42": insert.scale.y = parseFloat(value); break;
              case "50": insert.rotation = parseFloat(value); break;
              default:
                insert.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: insert, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["INSERT"]) return;
          let block = dxfDoc.blocks[this.blockName];
          if (!block) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.save();
          let { x: insX, y: insY } = this.insertionPoint;
          let { x: scaleX, y: scaleY } = this.scale;
          let angle = DXFUtils.degToRad(this.rotation);
          let bp = block.basePoint || { x: 0, y: 0 };
          ctx.translate(insX, insY);
          ctx.rotate(angle);
          ctx.scale(scaleX, scaleY);
          ctx.translate(-bp.x, -bp.y);
          block.entities.forEach(e => {
            if (renderSettings.entity[e.type] !== false) {
              e.draw(ctx, viewport, dxfDoc);
            }
          });
          this.attribs.forEach(attr => {
            if (renderSettings.entity[attr.type] !== false) {
              attr.draw(ctx, viewport, dxfDoc);
            }
          });
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      }

      class DXFText extends DXFEntity {
        constructor(type) {
          super(type);
          this.position = { x: 0, y: 0 };
          this.height = 12;
          this.rotation = 0;
          this.text = "";
          this.font = "sans-serif";
        }
        static parse(lines, i) {
          let textEntity = new DXFText((lines[i + 1] || "").trim());
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": textEntity.position.x = parseFloat(value); break;
              case "20": textEntity.position.y = parseFloat(value); break;
              case "40": textEntity.height = parseFloat(value); break;
              case "50": textEntity.rotation = parseFloat(value); break;
              case "1":
              case "3":
                textEntity.text += value;
                break;
              case "7": textEntity.font = value; break;
              default:
                textEntity.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: textEntity, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity[this.type]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let x = this.position.x, y = this.position.y;
          let height = this.height;
          let rotation = this.rotation ? DXFUtils.degToRad(this.rotation) : 0;
          let text = this.text;
          let screen = viewport.worldToScreen(x, y);
          let screenFontSize = height * viewport.viewScale;
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.translate(screen.x, screen.y);
          ctx.rotate(-rotation);
          ctx.fillStyle = this.getColor(dxfDoc);
          ctx.font = screenFontSize + "px " + this.font;
          ctx.textBaseline = "alphabetic";
          ctx.fillText(text, 0, 0);
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      }

      class DXFEllipse extends DXFEntity {
        constructor() {
          super("ELLIPSE");
          this.cx = 0; this.cy = 0;
          this.mx = 0; this.my = 0;
          this.ratio = 1;
          this.startParam = 0;
          this.endParam = 2 * Math.PI;
        }
        static parse(lines, i) {
          let ell = new DXFEllipse();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": ell.cx = parseFloat(value); break;
              case "20": ell.cy = parseFloat(value); break;
              case "11": ell.mx = parseFloat(value); break;
              case "21": ell.my = parseFloat(value); break;
              case "40": ell.ratio = parseFloat(value); break;
              case "41": ell.startParam = parseFloat(value); break;
              case "42": ell.endParam = parseFloat(value); break;
              default: ell.raw[code] = value; break;
            }
            i += 2;
          }
          return { entity: ell, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["ELLIPSE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let rx = Math.sqrt(this.mx * this.mx + this.my * this.my);
          let ry = rx * this.ratio;
          let angle = Math.atan2(this.my, this.mx);
          ctx.save();
          ctx.beginPath();
          ctx.translate(this.cx, this.cy);
          ctx.rotate(angle);
          ctx.ellipse(0, 0, rx, ry, 0, this.startParam, this.endParam);
          ctx.stroke();
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      }

      class DXF3DFace extends DXFEntity {
        constructor() {
          super("3DFACE");
          this.points = [];
        }
        static parse(lines, i) {
          let face = new DXF3DFace();
          i += 2;
          let corners = [];
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10" || code === "11" || code === "12" || code === "13") {
              let x = parseFloat(value);
              i += 2;
              let y = 0;
              if (i < lines.length && lines[i].trim() === (parseInt(code) + 10).toString()) {
                y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                i -= 2;
              }
              corners.push({ x, y });
              continue;
            } else {
              face.raw[code] = value;
            }
            i += 2;
          }
          face.points = corners;
          return { entity: face, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["3DFACE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.points.length < 3) return;
          ctx.beginPath();
          ctx.moveTo(this.points[0].x, this.points[0].y);
          for (let i = 1; i < this.points.length; i++) {
            ctx.lineTo(this.points[i].x, this.points[i].y);
          }
          if (this.points.length === 3 || this.points.length === 4) ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFSolid extends DXFEntity {
        constructor() {
          super("SOLID");
          this.points = [];
        }
        static parse(lines, i) {
          let solid = new DXFSolid();
          i += 2;
          let corners = [];
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10" || code === "11" || code === "12" || code === "13") {
              let x = parseFloat(value);
              i += 2;
              let y = 0;
              if (i < lines.length && lines[i].trim() === (parseInt(code) + 10).toString()) {
                y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                i -= 2;
              }
              corners.push({ x, y });
              continue;
            }
            solid.raw[code] = value;
            i += 2;
          }
          solid.points = corners;
          return { entity: solid, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["SOLID"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.points.length < 3) return;
          ctx.beginPath();
          ctx.moveTo(this.points[0].x, this.points[0].y);
          for (let i = 1; i < this.points.length; i++) {
            ctx.lineTo(this.points[i].x, this.points[i].y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class GenericDXFEntity extends DXFEntity {
        static parse(lines, i) {
          let type = (lines[i + 1] || "").trim();
          let gen = new GenericDXFEntity(type);
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            gen.raw[code] = value;
            i += 2;
          }
          return { entity: gen, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {}
      }

      // ─────────────────────────────────────────────────────────────
      // BLOCK / DOCUMENT CLASSES
      // ─────────────────────────────────────────────────────────────
      class DXFBlock {
        constructor(name) {
          this.name = name;
          this.basePoint = { x: 0, y: 0 };
          this.entities = [];
        }
      }
      class DXFDocument {
        constructor() {
          this.entities = [];
          this.blocks = {};
          this.layers = {};
          this.linetypes = {};
        }
      }

      // ─────────────────────────────────────────────────────────────
      // DXF PARSER CLASS
      // ─────────────────────────────────────────────────────────────
      class DXFParser {
        parse(text) {
          const lines = text.split(/\r\n|\n/);
          let dxf = new DXFDocument();
          let i = 0;
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "SECTION") {
              i += 2;
              if (lines[i]?.trim() === "2") {
                let sectionName = (lines[i + 1] || "").trim();
                i += 2;
                switch (sectionName) {
                  case "TABLES":
                    let tablesResult = this.parseTables(lines, i);
                    dxf.layers = tablesResult.layers;
                    dxf.linetypes = tablesResult.linetypes;
                    i = tablesResult.nextIndex;
                    break;
                  case "BLOCKS":
                    i = this.parseBlocks(lines, i, dxf);
                    break;
                  case "ENTITIES":
                    i = this.parseEntities(lines, i, dxf);
                    break;
                  default:
                    while (i < lines.length) {
                      if (lines[i].trim() === "0" && (lines[i + 1] || "").trim() === "ENDSEC") {
                        i += 2;
                        break;
                      }
                      i += 2;
                    }
                    break;
                }
              }
            } else {
              i += 2;
            }
          }
          return dxf;
        }
        parseTables(lines, i) {
          let layers = {}, linetypes = {};
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "ENDSEC") {
              i += 2;
              break;
            }
            if (code === "0" && value === "TABLE") {
              i += 2;
              let tableName = (lines[i + 1] || "").trim();
              i += 2;
              if (tableName === "LAYER") {
                while (i < lines.length) {
                  let c = lines[i].trim();
                  let v = (lines[i + 1] || "").trim();
                  if (c === "0" && (v === "ENDTAB" || v === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  if (c === "0" && v === "LAYER") {
                    let layer = {};
                    i += 2;
                    while (i < lines.length) {
                      let lc = lines[i].trim();
                      if (lc === "0") break;
                      let lv = (lines[i + 1] || "").trim();
                      if (lc === "2") layer.name = lv;
                      else if (lc === "62") layer["62"] = lv;
                      else if (lc === "6") layer["6"] = lv;
                      i += 2;
                    }
                    if (layer.name) layers[layer.name] = layer;
                  } else {
                    i += 2;
                  }
                }
              } else if (tableName === "LTYPE") {
                while (i < lines.length) {
                  let c = lines[i].trim();
                  let v = (lines[i + 1] || "").trim();
                  if (c === "0" && (v === "ENDTAB" || v === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  if (c === "0" && v === "LTYPE") {
                    let lt = {};
                    i += 2;
                    while (i < lines.length) {
                      let lc = lines[i].trim();
                      if (lc === "0") break;
                      let lv = (lines[i + 1] || "").trim();
                      if (lc === "2") lt.name = lv;
                      else if (lc === "3") lt.description = lv;
                      else if (lc === "72") lt.flags = lv;
                      else if (lc === "73") lt.elements = parseInt(lv, 10);
                      else if (lc === "40") lt.patternLength = parseFloat(lv);
                      else if (lc === "49") {
                        if (!lt.pattern) lt.pattern = [];
                        lt.pattern.push(parseFloat(lv));
                      }
                      i += 2;
                    }
                    if (lt.name) {
                      linetypes[lt.name] = lt;
                    }
                  } else {
                    i += 2;
                  }
                }
              } else {
                while (i < lines.length) {
                  let c = lines[i].trim();
                  let v = (lines[i + 1] || "").trim();
                  if (c === "0" && (v === "ENDTAB" || v === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  i += 2;
                }
              }
            } else {
              i += 2;
            }
          }
          return { layers, linetypes, nextIndex: i };
        }
        parseBlocks(lines, i, dxf) {
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "ENDSEC") {
              i += 2;
              break;
            }
            if (code === "0" && value === "BLOCK") {
              let block = new DXFBlock("");
              i += 2;
              while (i < lines.length) {
                let c = lines[i].trim();
                if (c === "0") {
                  let v = (lines[i + 1] || "").trim();
                  if (v === "ENDBLK") {
                    i += 2;
                    break;
                  }
                  if (["LINE", "CIRCLE", "ARC", "LWPOLYLINE", "POLYLINE", "TEXT", "MTEXT", "DIMENSION", "HATCH", "SPLINE", "INSERT", "ELLIPSE", "3DFACE", "SOLID", "ATTRIB"].includes(v)) {
                    let entRes = this.parseEntity(lines, i);
                    if (entRes) {
                      block.entities.push(entRes.entity);
                      i = entRes.nextIndex;
                      continue;
                    }
                  }
                }
                let v = (lines[i + 1] || "").trim();
                if (c === "2") {
                  block.name = v;
                } else if (c === "10") {
                  block.basePoint.x = parseFloat(v);
                } else if (c === "20") {
                  block.basePoint.y = parseFloat(v);
                }
                i += 2;
              }
              dxf.blocks[block.name] = block;
              continue;
            }
            i += 2;
          }
          return i;
        }
        parseEntities(lines, i, dxf) {
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "ENDSEC") {
              i += 2;
              break;
            }
            if (code === "0") {
              let res = this.parseEntity(lines, i);
              if (res) {
                let e = res.entity;
                i = res.nextIndex;
                if (e.type === "INSERT") {
                  e.attribs = [];
                  while (i < lines.length) {
                    let c2 = lines[i].trim();
                    let v2 = (lines[i + 1] || "").trim();
                    if (c2 === "0" && v2 === "ATTRIB") {
                      let ar = this.parseEntity(lines, i);
                      if (ar) {
                        e.attribs.push(ar.entity);
                        i = ar.nextIndex;
                        continue;
                      }
                    }
                    break;
                  }
                }
                dxf.entities.push(e);
                continue;
              }
            }
            i += 2;
          }
          return i;
        }
        parseEntity(lines, i) {
          if (i >= lines.length) return null;
          let code = lines[i].trim();
          let value = (lines[i + 1] || "").trim();
          if (code !== "0") return null;
          switch (value) {
            case "LINE": return DXFLine.parse(lines, i);
            case "CIRCLE": return DXFCircle.parse(lines, i);
            case "ARC": return DXFArc.parse(lines, i);
            case "POLYLINE": return DXFPolyline.parse(lines, i);
            case "LWPOLYLINE": return DXFLwPolyline.parse(lines, i);
            case "HATCH": return DXFHatch.parse(lines, i);
            case "DIMENSION": return DXFDimension.parse(lines, i);
            case "MTEXT": return DXFMTEXT.parse(lines, i);
            case "SPLINE": return DXFSpline.parse(lines, i);
            case "INSERT": return DXFInsert.parse(lines, i);
            case "TEXT":
            case "ATTRIB": return DXFText.parse(lines, i);
            case "ELLIPSE": return DXFEllipse.parse(lines, i);
            case "3DFACE": return DXF3DFace.parse(lines, i);
            case "SOLID": return DXFSolid.parse(lines, i);
            default: return GenericDXFEntity.parse(lines, i);
          }
        }
      }

      // ─────────────────────────────────────────────────────────────
      // VIEWPORT CLASS
      // ─────────────────────────────────────────────────────────────
      class Viewport {
        constructor(canvas) {
          this.canvas = canvas;
          this.baseScale = 1;
          this.baseOffsetX = 0;
          this.baseOffsetY = 0;
          this.viewScale = 1;
          this.viewOffsetX = 0;
          this.viewOffsetY = 0;
        }
        reset() {
          this.viewScale = this.baseScale;
          this.viewOffsetX = this.baseOffsetX;
          this.viewOffsetY = this.baseOffsetY;
        }
        setInitialView(dxfDoc) {
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          function considerPoint(x, y) {
            if (isNaN(x) || isNaN(y)) return;
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
          function processEntity(entity) {
            switch (entity.type) {
              case "LINE":
                considerPoint(entity.x1, entity.y1);
                considerPoint(entity.x2, entity.y2);
                break;
              case "CIRCLE":
                considerPoint(entity.cx - entity.r, entity.cy - entity.r);
                considerPoint(entity.cx + entity.r, entity.cy + entity.r);
                break;
              case "ARC":
                considerPoint(entity.cx - entity.r, entity.cy - entity.r);
                considerPoint(entity.cx + entity.r, entity.cy + entity.r);
                break;
              case "POLYLINE":
              case "LWPOLYLINE":
                entity.vertices.forEach(v => considerPoint(v.x, v.y));
                break;
              case "TEXT":
              case "MTEXT":
              case "ATTRIB":
              case "DIMENSION":
                if (entity.position) {
                  considerPoint(entity.position.x, entity.position.y);
                }
                if (entity.p1) considerPoint(entity.p1.x, entity.p1.y);
                if (entity.p2) considerPoint(entity.p2.x, entity.p2.y);
                break;
              case "HATCH":
                entity.boundaryLoops.forEach(loop => {
                  loop.forEach(pt => considerPoint(pt.x, pt.y));
                });
                break;
              case "INSERT":
                considerPoint(entity.insertionPoint.x, entity.insertionPoint.y);
                break;
              case "SPLINE":
                entity.fitPoints.forEach(pt => considerPoint(pt.x, pt.y));
                entity.controlPoints.forEach(pt => considerPoint(pt.x, pt.y));
                break;
              case "ELLIPSE":
                {
                  let rx = Math.sqrt(entity.mx * entity.mx + entity.my * entity.my);
                  let ry = rx * (entity.ratio || 1);
                  considerPoint(entity.cx - rx, entity.cy - ry);
                  considerPoint(entity.cx + rx, entity.cy + ry);
                }
                break;
              case "3DFACE":
              case "SOLID":
                entity.points.forEach(pt => considerPoint(pt.x, pt.y));
                break;
              default:
                break;
            }
          }
          dxfDoc.entities.forEach(e => processEntity(e));
          for (let name in dxfDoc.blocks) {
            let block = dxfDoc.blocks[name];
            considerPoint(block.basePoint.x, block.basePoint.y);
            block.entities.forEach(be => processEntity(be));
          }
          if (minX === Infinity) {
            minX = -100; minY = -100; maxX = 100; maxY = 100;
          }
          let dw = maxX - minX, dh = maxY - minY;
          let sx = this.canvas.width / dw, sy = this.canvas.height / dh;
          this.baseScale = 0.9 * Math.min(sx, sy);
          let cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
          this.viewScale = this.baseScale;
          this.baseOffsetX = this.canvas.width / 2 - this.baseScale * cx;
          this.baseOffsetY = this.canvas.height / 2 + this.baseScale * cy;
          this.viewOffsetX = this.baseOffsetX;
          this.viewOffsetY = this.baseOffsetY;
        }
        worldToScreen(x, y) {
          return { x: this.viewScale * x + this.viewOffsetX, y: -this.viewScale * y + this.viewOffsetY };
        }
        screenToWorld(sx, sy) {
          return { x: (sx - this.viewOffsetX) / this.viewScale, y: -(sy - this.viewOffsetY) / this.viewScale };
        }
      }

      // ─────────────────────────────────────────────────────────────
      // DXF VIEWER CLASS
      // ─────────────────────────────────────────────────────────────
      class DXFViewer {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          this.viewport = new Viewport(canvas);
          this.dxfDoc = new DXFDocument();
          this.parser = new DXFParser();
          this.gridEnabled = false;
          this.isPanning = false;
          this.lastPanPoint = { x: 0, y: 0 };
          this.ongoingTouches = [];
          this.lastTouchDistance = null;
          this.lastTouchCenter = null;
          this.registerEventHandlers();
          window.addEventListener("resize", () => this.onResize());
          this.onResize();
        }
        onResize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          if (this.dxfDoc.entities.length > 0) {
            this.viewport.setInitialView(this.dxfDoc);
          }
          this.draw();
        }
        loadDXF(text) {
          let dxfParsed = this.parser.parse(text);
          if (dxfParsed.entities.length === 0 && Object.keys(dxfParsed.blocks).length === 0) {
            alert("No supported entities found in DXF.");
            return;
          }
          this.dxfDoc = dxfParsed;
          this.viewport.setInitialView(this.dxfDoc);
          this.draw();
        }
        toggleGrid() {
          this.gridEnabled = !this.gridEnabled;
          this.draw();
        }
        resetView() {
          this.viewport.reset();
          this.draw();
        }
        draw() {
          let ctx = this.ctx;
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          ctx.restore();
          ctx.setTransform(
            this.viewport.viewScale, 0,
            0, -this.viewport.viewScale,
            this.viewport.viewOffsetX,
            this.viewport.viewOffsetY
          );
          if (this.gridEnabled) {
            this.drawGrid();
          }
          this.dxfDoc.entities.forEach(entity => {
            if (renderSettings.entity[entity.type] !== false) {
              entity.draw(ctx, this.viewport, this.dxfDoc);
            }
          });
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        drawGrid() {
          let spacing = getNiceGridSpacing(this.viewport);
          let tl = this.viewport.screenToWorld(0, 0);
          let br = this.viewport.screenToWorld(this.canvas.width, this.canvas.height);
          let startX = Math.floor(tl.x / spacing) * spacing;
          let endX = Math.ceil(br.x / spacing) * spacing;
          let startY = Math.floor(br.y / spacing) * spacing;
          let endY = Math.ceil(tl.y / spacing) * spacing;
          let ctx = this.ctx;
          ctx.save();
          ctx.lineWidth = 1 / this.viewport.viewScale;
          ctx.strokeStyle = "#444";
          ctx.beginPath();
          for (let x = startX; x <= endX; x += spacing) {
            ctx.moveTo(x, startY);
            ctx.lineTo(x, endY);
          }
          for (let y = startY; y <= endY; y += spacing) {
            ctx.moveTo(startX, y);
            ctx.lineTo(endX, y);
          }
          ctx.stroke();
          ctx.restore();
        }
        registerEventHandlers() {
          this.canvas.addEventListener("mousedown", (e) => {
            this.isPanning = true;
            this.lastPanPoint = { x: e.clientX, y: e.clientY };
          });
          this.canvas.addEventListener("mousemove", (e) => {
            if (this.isPanning) {
              let dx = e.clientX - this.lastPanPoint.x;
              let dy = e.clientY - this.lastPanPoint.y;
              this.lastPanPoint = { x: e.clientX, y: e.clientY };
              this.viewport.viewOffsetX += dx;
              this.viewport.viewOffsetY += dy;
              this.draw();
            }
          });
          this.canvas.addEventListener("mouseup", () => { this.isPanning = false; });
          this.canvas.addEventListener("mouseleave", () => { this.isPanning = false; });
          this.canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            const zoomIntensity = 0.001;
            let factor = 1 - e.deltaY * zoomIntensity;
            let mx = e.clientX, my = e.clientY;
            this.viewport.viewOffsetX = mx - factor * (mx - this.viewport.viewOffsetX);
            this.viewport.viewOffsetY = my - factor * (my - this.viewport.viewOffsetY);
            this.viewport.viewScale *= factor;
            this.draw();
          }, { passive: false });
          this.canvas.addEventListener("touchstart", (e) => this.handleTouchStart(e), { passive: false });
          this.canvas.addEventListener("touchmove", (e) => this.handleTouchMove(e), { passive: false });
          this.canvas.addEventListener("touchend", (e) => this.handleTouchEnd(e), { passive: false });
          this.canvas.addEventListener("touchcancel", (e) => this.handleTouchEnd(e), { passive: false });
        }
        getTouchPos(evt) {
          let rect = this.canvas.getBoundingClientRect();
          return Array.from(evt.touches).map(t => ({ x: t.clientX - rect.left, y: t.clientY - rect.top }));
        }
        handleTouchStart(evt) {
          evt.preventDefault();
          let touches = this.getTouchPos(evt);
          this.ongoingTouches = touches;
          if (touches.length === 2) {
            this.lastTouchDistance = getDistance(touches[0], touches[1]);
            this.lastTouchCenter = getCenter(touches[0], touches[1]);
          } else if (touches.length === 1) {
            this.lastPanPoint = touches[0];
          }
        }
        handleTouchMove(evt) {
          evt.preventDefault();
          let touches = this.getTouchPos(evt);
          if (touches.length === 2 && this.ongoingTouches.length >= 2) {
            let newDist = getDistance(touches[0], touches[1]);
            let factor = newDist / this.lastTouchDistance;
            let newCenter = getCenter(touches[0], touches[1]);
            this.viewport.viewOffsetX = newCenter.x - factor * (newCenter.x - this.viewport.viewOffsetX);
            this.viewport.viewOffsetY = newCenter.y - factor * (newCenter.y - this.viewport.viewOffsetY);
            this.viewport.viewScale *= factor;
            this.lastTouchDistance = newDist;
            this.lastTouchCenter = newCenter;
          } else if (touches.length === 1 && this.ongoingTouches.length === 1) {
            let dx = touches[0].x - this.lastPanPoint.x;
            let dy = touches[0].y - this.lastPanPoint.y;
            this.viewport.viewOffsetX += dx;
            this.viewport.viewOffsetY += dy;
            this.lastPanPoint = touches[0];
          }
          this.ongoingTouches = touches;
          this.draw();
        }
        handleTouchEnd(evt) {
          evt.preventDefault();
          let touches = this.getTouchPos(evt);
          this.ongoingTouches = touches;
          if (touches.length < 2) {
            this.lastTouchDistance = null;
            this.lastTouchCenter = null;
          }
          if (touches.length === 0) this.isPanning = false;
        }
      }

      // ─────────────────────────────────────────────────────────────
      // BOOTSTRAP
      // ─────────────────────────────────────────────────────────────
      const canvas = document.getElementById("canvas");
      const viewer = new DXFViewer(canvas);

      document.getElementById("dxfFile").addEventListener("change", function (e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (event) {
          const text = event.target.result;
          viewer.loadDXF(text);
        };
        reader.readAsText(file);
      });
      document.getElementById("resetView").addEventListener("click", () => viewer.resetView());
      document.getElementById("toggleGrid").addEventListener("click", () => viewer.toggleGrid());
      document.getElementById("toggleEntityOptions").addEventListener("click", () => {
        document.getElementById("entityOptionsOverlay").style.display = "block";
      });
      document.getElementById("toggleOtherOptions").addEventListener("click", () => {
        document.getElementById("otherOptionsOverlay").style.display = "block";
      });
      document.getElementById("entityOptionsOverlay").addEventListener("click", (e) => {
        if (e.target === document.getElementById("entityOptionsOverlay")) {
          document.getElementById("entityOptionsOverlay").style.display = "none";
        }
      });
      document.getElementById("otherOptionsOverlay").addEventListener("click", (e) => {
        if (e.target === document.getElementById("otherOptionsOverlay")) {
          document.getElementById("otherOptionsOverlay").style.display = "none";
        }
      });
      document.getElementById("entityOptionsPopup").addEventListener("click", e => e.stopPropagation());
      document.getElementById("otherOptionsPopup").addEventListener("click", e => e.stopPropagation());
      document.querySelectorAll(".entity-toggle").forEach(checkbox => {
        checkbox.addEventListener("change", function (e) {
          const type = e.target.getAttribute("data-type");
          renderSettings.entity[type] = e.target.checked;
          viewer.draw();
        });
      });
      document.getElementById("selectAllEntities").addEventListener("click", () => {
        document.querySelectorAll(".entity-toggle").forEach(cb => {
          cb.checked = true;
          const type = cb.getAttribute("data-type");
          renderSettings.entity[type] = true;
        });
        viewer.draw();
      });
      document.getElementById("deselectAllEntities").addEventListener("click", () => {
        document.querySelectorAll(".entity-toggle").forEach(cb => {
          cb.checked = false;
          const type = cb.getAttribute("data-type");
          renderSettings.entity[type] = false;
        });
        viewer.draw();
      });
      document.getElementById("toggleLinetype").addEventListener("change", function (e) {
        renderSettings.renderLinetype = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleColor").addEventListener("change", function (e) {
        renderSettings.renderColor = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleThickness").addEventListener("change", function (e) {
        renderSettings.renderThickness = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleWidth").addEventListener("change", function (e) {
        renderSettings.renderWidth = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleTransparency").addEventListener("change", function (e) {
        renderSettings.renderTransparency = !e.target.checked;
        viewer.draw();
      });
      viewer.draw();
    </script>
  </body>
</html>
