<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advanced Web DXF Viewer (Corrected Coordinates & MTEXT)</title>
  <style>
    /* Fullscreen canvas and simple toolbar styling */
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
    }
    #toolbar button,
    #toolbar input {
      margin: 4px 0;
    }
    canvas {
      display: block;
      touch-action: none; /* disable default gestures */
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div>
      <input type="file" id="dxfFile" accept=".dxf" />
    </div>
    <div>
      <button id="resetView">Reset View</button>
      <button id="toggleGrid">Toggle Grid</button>
    </div>
    <div style="margin-top:8px;">
      <small>Mouse or touch: drag to pan, wheel or pinch to zoom.</small>
    </div>
  </div>
  <canvas id="canvas"></canvas>
  <script>
    // Global variables and view state
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let dxf = { entities: [], blocks: {} }; // parsed DXF data
    let baseScale = 1, baseOffsetX = 0, baseOffsetY = 0;
    let viewScale = 1, viewOffsetX = 0, viewOffsetY = 0;
    let gridEnabled = true;
    let isPanning = false;
    let lastPanPoint = { x: 0, y: 0 };

    // Touch state
    let ongoingTouches = [];
    let lastTouchDistance = null;
    let lastTouchCenter = null;

    // Resize canvas to fill the window
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (dxf.entities.length > 0) {
        setInitialView();
      }
      draw();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // --- File Loading and Parsing ---
    document.getElementById("dxfFile").addEventListener("change", function (e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (event) {
        const text = event.target.result;
        dxf = parseDXF(text);
        if (dxf.entities.length === 0 && Object.keys(dxf.blocks).length === 0) {
          alert("No supported entities found in DXF.");
          return;
        }
        setInitialView();
        draw();
      };
      reader.readAsText(file);
    });

    // Reset view button
    document.getElementById("resetView").addEventListener("click", function () {
      viewScale = baseScale;
      viewOffsetX = baseOffsetX;
      viewOffsetY = baseOffsetY;
      draw();
    });

    // Toggle grid button
    document.getElementById("toggleGrid").addEventListener("click", function () {
      gridEnabled = !gridEnabled;
      draw();
    });

    // --- Mouse Pan & Zoom ---
    canvas.addEventListener("mousedown", (e) => {
      isPanning = true;
      lastPanPoint = { x: e.clientX, y: e.clientY };
    });
    canvas.addEventListener("mousemove", (e) => {
      if (isPanning) {
        const dx = e.clientX - lastPanPoint.x;
        const dy = e.clientY - lastPanPoint.y;
        lastPanPoint = { x: e.clientX, y: e.clientY };
        viewOffsetX += dx;
        viewOffsetY += dy;
        draw();
      }
    });
    canvas.addEventListener("mouseup", () => (isPanning = false));
    canvas.addEventListener("mouseleave", () => (isPanning = false));
    canvas.addEventListener("wheel", function (e) {
      e.preventDefault();
      const zoomIntensity = 0.001;
      const delta = e.deltaY;
      const factor = 1 - delta * zoomIntensity;
      // Zoom relative to mouse pointer
      const mouseX = e.clientX;
      const mouseY = e.clientY;
      viewOffsetX = mouseX - factor * (mouseX - viewOffsetX);
      viewOffsetY = mouseY - factor * (mouseY - viewOffsetY);
      viewScale *= factor;
      draw();
    });

    // --- Touch Pan and Pinch Zoom ---
    canvas.addEventListener("touchstart", handleTouchStart, {passive: false});
    canvas.addEventListener("touchmove", handleTouchMove, {passive: false});
    canvas.addEventListener("touchend", handleTouchEnd, {passive: false});
    canvas.addEventListener("touchcancel", handleTouchEnd, {passive: false});

    function getTouchPos(touchEvent) {
      const rect = canvas.getBoundingClientRect();
      return Array.from(touchEvent.touches).map(touch => ({
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      }));
    }

    function handleTouchStart(evt) {
      evt.preventDefault();
      const touches = getTouchPos(evt);
      ongoingTouches = touches;
      if (touches.length === 2) {
        lastTouchDistance = getDistance(touches[0], touches[1]);
        lastTouchCenter = getCenter(touches[0], touches[1]);
      } else if (touches.length === 1) {
        lastPanPoint = touches[0];
      }
    }

    function handleTouchMove(evt) {
      evt.preventDefault();
      const touches = getTouchPos(evt);
      if (touches.length === 2 && ongoingTouches.length >= 2) {
        // Pinch zoom
        const newDistance = getDistance(touches[0], touches[1]);
        const factor = newDistance / lastTouchDistance;
        const newCenter = getCenter(touches[0], touches[1]);
        // Adjust zoom relative to the center of the pinch
        viewOffsetX = newCenter.x - factor * (newCenter.x - viewOffsetX);
        viewOffsetY = newCenter.y - factor * (newCenter.y - viewOffsetY);
        viewScale *= factor;
        lastTouchDistance = newDistance;
        lastTouchCenter = newCenter;
      } else if (touches.length === 1 && ongoingTouches.length === 1) {
        // Single finger pan
        const dx = touches[0].x - lastPanPoint.x;
        const dy = touches[0].y - lastPanPoint.y;
        viewOffsetX += dx;
        viewOffsetY += dy;
        lastPanPoint = touches[0];
      }
      ongoingTouches = touches;
      draw();
    }

    function handleTouchEnd(evt) {
      evt.preventDefault();
      const touches = getTouchPos(evt);
      ongoingTouches = touches;
      if (touches.length < 2) {
        lastTouchDistance = null;
        lastTouchCenter = null;
      }
      if (touches.length === 0) {
        isPanning = false;
      }
    }

    function getDistance(p1, p2) {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function getCenter(p1, p2) {
      return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    }

    // --- DXF Parsing ---
    // This simplified parser looks for SECTION markers and supports the ENTITIES and BLOCKS sections.
    // It supports LINE, CIRCLE, ARC, POLYLINE (and its vertices via VERTEX/SEQEND),
    // LWPOLYLINE, TEXT, MTEXT, and INSERT (with attached ATTRIBs).
    function parseDXF(text) {
      const lines = text.split(/\r\n|\n/);
      const dxf = { entities: [], blocks: {} };
      let i = 0;
      let currentSection = null;

      while (i < lines.length) {
        let code = lines[i].trim();
        let value = lines[i + 1] ? lines[i + 1].trim() : "";
        if (code === "0" && value === "SECTION") {
          i += 2;
          if (lines[i].trim() === "2") {
            const sectionName = lines[i + 1].trim();
            currentSection = sectionName;
            i += 2;
            if (sectionName === "BLOCKS") {
              // Parse BLOCKS section
              while (i < lines.length) {
                code = lines[i].trim();
                value = lines[i + 1] ? lines[i + 1].trim() : "";
                if (code === "0" && value === "ENDSEC") {
                  i += 2;
                  break;
                }
                if (code === "0" && value === "BLOCK") {
                  const block = { name: "", basePoint: { x: 0, y: 0 }, entities: [] };
                  i += 2;
                  // Read block header properties until first entity (type "LINE", etc.) or ENDBLK
                  while (i < lines.length) {
                    code = lines[i].trim();
                    value = lines[i + 1] ? lines[i + 1].trim() : "";
                    if (code === "0" && (value === "ENDBLK" || value === "LINE" || value === "CIRCLE" || value === "ARC" || value === "LWPOLYLINE" || value === "POLYLINE" || value === "TEXT" || value === "MTEXT")) {
                      break;
                    }
                    if (code === "2") {
                      block.name = value;
                    } else if (code === "10") {
                      block.basePoint.x = parseFloat(value);
                    } else if (code === "20") {
                      block.basePoint.y = parseFloat(value);
                    }
                    i += 2;
                  }
                  // Now parse block entities until ENDBLK
                  while (i < lines.length) {
                    code = lines[i].trim();
                    value = lines[i + 1] ? lines[i + 1].trim() : "";
                    if (code === "0" && value === "ENDBLK") {
                      i += 2;
                      break;
                    }
                    if (code === "0") {
                      const result = parseEntity(lines, i);
                      if (result) {
                        block.entities.push(result.entity);
                        i = result.nextIndex;
                        continue;
                      }
                    }
                    i += 2;
                  }
                  dxf.blocks[block.name] = block;
                  continue;
                }
                i += 2;
              }
            } else if (sectionName === "ENTITIES") {
              // Parse ENTITIES section
              while (i < lines.length) {
                code = lines[i].trim();
                value = lines[i + 1] ? lines[i + 1].trim() : "";
                if (code === "0" && value === "ENDSEC") {
                  i += 2;
                  break;
                }
                if (code === "0") {
                  const result = parseEntity(lines, i);
                  if (result) {
                    const entity = result.entity;
                    i = result.nextIndex;
                    // If an INSERT is encountered, attach following ATTRIBs
                    if (entity.type === "INSERT") {
                      entity.attribs = [];
                      while (i < lines.length) {
                        let codePeek = lines[i].trim();
                        let valuePeek = lines[i + 1] ? lines[i + 1].trim() : "";
                        if (codePeek === "0" && valuePeek === "ATTRIB") {
                          const attribResult = parseEntity(lines, i);
                          if (attribResult) {
                            entity.attribs.push(attribResult.entity);
                            i = attribResult.nextIndex;
                            continue;
                          }
                        }
                        break;
                      }
                    }
                    dxf.entities.push(entity);
                    continue;
                  }
                }
                i += 2;
              }
            } else {
              // Skip any other section
              while (i < lines.length) {
                code = lines[i].trim();
                value = lines[i + 1] ? lines[i + 1].trim() : "";
                if (code === "0" && value === "ENDSEC") {
                  i += 2;
                  break;
                }
                i += 2;
              }
            }
            continue;
          }
        }
        i += 2;
      }
      return dxf;
    }

    // Parses an individual DXF entity starting at index i.
    // Special handling is provided for POLYLINE (which may contain VERTEX entities)
    // and LWPOLYLINE (which has embedded vertices).
    function parseEntity(lines, i) {
      if (i >= lines.length) return null;
      let code = lines[i].trim();
      let value = lines[i + 1] ? lines[i + 1].trim() : "";
      if (code !== "0") return null;
      const entity = { type: value };
      i += 2;

      if (entity.type === "POLYLINE") {
        entity.vertices = [];
        // Read header properties until encountering VERTEX or SEQEND
        while (i < lines.length) {
          code = lines[i].trim();
          value = lines[i + 1] ? lines[i + 1].trim() : "";
          if (code === "0" && (value === "VERTEX" || value === "SEQEND")) break;
          entity[code] = value;
          i += 2;
        }
        // Read vertices
        while (i < lines.length) {
          code = lines[i].trim();
          value = lines[i + 1] ? lines[i + 1].trim() : "";
          if (code === "0" && value === "VERTEX") {
            let vertex = {};
            i += 2;
            while (i < lines.length) {
              let vCode = lines[i].trim();
              let vValue = lines[i + 1] ? lines[i + 1].trim() : "";
              if (vCode === "0") break;
              if (vCode === "10") vertex.x = parseFloat(vValue);
              else if (vCode === "20") vertex.y = parseFloat(vValue);
              i += 2;
            }
            entity.vertices.push(vertex);
            continue;
          } else if (code === "0" && value === "SEQEND") {
            i += 2;
            break;
          } else {
            i += 2;
          }
        }
        return { entity, nextIndex: i };
      } else if (entity.type === "LWPOLYLINE") {
        entity.vertices = [];
        // LWPOLYLINE header: some properties may be present
        while (i < lines.length) {
          code = lines[i].trim();
          value = lines[i + 1] ? lines[i + 1].trim() : "";
          // Vertices come as repeating 10 and 20 codes.
          if (code === "10") {
            let vertex = { x: parseFloat(value) };
            i += 2;
            if (i < lines.length && lines[i].trim() === "20") {
              vertex.y = parseFloat(lines[i + 1].trim());
              i += 2;
            }
            entity.vertices.push(vertex);
          } else if (code === "0") {
            break;
          } else {
            entity[code] = value;
            i += 2;
          }
        }
        return { entity, nextIndex: i };
      } else {
        // For all other entities, read until the next "0" marker.
        while (i < lines.length) {
          code = lines[i].trim();
          if (code === "0") break;
          value = lines[i + 1] ? lines[i + 1].trim() : "";
          entity[code] = value;
          i += 2;
        }
        return { entity, nextIndex: i };
      }
    }

    // --- Compute Initial View ---
    // Computes the overall drawing bounding box (based on common entities)
    // and sets the base scale/offset so that the drawing fits the canvas.
    function setInitialView() {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

      function considerPoint(x, y) {
        if (isNaN(x) || isNaN(y)) return;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }

      // Process a single entity
      function processEntity(entity) {
        switch (entity.type) {
          case "LINE":
            considerPoint(parseFloat(entity["10"]), parseFloat(entity["20"]));
            considerPoint(parseFloat(entity["11"]), parseFloat(entity["21"]));
            break;
          case "CIRCLE":
            {
              const cx = parseFloat(entity["10"]);
              const cy = parseFloat(entity["20"]);
              const r = parseFloat(entity["40"]);
              considerPoint(cx - r, cy - r);
              considerPoint(cx + r, cy + r);
            }
            break;
          case "ARC":
            {
              const cx = parseFloat(entity["10"]);
              const cy = parseFloat(entity["20"]);
              const r = parseFloat(entity["40"]);
              considerPoint(cx - r, cy - r);
              considerPoint(cx + r, cy + r);
            }
            break;
          case "POLYLINE":
          case "LWPOLYLINE":
            if (entity.vertices) {
              entity.vertices.forEach(v => {
                considerPoint(v.x, v.y);
              });
            }
            break;
          case "TEXT":
          case "MTEXT":
          case "ATTRIB":
            considerPoint(parseFloat(entity["10"]), parseFloat(entity["20"]));
            break;
          case "INSERT":
            // For an insert, approximate by its insertion point.
            considerPoint(parseFloat(entity["10"]), parseFloat(entity["20"]));
            break;
        }
      }

      // Process all top-level entities.
      dxf.entities.forEach(processEntity);
      // Also process block definitions (their contents are drawn relative to their base point).
      for (let name in dxf.blocks) {
        const block = dxf.blocks[name];
        considerPoint(block.basePoint.x, block.basePoint.y);
        if (block.entities) {
          block.entities.forEach(processEntity);
        }
      }
      // Fallback if no entities found
      if (minX === Infinity) { minX = -100; minY = -100; maxX = 100; maxY = 100; }

      const drawingWidth = maxX - minX;
      const drawingHeight = maxY - minY;
      const scaleX = canvas.width / drawingWidth;
      const scaleY = canvas.height / drawingHeight;
      baseScale = 0.9 * Math.min(scaleX, scaleY);
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      // Using a transform with negative Yâ€“scale:
      // We want T(centerX, centerY) = (canvas.width/2, canvas.height/2)
      viewScale = baseScale;
      baseOffsetX = canvas.width / 2 - baseScale * centerX;
      baseOffsetY = canvas.height / 2 + baseScale * centerY;
      viewOffsetX = baseOffsetX;
      viewOffsetY = baseOffsetY;
    }

    // --- Drawing Functions ---
    function draw() {
      // Clear the canvas.
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      // Set the world transform.
      // The Y axis is flipped so that DXF world coordinates (with Y up) render properly.
      ctx.setTransform(viewScale, 0, 0, -viewScale, viewOffsetX, viewOffsetY);

      // Optionally draw a grid.
      if (gridEnabled) drawGrid();

      // Draw all top-level entities.
      dxf.entities.forEach(entity => {
        drawEntity(entity);
      });
    }

    // Draw a grid in world coordinates.
    function drawGrid() {
      const gridSpacing = 10;
      const topLeft = screenToWorld(0, 0);
      const bottomRight = screenToWorld(canvas.width, canvas.height);
      const startX = Math.floor(topLeft.x / gridSpacing) * gridSpacing;
      const endX = Math.ceil(bottomRight.x / gridSpacing) * gridSpacing;
      const startY = Math.floor(bottomRight.y / gridSpacing) * gridSpacing;
      const endY = Math.ceil(topLeft.y / gridSpacing) * gridSpacing;
      ctx.save();
      ctx.lineWidth = 0.5 / viewScale;
      ctx.strokeStyle = "#ddd";
      ctx.beginPath();
      for (let x = startX; x <= endX; x += gridSpacing) {
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
      }
      for (let y = startY; y <= endY; y += gridSpacing) {
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
      }
      ctx.stroke();
      ctx.restore();
    }

    // Convert screen (pixel) coordinates to world (DXF) coordinates.
    function screenToWorld(sx, sy) {
      // Inverse of: (x, y) -> (viewScale*x + viewOffsetX, -viewScale*y + viewOffsetY)
      const x = (sx - viewOffsetX) / viewScale;
      const y = -(sy - viewOffsetY) / viewScale;
      return { x, y };
    }

    // Convert world coordinates to screen coordinates.
    // This is used for drawing text without the flipped Y.
    function worldToScreen(x, y) {
      return {
        x: viewScale * x + viewOffsetX,
        y: -viewScale * y + viewOffsetY
      };
    }

    // Draw an individual DXF entity.
    // For TEXT, MTEXT, and ATTRIB, we use a separate routine so that text is drawn unflipped.
    function drawEntity(entity) {
      // For text entities, use our custom text drawer.
      if (entity.type === "TEXT" || entity.type === "MTEXT" || entity.type === "ATTRIB") {
        drawText(entity);
        return;
      }
      // For INSERT entities, we need to apply block transforms.
      if (entity.type === "INSERT") {
        ctx.save();
        const blockName = entity["2"];
        const block = dxf.blocks[blockName];
        if (block) {
          const insX = parseFloat(entity["10"]) || 0;
          const insY = parseFloat(entity["20"]) || 0;
          const scaleX = entity["41"] ? parseFloat(entity["41"]) : 1;
          const scaleY = entity["42"] ? parseFloat(entity["42"]) : 1;
          const rotation = entity["50"] ? degToRad(parseFloat(entity["50"])) : 0;
          const bp = block.basePoint || { x: 0, y: 0 };
          ctx.translate(insX, insY);
          ctx.rotate(rotation);
          ctx.scale(scaleX, scaleY);
          ctx.translate(-bp.x, -bp.y);
          block.entities.forEach(be => drawEntity(be));
          if (entity.attribs) {
            entity.attribs.forEach(attr => drawEntity(attr));
          }
        }
        ctx.restore();
        return;
      }

      // Draw other geometric entities.
      ctx.save();
      ctx.lineWidth = 1 / viewScale;
      ctx.strokeStyle = "#000";
      ctx.fillStyle = "#000";

      switch (entity.type) {
        case "LINE":
          {
            const x1 = parseFloat(entity["10"]);
            const y1 = parseFloat(entity["20"]);
            const x2 = parseFloat(entity["11"]);
            const y2 = parseFloat(entity["21"]);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          }
          break;
        case "CIRCLE":
          {
            const cx = parseFloat(entity["10"]);
            const cy = parseFloat(entity["20"]);
            const r = parseFloat(entity["40"]);
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, 2 * Math.PI);
            ctx.stroke();
          }
          break;
        case "ARC":
          {
            const cx = parseFloat(entity["10"]);
            const cy = parseFloat(entity["20"]);
            const r = parseFloat(entity["40"]);
            const startAngle = degToRad(parseFloat(entity["50"] || "0"));
            const endAngle = degToRad(parseFloat(entity["51"] || "0"));
            ctx.beginPath();
            ctx.arc(cx, cy, r, startAngle, endAngle);
            ctx.stroke();
          }
          break;
        case "POLYLINE":
        case "LWPOLYLINE":
          {
            if (entity.vertices && entity.vertices.length > 0) {
              ctx.beginPath();
              ctx.moveTo(entity.vertices[0].x, entity.vertices[0].y);
              for (let i = 1; i < entity.vertices.length; i++) {
                ctx.lineTo(entity.vertices[i].x, entity.vertices[i].y);
              }
              // If flag for closed polyline is set (group code 70 bit 1), close the path.
              if (entity["70"] && (parseInt(entity["70"]) & 1)) {
                ctx.closePath();
              }
              ctx.stroke();
            }
          }
          break;
        default:
          // Unsupported entity types are simply ignored.
          break;
      }
      ctx.restore();
    }

    // --- Text Drawing ---
    // Draws TEXT, MTEXT, and ATTRIB entities so that the text appears upright.
    // It computes the screen coordinate (using the current view transform)
    // and then resets the transform to draw text with the proper font size and rotation.
    function drawText(entity) {
      // Get world insertion point.
      const x = parseFloat(entity["10"]);
      const y = parseFloat(entity["20"]);
      // Text height (default to 12 if not specified)
      const height = entity["40"] ? parseFloat(entity["40"]) : 12;
      // DXF text rotation (in degrees); convert to radians.
      const rotation = entity["50"] ? degToRad(parseFloat(entity["50"])) : 0;
      // The text content is stored in group code "1". (MTEXT may also use "1".)
      const rawText = entity["1"] || "";
      // Compute screen coordinate from world coordinate.
      const screen = worldToScreen(x, y);
      // Compute the font size in screen space.
      const screenFontSize = height * viewScale;

      // Reset transform so that text is drawn normally.
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.translate(screen.x, screen.y);
      // Because the global transform flipped Y, we use -rotation so that text appears with the correct orientation.
      ctx.rotate(-rotation);
      ctx.fillStyle = "#000";
      ctx.textBaseline = "middle";
      
      // If MTEXT, split into lines on "\P" (DXF line break) or newline.
      if (entity.type === "MTEXT") {
        const lines = rawText.split(/\\P|\n/);
        const lineHeight = screenFontSize * 1.2;
        ctx.font = `${screenFontSize}px sans-serif`;
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], 0, i * lineHeight);
        }
      } else {
        // For TEXT and ATTRIB, just draw a single line.
        ctx.font = `${screenFontSize}px sans-serif`;
        ctx.fillText(rawText, 0, 0);
      }
      ctx.restore();
    }

    // Utility: convert degrees to radians.
    function degToRad(deg) {
      return (deg * Math.PI) / 180;
    }

    // Initial draw.
    draw();
  </script>
</body>
</html>
