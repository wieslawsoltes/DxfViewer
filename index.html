<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advanced Web DXF Viewer – Dimensions, Hatch & MTEXT</title>
  <style>
    /* Fullscreen canvas and toolbar styling */
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
      user-select: none;
    }
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0,0,0,0.3);
    }
    #toolbar button,
    #toolbar input {
      margin: 4px 0;
    }
    canvas {
      display: block;
      touch-action: none;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div>
      <input type="file" id="dxfFile" accept=".dxf" />
    </div>
    <div>
      <button id="resetView">Reset View</button>
      <button id="toggleGrid">Toggle Grid</button>
    </div>
    <div style="margin-top:8px;">
      <small>Pan with mouse/touch; wheel or pinch to zoom.</small>
    </div>
  </div>
  <canvas id="canvas"></canvas>
  <script>
    /* =========================================================================
       Global Variables & View State
    ========================================================================= */
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    // dxf now holds entities, blocks, layers, and linetypes.
    let dxf = { entities: [], blocks: {}, layers: {}, linetypes: {} };
    let baseScale = 1, baseOffsetX = 0, baseOffsetY = 0;
    let viewScale = 1, viewOffsetX = 0, viewOffsetY = 0;
    let gridEnabled = true;
    let isPanning = false;
    let lastPanPoint = { x: 0, y: 0 };
    // Touch state
    let ongoingTouches = [];
    let lastTouchDistance = null;
    let lastTouchCenter = null;

    /* =========================================================================
       ACI Color Mapping (partial – extend as needed)
    ========================================================================= */
    const ACI_COLORS = {
      0: "#000000", 1: "#FF0000", 2: "#FFFF00", 3: "#00FF00", 4: "#00FFFF",
      5: "#0000FF", 6: "#FF00FF", 7: "#FFFFFF", 8: "#808080", 9: "#C0C0C0",
      10: "#FF6600", 11: "#FF9900", 12: "#FFCC00", 13: "#CCFF00", 14: "#99FF00",
      15: "#66FF00", 16: "#33FF00", 17: "#00FF33", 18: "#00FF66", 19: "#00FF99",
      20: "#00FFCC", 21: "#00FFFF", 22: "#00CCFF", 23: "#0099FF", 24: "#0066FF",
      25: "#0033FF", 26: "#0000FF", 27: "#3300FF", 28: "#6600FF", 29: "#9900FF",
      30: "#CC00FF", 31: "#FF00FF", 32: "#FF00CC", 33: "#FF0099", 34: "#FF0066",
      35: "#FF0033"
      // ... (extend indices as needed)
    };

    /* =========================================================================
       Canvas Resize & Initial Setup
    ========================================================================= */
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (dxf.entities.length > 0) setInitialView();
      draw();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    /* =========================================================================
       File Loading & DXF Parsing
    ========================================================================= */
    document.getElementById("dxfFile").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(event) {
        const text = event.target.result;
        dxf = parseDXF(text);
        if (dxf.entities.length === 0 && Object.keys(dxf.blocks).length === 0) {
          alert("No supported entities found in DXF.");
          return;
        }
        setInitialView();
        draw();
      };
      reader.readAsText(file);
    });

    /* =========================================================================
       Toolbar Handlers
    ========================================================================= */
    document.getElementById("resetView").addEventListener("click", function() {
      viewScale = baseScale;
      viewOffsetX = baseOffsetX;
      viewOffsetY = baseOffsetY;
      draw();
    });
    document.getElementById("toggleGrid").addEventListener("click", function() {
      gridEnabled = !gridEnabled;
      draw();
    });

    /* =========================================================================
       Mouse Pan & Zoom
    ========================================================================= */
    canvas.addEventListener("mousedown", (e) => {
      isPanning = true;
      lastPanPoint = { x: e.clientX, y: e.clientY };
    });
    canvas.addEventListener("mousemove", (e) => {
      if (isPanning) {
        let dx = e.clientX - lastPanPoint.x;
        let dy = e.clientY - lastPanPoint.y;
        lastPanPoint = { x: e.clientX, y: e.clientY };
        viewOffsetX += dx;
        viewOffsetY += dy;
        draw();
      }
    });
    canvas.addEventListener("mouseup", () => isPanning = false);
    canvas.addEventListener("mouseleave", () => isPanning = false);
    canvas.addEventListener("wheel", function(e) {
      e.preventDefault();
      const zoomIntensity = 0.001;
      let factor = 1 - e.deltaY * zoomIntensity;
      let mouseX = e.clientX;
      let mouseY = e.clientY;
      viewOffsetX = mouseX - factor * (mouseX - viewOffsetX);
      viewOffsetY = mouseY - factor * (mouseY - viewOffsetY);
      viewScale *= factor;
      draw();
    });

    /* =========================================================================
       Touch Pan & Pinch Zoom
    ========================================================================= */
    canvas.addEventListener("touchstart", handleTouchStart, {passive: false});
    canvas.addEventListener("touchmove", handleTouchMove, {passive: false});
    canvas.addEventListener("touchend", handleTouchEnd, {passive: false});
    canvas.addEventListener("touchcancel", handleTouchEnd, {passive: false});
    function getTouchPos(evt) {
      let rect = canvas.getBoundingClientRect();
      return Array.from(evt.touches).map(t => ({
        x: t.clientX - rect.left,
        y: t.clientY - rect.top
      }));
    }
    function handleTouchStart(evt) {
      evt.preventDefault();
      let touches = getTouchPos(evt);
      ongoingTouches = touches;
      if (touches.length === 2) {
        lastTouchDistance = getDistance(touches[0], touches[1]);
        lastTouchCenter = getCenter(touches[0], touches[1]);
      } else if (touches.length === 1) {
        lastPanPoint = touches[0];
      }
    }
    function handleTouchMove(evt) {
      evt.preventDefault();
      let touches = getTouchPos(evt);
      if (touches.length === 2 && ongoingTouches.length >= 2) {
        let newDistance = getDistance(touches[0], touches[1]);
        let factor = newDistance / lastTouchDistance;
        let newCenter = getCenter(touches[0], touches[1]);
        viewOffsetX = newCenter.x - factor * (newCenter.x - viewOffsetX);
        viewOffsetY = newCenter.y - factor * (newCenter.y - viewOffsetY);
        viewScale *= factor;
        lastTouchDistance = newDistance;
        lastTouchCenter = newCenter;
      } else if (touches.length === 1 && ongoingTouches.length === 1) {
        let dx = touches[0].x - lastPanPoint.x;
        let dy = touches[0].y - lastPanPoint.y;
        viewOffsetX += dx;
        viewOffsetY += dy;
        lastPanPoint = touches[0];
      }
      ongoingTouches = touches;
      draw();
    }
    function handleTouchEnd(evt) {
      evt.preventDefault();
      let touches = getTouchPos(evt);
      ongoingTouches = touches;
      if (touches.length < 2) {
        lastTouchDistance = null;
        lastTouchCenter = null;
      }
      if (touches.length === 0) isPanning = false;
    }
    function getDistance(p1, p2) {
      return Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
    }
    function getCenter(p1, p2) {
      return { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
    }

    /* =========================================================================
       TABLES Parsing – (Layers & Linetypes)
       (See previous examples; not repeated here for brevity.)
       In our parser, layers are stored in dxf.layers and linetypes in dxf.linetypes.
    ========================================================================= */
    function parseTables(lines, i) {
      let layers = {};
      let linetypes = {};
      while (i < lines.length) {
        let code = lines[i].trim();
        let value = lines[i+1] ? lines[i+1].trim() : "";
        if (code === "0" && value === "ENDSEC") {
          i += 2;
          break;
        }
        if (code === "0" && value === "TABLE") {
          i += 2;
          let tableName = lines[i+1] ? lines[i+1].trim() : "";
          i += 2;
          if (tableName === "LAYER") {
            while (i < lines.length) {
              code = lines[i].trim();
              value = lines[i+1] ? lines[i+1].trim() : "";
              if (code === "0" && (value === "ENDTAB" || value === "ENDTABLE")) {
                i += 2;
                break;
              }
              if (code === "0" && value === "LAYER") {
                let layer = {};
                i += 2;
                while (i < lines.length) {
                  code = lines[i].trim();
                  if (code === "0") break;
                  value = lines[i+1] ? lines[i+1].trim() : "";
                  if (code === "2") layer.name = value;
                  else if (code === "62") layer["62"] = value;
                  else if (code === "6") layer["6"] = value;
                  i += 2;
                }
                if (layer.name) layers[layer.name] = layer;
              } else { i += 2; }
            }
          } else if (tableName === "LTYPE") {
            while (i < lines.length) {
              code = lines[i].trim();
              value = lines[i+1] ? lines[i+1].trim() : "";
              if (code === "0" && (value === "ENDTAB" || value === "ENDTABLE")) {
                i += 2;
                break;
              }
              if (code === "0" && value === "LTYPE") {
                let ltype = {};
                i += 2;
                while (i < lines.length) {
                  code = lines[i].trim();
                  if (code === "0") break;
                  value = lines[i+1] ? lines[i+1].trim() : "";
                  if (code === "2") ltype.name = value;
                  else if (code === "3") ltype.description = value;
                  else if (code === "72") ltype.flags = value;
                  else if (code === "73") ltype.elements = parseInt(value);
                  else if (code === "40") ltype.patternLength = parseFloat(value);
                  else if (code === "49") {
                    if (!ltype.pattern) ltype.pattern = [];
                    ltype.pattern.push(parseFloat(value));
                  }
                  i += 2;
                }
                if (ltype.name) linetypes[ltype.name] = ltype;
              } else { i += 2; }
            }
          } else {
            while (i < lines.length) {
              code = lines[i].trim();
              value = lines[i+1] ? lines[i+1].trim() : "";
              if (code === "0" && (value === "ENDTAB" || value === "ENDTABLE")) {
                i += 2;
                break;
              }
              i += 2;
            }
          }
        } else { i += 2; }
      }
      return { layers: layers, linetypes: linetypes, nextIndex: i };
    }

    /* =========================================================================
       DXF Parsing – Main Function
    ========================================================================= */
    function parseDXF(text) {
      const lines = text.split(/\r\n|\n/);
      let dxf = { entities: [], blocks: {}, layers: {}, linetypes: {} };
      let i = 0;
      while (i < lines.length) {
        let code = lines[i].trim();
        let value = lines[i+1] ? lines[i+1].trim() : "";
        if (code === "0" && value === "SECTION") {
          i += 2;
          if (lines[i].trim() === "2") {
            let sectionName = lines[i+1].trim();
            i += 2;
            if (sectionName === "TABLES") {
              let tableResult = parseTables(lines, i);
              dxf.layers = tableResult.layers;
              dxf.linetypes = tableResult.linetypes;
              i = tableResult.nextIndex;
            } else if (sectionName === "BLOCKS") {
              while (i < lines.length) {
                code = lines[i].trim();
                value = lines[i+1] ? lines[i+1].trim() : "";
                if (code === "0" && value === "ENDSEC") { i += 2; break; }
                if (code === "0" && value === "BLOCK") {
                  let block = { name:"", basePoint: {x:0,y:0}, entities: [] };
                  i += 2;
                  while (i < lines.length) {
                    code = lines[i].trim();
                    value = lines[i+1] ? lines[i+1].trim() : "";
                    if (code === "0" && (value === "ENDBLK" ||
                        ["LINE", "CIRCLE", "ARC", "LWPOLYLINE", "POLYLINE", "TEXT", "MTEXT", "DIMENSION", "HATCH"].includes(value))) break;
                    if (code === "2") block.name = value;
                    else if (code === "10") block.basePoint.x = parseFloat(value);
                    else if (code === "20") block.basePoint.y = parseFloat(value);
                    i += 2;
                  }
                  while (i < lines.length) {
                    code = lines[i].trim();
                    value = lines[i+1] ? lines[i+1].trim() : "";
                    if (code === "0" && value === "ENDBLK") { i += 2; break; }
                    if (code === "0") {
                      let result = parseEntity(lines, i);
                      if (result) { block.entities.push(result.entity); i = result.nextIndex; continue; }
                    }
                    i += 2;
                  }
                  dxf.blocks[block.name] = block;
                  continue;
                }
                i += 2;
              }
            } else if (sectionName === "ENTITIES") {
              while (i < lines.length) {
                code = lines[i].trim();
                value = lines[i+1] ? lines[i+1].trim() : "";
                if (code === "0" && value === "ENDSEC") { i += 2; break; }
                if (code === "0") {
                  let result = parseEntity(lines, i);
                  if (result) {
                    let entity = result.entity;
                    i = result.nextIndex;
                    if (entity.type === "INSERT") {
                      entity.attribs = [];
                      while (i < lines.length) {
                        let codePeek = lines[i].trim();
                        let valuePeek = lines[i+1] ? lines[i+1].trim() : "";
                        if (codePeek === "0" && valuePeek === "ATTRIB") {
                          let attribResult = parseEntity(lines, i);
                          if (attribResult) { entity.attribs.push(attribResult.entity); i = attribResult.nextIndex; continue; }
                        }
                        break;
                      }
                    }
                    dxf.entities.push(entity);
                    continue;
                  }
                }
                i += 2;
              }
            } else {
              while (i < lines.length) {
                code = lines[i].trim();
                value = lines[i+1] ? lines[i+1].trim() : "";
                if (code === "0" && value === "ENDSEC") { i += 2; break; }
                i += 2;
              }
            }
          }
          continue;
        }
        i += 2;
      }
      return dxf;
    }

    /* =========================================================================
       parseEntity – Extended to support DIMENSION, HATCH, and MTEXT
    ========================================================================= */
    function parseEntity(lines, i) {
      if (i >= lines.length) return null;
      let code = lines[i].trim();
      let value = lines[i+1] ? lines[i+1].trim() : "";
      if (code !== "0") return null;
      const entity = { type: value };
      i += 2;
      if (entity.type === "POLYLINE") {
        entity.vertices = [];
        while (i < lines.length) {
          code = lines[i].trim();
          value = lines[i+1] ? lines[i+1].trim() : "";
          if (code === "0" && (value === "VERTEX" || value === "SEQEND")) break;
          entity[code] = value;
          i += 2;
        }
        while (i < lines.length) {
          code = lines[i].trim();
          value = lines[i+1] ? lines[i+1].trim() : "";
          if (code === "0" && value === "VERTEX") {
            let vertex = {};
            i += 2;
            while (i < lines.length) {
              let vCode = lines[i].trim();
              let vValue = lines[i+1] ? lines[i+1].trim() : "";
              if (vCode === "0") break;
              if (vCode === "10") vertex.x = parseFloat(vValue);
              else if (vCode === "20") vertex.y = parseFloat(vValue);
              i += 2;
            }
            entity.vertices.push(vertex);
            continue;
          } else if (code === "0" && value === "SEQEND") { i += 2; break; }
          else { i += 2; }
        }
        return { entity: entity, nextIndex: i };
      } else if (entity.type === "LWPOLYLINE") {
        entity.vertices = [];
        while (i < lines.length) {
          code = lines[i].trim();
          value = lines[i+1] ? lines[i+1].trim() : "";
          if (code === "10") {
            let vertex = { x: parseFloat(value) };
            i += 2;
            if (i < lines.length && lines[i].trim() === "20") {
              vertex.y = parseFloat(lines[i+1].trim());
              i += 2;
            }
            entity.vertices.push(vertex);
          } else if (code === "0") break;
          else { entity[code] = value; i += 2; }
        }
        return { entity: entity, nextIndex: i };
      } else if (entity.type === "HATCH") {
        // For our simplified hatch, we parse boundary points and additional hatch parameters.
        // Group codes 10/20 are collected into entity.boundary.
        entity.boundary = [];
        while (i < lines.length) {
          code = lines[i].trim();
          if (code === "0") break;
          value = lines[i+1] ? lines[i+1].trim() : "";
          if (code === "10") {
            let x = parseFloat(value);
            i += 2;
            if (i < lines.length && lines[i].trim() === "20") {
              let y = parseFloat(lines[i+1].trim());
              i += 2;
              entity.boundary.push({ x: x, y: y });
              continue;
            }
          } else {
            // Also capture additional hatch properties like:
            // 70: solid fill flag, 2: pattern name, 52: pattern angle, 41: hatch spacing, 51: pattern offset.
            entity[code] = value;
            i += 2;
          }
        }
        return { entity: entity, nextIndex: i };
      } else if (entity.type === "DIMENSION") {
        // Simply collect all group codes; our draw function will interpret common ones.
        while (i < lines.length) {
          code = lines[i].trim();
          if (code === "0") break;
          value = lines[i+1] ? lines[i+1].trim() : "";
          entity[code] = value;
          i += 2;
        }
        return { entity: entity, nextIndex: i };
      } else if (entity.type === "MTEXT") {
        // MTEXT parsing: collect group codes for position, text, style, etc.
        while (i < lines.length) {
          code = lines[i].trim();
          if (code === "0") break;
          value = lines[i+1] ? lines[i+1].trim() : "";
          entity[code] = value;
          i += 2;
        }
        return { entity: entity, nextIndex: i };
      } else {
        // For other entities, read until next "0".
        while (i < lines.length) {
          code = lines[i].trim();
          if (code === "0") break;
          value = lines[i+1] ? lines[i+1].trim() : "";
          entity[code] = value;
          i += 2;
        }
        return { entity: entity, nextIndex: i };
      }
    }

    /* =========================================================================
       Compute Initial View (bounding box, centering, scaling)
    ========================================================================= */
    function setInitialView() {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      function considerPoint(x,y) {
        if (isNaN(x) || isNaN(y)) return;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
      function processEntity(entity) {
        switch(entity.type) {
          case "LINE":
            considerPoint(parseFloat(entity["10"]), parseFloat(entity["20"]));
            considerPoint(parseFloat(entity["11"]), parseFloat(entity["21"]));
            break;
          case "CIRCLE":
            {
              let cx = parseFloat(entity["10"]),
                  cy = parseFloat(entity["20"]),
                  r = parseFloat(entity["40"]);
              considerPoint(cx - r, cy - r);
              considerPoint(cx + r, cy + r);
            }
            break;
          case "ARC":
            {
              let cx = parseFloat(entity["10"]),
                  cy = parseFloat(entity["20"]),
                  r = parseFloat(entity["40"]);
              considerPoint(cx - r, cy - r);
              considerPoint(cx + r, cy + r);
            }
            break;
          case "POLYLINE":
          case "LWPOLYLINE":
            if (entity.vertices) entity.vertices.forEach(v => considerPoint(v.x, v.y));
            break;
          case "TEXT":
          case "MTEXT":
          case "ATTRIB":
          case "DIMENSION":
            considerPoint(parseFloat(entity["10"]), parseFloat(entity["20"]));
            break;
          case "HATCH":
            if (entity.boundary && entity.boundary.length > 0) {
              entity.boundary.forEach(pt => considerPoint(pt.x, pt.y));
            }
            break;
          case "INSERT":
            considerPoint(parseFloat(entity["10"]), parseFloat(entity["20"]));
            break;
        }
      }
      dxf.entities.forEach(processEntity);
      for (let name in dxf.blocks) {
        let block = dxf.blocks[name];
        considerPoint(block.basePoint.x, block.basePoint.y);
        if (block.entities) block.entities.forEach(processEntity);
      }
      if (minX === Infinity) { minX = -100; minY = -100; maxX = 100; maxY = 100; }
      let drawingWidth = maxX - minX,
          drawingHeight = maxY - minY;
      let scaleX = canvas.width / drawingWidth,
          scaleY = canvas.height / drawingHeight;
      baseScale = 0.9 * Math.min(scaleX, scaleY);
      let centerX = (minX+maxX)/2,
          centerY = (minY+maxY)/2;
      viewScale = baseScale;
      baseOffsetX = canvas.width/2 - baseScale*centerX;
      baseOffsetY = canvas.height/2 + baseScale*centerY;
      viewOffsetX = baseOffsetX;
      viewOffsetY = baseOffsetY;
    }

    /* =========================================================================
       Helper Functions for Hatch Patterns
    ========================================================================= */
    // Compute a bounding box from a boundary (single loop or multiple loops)
    function computeBBox(boundary) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      if (Array.isArray(boundary[0])) {
        boundary.forEach(loop => {
          loop.forEach(pt => {
            minX = Math.min(minX, pt.x);
            minY = Math.min(minY, pt.y);
            maxX = Math.max(maxX, pt.x);
            maxY = Math.max(maxY, pt.y);
          });
        });
      } else {
        boundary.forEach(pt => {
          minX = Math.min(minX, pt.x);
          minY = Math.min(minY, pt.y);
          maxX = Math.max(maxX, pt.x);
          maxY = Math.max(maxY, pt.y);
        });
      }
      return { minX, minY, maxX, maxY };
    }
    // Rotate a point by a given angle (in radians)
    function rotatePoint(x, y, angle) {
      return {
        x: x * Math.cos(angle) - y * Math.sin(angle),
        y: x * Math.sin(angle) + y * Math.cos(angle)
      };
    }
    function degToRad(deg) { return (deg * Math.PI)/180; }

    /* =========================================================================
       Drawing Functions
    ========================================================================= */
    function draw() {
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.restore();

      // Set world transform (flip Y to preserve DXF's Y-up)
      ctx.setTransform(viewScale, 0, 0, -viewScale, viewOffsetX, viewOffsetY);

      if (gridEnabled) drawGrid();
      dxf.entities.forEach(entity => { drawEntity(entity); });
    }

    function drawGrid() {
      const gridSpacing = 10;
      let topLeft = screenToWorld(0,0);
      let bottomRight = screenToWorld(canvas.width, canvas.height);
      let startX = Math.floor(topLeft.x/gridSpacing)*gridSpacing;
      let endX = Math.ceil(bottomRight.x/gridSpacing)*gridSpacing;
      let startY = Math.floor(bottomRight.y/gridSpacing)*gridSpacing;
      let endY = Math.ceil(topLeft.y/gridSpacing)*gridSpacing;
      ctx.save();
      ctx.lineWidth = 0.5 / viewScale;
      ctx.strokeStyle = "#ddd";
      ctx.beginPath();
      for(let x = startX; x <= endX; x += gridSpacing) {
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
      }
      for(let y = startY; y <= endY; y += gridSpacing) {
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
      }
      ctx.stroke();
      ctx.restore();
    }
    function screenToWorld(sx, sy) {
      return { x: (sx - viewOffsetX)/viewScale, y: -(sy - viewOffsetY)/viewScale };
    }
    function worldToScreen(x, y) {
      return { x: viewScale*x + viewOffsetX, y: -viewScale*y + viewOffsetY };
    }

    /* =========================================================================
       Color, Line Weight & Linetype Helpers
    ========================================================================= */
    function getACIColor(aci) {
      if (ACI_COLORS.hasOwnProperty(aci)) return ACI_COLORS[aci];
      return "#000000";
    }
    function getEntityColor(entity) {
      if (entity["420"]) {
        let tc = parseInt(entity["420"]);
        let hex = tc.toString(16).padStart(6,"0");
        return "#" + hex;
      }
      let colorIndex = parseInt(entity["62"]);
      if (!colorIndex || colorIndex === 256) {
        if (entity["8"] && dxf.layers && dxf.layers[entity["8"]] && dxf.layers[entity["8"]]["62"])
          colorIndex = parseInt(dxf.layers[entity["8"]]["62"]);
        else return "#000000";
      }
      return getACIColor(colorIndex);
    }
    function getLineWidth(entity) {
      if (entity["39"] && parseFloat(entity["39"]) !== 0) {
        let thickness = parseFloat(entity["39"]);
        return Math.max(1, thickness * 3.78) / viewScale;
      } else if (entity["370"]) {
        let lw_mm = parseInt(entity["370"]) / 100;
        return Math.max(1, lw_mm * 3.78) / viewScale;
      }
      return 1 / viewScale;
    }
    function getEntityLineDash(entity) {
      let linetypeName = entity["6"];
      if (!linetypeName || linetypeName.toUpperCase() === "BYLAYER") {
        if (entity["8"] && dxf.layers && dxf.layers[entity["8"]] && dxf.layers[entity["8"]]["6"])
          linetypeName = dxf.layers[entity["8"]]["6"];
      }
      if (!linetypeName) return [];
      if (dxf.linetypes && dxf.linetypes[linetypeName]) {
        let ltype = dxf.linetypes[linetypeName];
        if (ltype.pattern && ltype.pattern.length > 0)
          return ltype.pattern.map(d => d * viewScale);
      }
      return [];
    }

    /* =========================================================================
       Entity Drawing Functions
    ========================================================================= */
    function drawEntity(entity) {
      if (entity.type === "TEXT" || entity.type === "ATTRIB") { drawSimpleText(entity); return; }
      if (entity.type === "MTEXT") { drawMTEXT(entity); return; }
      if (entity.type === "DIMENSION") { drawDimension(entity); return; }
      if (entity.type === "HATCH") { drawHatch(entity); return; }
      if (entity.type === "INSERT") {
        ctx.save();
        let blockName = entity["2"];
        let block = dxf.blocks[blockName];
        if (block) {
          let insX = parseFloat(entity["10"]) || 0,
              insY = parseFloat(entity["20"]) || 0;
          let scaleX = entity["41"] ? parseFloat(entity["41"]) : 1,
              scaleY = entity["42"] ? parseFloat(entity["42"]) : 1;
          let rotation = entity["50"] ? degToRad(parseFloat(entity["50"])) : 0;
          let bp = block.basePoint || {x:0,y:0};
          ctx.translate(insX, insY);
          ctx.rotate(rotation);
          ctx.scale(scaleX, scaleY);
          ctx.translate(-bp.x, -bp.y);
          block.entities.forEach(be => drawEntity(be));
          if (entity.attribs) entity.attribs.forEach(attr => drawEntity(attr));
        }
        ctx.restore();
        return;
      }
      ctx.save();
      ctx.lineWidth = getLineWidth(entity);
      let color = getEntityColor(entity);
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      let dash = getEntityLineDash(entity);
      if (dash.length > 0) ctx.setLineDash(dash);
      switch(entity.type) {
        case "LINE":
          {
            let x1 = parseFloat(entity["10"]),
                y1 = parseFloat(entity["20"]),
                x2 = parseFloat(entity["11"]),
                y2 = parseFloat(entity["21"]);
            ctx.beginPath();
            ctx.moveTo(x1,y1);
            ctx.lineTo(x2,y2);
            ctx.stroke();
          }
          break;
        case "CIRCLE":
          {
            let cx = parseFloat(entity["10"]),
                cy = parseFloat(entity["20"]),
                r = parseFloat(entity["40"]);
            ctx.beginPath();
            ctx.arc(cx,cy,r,0,2*Math.PI);
            ctx.stroke();
          }
          break;
        case "ARC":
          {
            let cx = parseFloat(entity["10"]),
                cy = parseFloat(entity["20"]),
                r = parseFloat(entity["40"]);
            let startAngle = degToRad(parseFloat(entity["50"] || "0")),
                endAngle = degToRad(parseFloat(entity["51"] || "0"));
            ctx.beginPath();
            ctx.arc(cx,cy,r,startAngle,endAngle);
            ctx.stroke();
          }
          break;
        case "POLYLINE":
        case "LWPOLYLINE":
          if (entity.vertices && entity.vertices.length > 0) {
            ctx.beginPath();
            ctx.moveTo(entity.vertices[0].x, entity.vertices[0].y);
            for (let i = 1; i < entity.vertices.length; i++)
              ctx.lineTo(entity.vertices[i].x, entity.vertices[i].y);
            if (entity["70"] && (parseInt(entity["70"]) & 1)) ctx.closePath();
            ctx.stroke();
          }
          break;
        default:
          break;
      }
      ctx.restore();
    }

    function drawSimpleText(entity) {
      let x = parseFloat(entity["10"]),
          y = parseFloat(entity["20"]),
          height = entity["40"] ? parseFloat(entity["40"]) : 12,
          rotation = entity["50"] ? degToRad(parseFloat(entity["50"])) : 0,
          text = entity["1"] || "";
      let screen = worldToScreen(x,y),
          screenFontSize = height * viewScale;
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.translate(screen.x, screen.y);
      ctx.rotate(-rotation);
      ctx.fillStyle = getEntityColor(entity);
      ctx.font = `${screenFontSize}px ${entity["7"] || "sans-serif"}`;
      ctx.textBaseline = "middle";
      ctx.fillText(text, 0, 0);
      ctx.restore();
    }

    /* =========================================================================
       Dimension Rendering
       (A basic linear dimension support with improved text orientation)
    ========================================================================= */
    function drawDimension(entity) {
      // Expect group codes:
      // 10/20: first measured point; 11/21: second measured point;
      // 1: dimension text (optional)
      let p1 = { x: parseFloat(entity["10"]), y: parseFloat(entity["20"]) };
      let p2 = { x: parseFloat(entity["11"]), y: parseFloat(entity["21"]) };
      let dimText = entity["1"] || "";

      // Compute vector along measured line.
      let dx = p2.x - p1.x, dy = p2.y - p1.y;
      let len = Math.sqrt(dx * dx + dy * dy);
      if (len === 0) return;
      let ux = dx / len, uy = dy / len;

      // Perpendicular vector.
      let vx = -uy, vy = ux;

      // Offset for extension lines.
      let offset = 5;
      let p1_ext = { x: p1.x + vx * offset, y: p1.y + vy * offset };
      let p2_ext = { x: p2.x + vx * offset, y: p2.y + vy * offset };

      let color = getEntityColor(entity);
      let lw = getLineWidth(entity);

      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = lw;

      // Draw extension lines.
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p1_ext.x, p1_ext.y);
      ctx.moveTo(p2.x, p2.y);
      ctx.lineTo(p2_ext.x, p2_ext.y);
      ctx.stroke();

      // Draw the dimension line.
      ctx.beginPath();
      ctx.moveTo(p1_ext.x, p1_ext.y);
      ctx.lineTo(p2_ext.x, p2_ext.y);
      ctx.stroke();

      // Draw arrowheads.
      let arrowSize = 3;
      function drawArrow(pt, dir) {
        let halfWidth = arrowSize / 2;
        let base = { x: pt.x - arrowSize * dir.x, y: pt.y - arrowSize * dir.y };
        let left = { x: base.x + halfWidth * (-dir.y), y: base.y + halfWidth * (dir.x) };
        let right = { x: base.x - halfWidth * (-dir.y), y: base.y - halfWidth * (dir.x) };
        ctx.beginPath();
        ctx.moveTo(pt.x, pt.y);
        ctx.lineTo(left.x, left.y);
        ctx.lineTo(right.x, right.y);
        ctx.closePath();
        ctx.fill();
      }
      drawArrow(p1_ext, { x: ux, y: uy });
      drawArrow(p2_ext, { x: -ux, y: -uy });

      // Compute midpoint for the dimension text.
      let mid = { x: (p1_ext.x + p2_ext.x) / 2, y: (p1_ext.y + p2_ext.y) / 2 };

      // Calculate the angle of the measured line.
      let angle = Math.atan2(uy, ux);
      // Adjust angle to keep text readable.
      if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
        angle += Math.PI;
      }

      ctx.save();
      ctx.translate(mid.x, mid.y);
      ctx.rotate(angle);
      ctx.font = `12px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(dimText, 0, -offset - 2);
      ctx.restore();
      ctx.restore();
    }

    /* =========================================================================
       Hatch Rendering
       (Enhanced to support both solid and pattern fills with correct size)
    ========================================================================= */
    function drawHatch(entity) {
      if (!entity.boundary || entity.boundary.length === 0) return;
      
      // Determine whether to use solid fill or pattern fill.
      let isSolid = false;
      if (entity["70"] !== undefined) {
        isSolid = (parseInt(entity["70"]) & 1) !== 0;
      }
      if (entity["2"]) {
        let patternName = entity["2"].toUpperCase();
        if (patternName === "SOLID" || patternName === "*SOLID") {
          isSolid = true;
        }
      }
      
      if (isSolid) {
        // Solid fill: create a path from the boundary and fill it.
        ctx.save();
        let fillColor = getEntityColor(entity) || "#cccccc";
        ctx.fillStyle = fillColor;
        ctx.strokeStyle = fillColor;
        ctx.lineWidth = 1 / viewScale;
        ctx.beginPath();
        if (Array.isArray(entity.boundary[0])) {
          entity.boundary.forEach(loop => {
            if (loop.length > 0) {
              ctx.moveTo(loop[0].x, loop[0].y);
              for (let i = 1; i < loop.length; i++) {
                ctx.lineTo(loop[i].x, loop[i].y);
              }
              ctx.closePath();
            }
          });
        } else {
          ctx.moveTo(entity.boundary[0].x, entity.boundary[0].y);
          for (let i = 1; i < entity.boundary.length; i++) {
            ctx.lineTo(entity.boundary[i].x, entity.boundary[i].y);
          }
          ctx.closePath();
        }
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      } else {
        // Pattern fill: use hatch parameters to draw parallel lines inside the hatch.
        ctx.save();
        // Create a clipping path from the hatch boundary.
        ctx.beginPath();
        if (Array.isArray(entity.boundary[0])) {
          entity.boundary.forEach(loop => {
            if (loop.length > 0) {
              ctx.moveTo(loop[0].x, loop[0].y);
              for (let i = 1; i < loop.length; i++) {
                ctx.lineTo(loop[i].x, loop[i].y);
              }
              ctx.closePath();
            }
          });
        } else {
          ctx.moveTo(entity.boundary[0].x, entity.boundary[0].y);
          for (let i = 1; i < entity.boundary.length; i++) {
            ctx.lineTo(entity.boundary[i].x, entity.boundary[i].y);
          }
          ctx.closePath();
        }
        ctx.clip();
        
        // Get hatch pattern parameters.
        let patternAngle = degToRad(parseFloat(entity["52"]) || 0);
        let spacing = parseFloat(entity["41"]) || 10; // default spacing
        
        // Compute bounding box for the hatch boundary.
        let bbox = computeBBox(entity.boundary);
        
        // Compute rotated bounding box corners.
        let corners = [
          { x: bbox.minX, y: bbox.minY },
          { x: bbox.maxX, y: bbox.minY },
          { x: bbox.maxX, y: bbox.maxY },
          { x: bbox.minX, y: bbox.maxY }
        ];
        let rotatedCorners = corners.map(pt => rotatePoint(pt.x, pt.y, -patternAngle));
        let rotatedXs = rotatedCorners.map(pt => pt.x);
        let rotatedYs = rotatedCorners.map(pt => pt.y);
        let minXRot = Math.min(...rotatedXs);
        let maxXRot = Math.max(...rotatedXs);
        let minYRot = Math.min(...rotatedYs);
        let maxYRot = Math.max(...rotatedYs);
        
        // Draw hatch lines in the rotated coordinate system.
        ctx.save();
        ctx.rotate(-patternAngle);
        ctx.beginPath();
        for (let y = minYRot - spacing; y <= maxYRot + spacing; y += spacing) {
          ctx.moveTo(minXRot - spacing, y);
          ctx.lineTo(maxXRot + spacing, y);
        }
        ctx.strokeStyle = getEntityColor(entity);
        ctx.lineWidth = 1 / viewScale;
        ctx.stroke();
        ctx.restore();
        ctx.restore();
      }
    }

    /* =========================================================================
       MTEXT Parsing & Rendering – Improved Formatting & Layout
    ========================================================================= */
    function parseMTEXTContent(rawText, defaultSize, defaultFont, defaultColor) {
      // Replace common DXF escape sequences.
      rawText = rawText.replace(/%%d/g, "°").replace(/%%c/g, "Ø");
      let defaultStyle = { scale: 1, font: defaultFont, underline: false, bold: false, italic: false, color: defaultColor };
      let result = parseFormattedText(rawText, 0, defaultStyle);
      return result.segments;
    }
    function parseFormattedText(text, pos, currentStyle) {
      let segments = [];
      let currentSegment = { text: "", style: Object.assign({}, currentStyle) };
      while (pos < text.length) {
        let ch = text[pos];
        if (ch === '{') {
          if (currentSegment.text) { segments.push(currentSegment); currentSegment = { text:"", style: Object.assign({}, currentStyle) }; }
          let groupResult = parseGroup(text, pos+1, Object.assign({}, currentStyle));
          segments.push(...groupResult.segments);
          pos = groupResult.pos;
        } else if (ch === '}') {
          if (currentSegment.text) segments.push(currentSegment);
          return { segments: segments, pos: pos+1 };
        } else if (ch === '\\') {
          if (text.substr(pos,2) === '\\P') {
            if (currentSegment.text) segments.push(currentSegment);
            segments.push({ paragraphBreak: true });
            pos += 2;
            currentSegment = { text:"", style: Object.assign({}, currentStyle) };
            continue;
          } else if (text.substr(pos,2) === '\\L') { currentStyle.underline = true; pos +=2; continue; }
          else if (text.substr(pos,2) === '\\l') { currentStyle.underline = false; pos +=2; continue; }
          else { currentSegment.text += ch; pos++; }
        } else { currentSegment.text += ch; pos++; }
      }
      if (currentSegment.text) segments.push(currentSegment);
      return { segments: segments, pos: pos };
    }
    function parseGroup(text, pos, currentStyle) {
      if (text.substr(pos,2) === '\\H') {
        pos += 2;
        let multiplierStr = "";
        while (pos < text.length && text[pos] !== 'x') { multiplierStr += text[pos]; pos++; }
        let multiplier = parseFloat(multiplierStr);
        pos++; // skip 'x'
        if (text[pos] === ';') pos++;
        let newStyle = Object.assign({}, currentStyle);
        newStyle.scale = currentStyle.scale * multiplier;
        let result = parseFormattedText(text, pos, newStyle);
        return { segments: result.segments, pos: result.pos };
      } else if (text.substr(pos,2) === '\\F') {
        pos += 2;
        let fontName = "";
        while (pos < text.length && text[pos] !== ';') { fontName += text[pos]; pos++; }
        if (text[pos] === ';') pos++;
        let newStyle = Object.assign({}, currentStyle);
        newStyle.font = fontName;
        let result = parseFormattedText(text, pos, newStyle);
        return { segments: result.segments, pos: result.pos };
      } else {
        return parseFormattedText(text, pos, currentStyle);
      }
    }
    function measureSegment(segment, defaultSize) {
      let size = defaultSize * (segment.style.scale || 1) * viewScale;
      let font = segment.style.font || "sans-serif";
      let weight = segment.style.bold ? "bold " : "";
      let italic = segment.style.italic ? "italic " : "";
      ctx.font = italic + weight + size + "px " + font;
      return ctx.measureText(segment.text).width;
    }
    function wrapMTEXTSegments(segments, maxWidth, defaultSize) {
      let lines = [];
      let currentLine = [];
      let currentLineWidth = 0;
      for (let seg of segments) {
        if (seg.paragraphBreak) { lines.push(currentLine); currentLine = []; currentLineWidth = 0; continue; }
        let tokens = seg.text.split(/(\s+)/);
        for (let token of tokens) {
          if (token === "") continue;
          let tokenSegment = { text: token, style: seg.style };
          let tokenWidth = measureSegment(tokenSegment, defaultSize);
          if (currentLineWidth + tokenWidth > maxWidth && currentLine.length > 0) {
            lines.push(currentLine); currentLine = []; currentLineWidth = 0;
          }
          currentLine.push(tokenSegment);
          currentLineWidth += tokenWidth;
        }
      }
      if (currentLine.length > 0) lines.push(currentLine);
      return lines;
    }
    function drawMTEXT(entity) {
      let x = parseFloat(entity["10"]),
          y = parseFloat(entity["20"]),
          defaultSize = entity["40"] ? parseFloat(entity["40"]) : 12,
          rotation = entity["50"] ? degToRad(parseFloat(entity["50"])) : 0,
          rawText = entity["1"] || "",
          defaultFont = entity["7"] || "sans-serif",
          defaultColor = getEntityColor(entity);
      let parsedSegments = parseMTEXTContent(rawText, defaultSize, defaultFont, defaultColor);
      // Split segments into paragraphs
      let paragraphs = [], currentParagraph = [];
      parsedSegments.forEach(seg => { 
        if (seg.paragraphBreak) { paragraphs.push(currentParagraph); currentParagraph = []; }
        else { currentParagraph.push(seg); }
      });
      if (currentParagraph.length > 0) paragraphs.push(currentParagraph);
      // Wrap lines if a wrap width is provided (group code 41)
      let maxWidth = parseFloat(entity["41"]) || 0;
      let wrappedLines = [];
      if (maxWidth > 0) {
         // Convert wrap width from drawing units to screen units.
         let maxWidthScreen = maxWidth * viewScale;
         paragraphs.forEach(para => { 
           let lines = wrapMTEXTSegments(para, maxWidthScreen, defaultSize);
           wrappedLines.push(...lines);
         });
      } else { wrappedLines = paragraphs; }
      
      // Alignment: group code 71 defines the attachment point.
      let align = parseInt(entity["71"]) || 1;
      let hAlign = align % 3, vAlign = Math.floor((align-1)/3);
      let lineHeight = defaultSize * viewScale * 1.2;
      let totalHeight = wrappedLines.length * lineHeight;
      let lineWidths = [], maxLineWidth = 0;
      wrappedLines.forEach(line => {
         let width = line.reduce((sum, seg) => sum + measureSegment(seg, defaultSize), 0);
         lineWidths.push(width);
         if (width > maxLineWidth) maxLineWidth = width;
      });
      // Calculate vertical offset based on vertical alignment.
      let offsetY = (vAlign === 1) ? -totalHeight/2 : (vAlign === 2 ? -totalHeight : 0);
      
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      let screenPos = worldToScreen(x,y);
      ctx.translate(screenPos.x, screenPos.y);
      ctx.rotate(-rotation);
      ctx.translate(0, offsetY);
      for (let i=0; i<wrappedLines.length; i++) {
         let line = wrappedLines[i],
             lineWidth = lineWidths[i],
             offsetX = (hAlign === 2) ? (maxLineWidth - lineWidth)/2 : (hAlign === 0 ? (maxLineWidth - lineWidth) : 0);
         ctx.save();
         ctx.translate(offsetX, i*lineHeight);
         let xPos = 0;
         line.forEach(seg => {
           let segStyle = seg.style,
               segSize = defaultSize * (segStyle.scale || 1) * viewScale,
               segFont = segStyle.font || defaultFont,
               segWeight = segStyle.bold ? "bold " : "",
               segItalic = segStyle.italic ? "italic " : "";
           ctx.font = segItalic + segWeight + segSize + "px " + segFont;
           ctx.fillStyle = segStyle.color || defaultColor;
           ctx.textBaseline = "middle";
           ctx.fillText(seg.text, xPos, 0);
           if (segStyle.underline) {
             let metrics = ctx.measureText(seg.text),
                 underlineY = segSize * 0.6;
             ctx.beginPath();
             ctx.moveTo(xPos, underlineY);
             ctx.lineTo(xPos+metrics.width, underlineY);
             ctx.lineWidth = Math.max(1, segSize/15);
             ctx.strokeStyle = ctx.fillStyle;
             ctx.stroke();
           }
           xPos += ctx.measureText(seg.text).width;
         });
         ctx.restore();
      }
      ctx.restore();
    }

    /* =========================================================================
       Initial Draw
    ========================================================================= */
    draw();
  </script>
</body>
</html>
