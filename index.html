<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Advanced Web DXF Viewer – Dimensions, Hatch, MTEXT & SPLINE</title>
    <style>
      /* Fullscreen canvas and toolbar styling */
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        user-select: none;
      }
      #toolbar {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 110; /* above canvas but below the overlay when open */
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
      }
      #toolbar button,
      #toolbar input {
        margin: 4px 0;
      }
      /* Overlay for modal popup */
      #optionsOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.3);
        z-index: 200;
      }
      /* Styling for the rendering options popup */
      #renderOptions {
        position: absolute;
        top: 50px;
        left: 10px;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
        max-height: 400px;
        overflow-y: auto;
      }
      #renderOptions label {
        font-size: 14px;
      }
      canvas {
        display: block;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="toolbar">
      <div>
        <input type="file" id="dxfFile" accept=".dxf" />
      </div>
      <div>
        <button id="resetView">Reset View</button>
        <button id="toggleGrid">Toggle Grid</button>
      </div>
      <div style="margin-top:8px;">
        <button id="toggleRenderOptions">Rendering Options</button>
      </div>
      <div style="margin-top:8px;">
        <small>Pan with mouse/touch; wheel or pinch to zoom.</small>
      </div>
    </div>
    <!-- The overlay that contains the rendering options popup -->
    <div id="optionsOverlay">
      <div id="renderOptions">
        <div><strong>Entity Types</strong></div>
        <label>
          <input type="checkbox" class="entity-toggle" data-type="LINE" checked /> LINE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="CIRCLE" checked /> CIRCLE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="ARC" checked /> ARC
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="POLYLINE" checked /> POLYLINE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="LWPOLYLINE" checked /> LWPOLYLINE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="HATCH" checked /> HATCH
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="DIMENSION" checked /> DIMENSION
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="MTEXT" checked /> MTEXT
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="SPLINE" checked /> SPLINE
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="INSERT" checked /> INSERT
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="TEXT" checked /> TEXT
        </label><br />
        <label>
          <input type="checkbox" class="entity-toggle" data-type="ATTRIB" checked /> ATTRIB
        </label><br />
        <div style="margin-top:10px;"><strong>Rendering Options</strong></div>
        <label>
          <input type="checkbox" id="toggleLinetype" /> Disable Linetype Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleHatch" /> Disable Hatch Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleColor" /> Disable Color Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleThickness" /> Disable Thickness Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleWidth" /> Disable Width Rendering
        </label><br />
      </div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
      // Global render settings: each entity type is shown by default and all styling is enabled.
      const renderSettings = {
        entity: {
          LINE: true,
          CIRCLE: true,
          ARC: true,
          POLYLINE: true,
          LWPOLYLINE: true,
          HATCH: true,
          DIMENSION: true,
          MTEXT: true,
          SPLINE: true,
          INSERT: true,
          TEXT: true,
          ATTRIB: true
        },
        renderLinetype: true,
        renderHatch: true,
        renderColor: true,
        renderThickness: true,
        renderWidth: true
      };

      // ─────────────────────────────────────────────────────────────
      // Utility functions and classes
      // ─────────────────────────────────────────────────────────────

      class DXFUtils {
        static degToRad(deg) {
          return (deg * Math.PI) / 180;
        }
        static rotatePoint(x, y, angle) {
          return {
            x: x * Math.cos(angle) - y * Math.sin(angle),
            y: x * Math.sin(angle) + y * Math.cos(angle)
          };
        }
      }

      // Compute bounding box from a set of points or loops.
      function computeBBox(boundary) {
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
        if (Array.isArray(boundary[0])) {
          boundary.forEach(loop => {
            loop.forEach(pt => {
              minX = Math.min(minX, pt.x);
              minY = Math.min(minY, pt.y);
              maxX = Math.max(maxX, pt.x);
              maxY = Math.max(maxY, pt.y);
            });
          });
        } else {
          boundary.forEach(pt => {
            minX = Math.min(minX, pt.x);
            minY = Math.min(minY, pt.y);
            maxX = Math.max(maxX, pt.x);
            maxY = Math.max(maxY, pt.y);
          });
        }
        return { minX, minY, maxX, maxY };
      }

      function getDistance(p1, p2) {
        return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
      }
      function getCenter(p1, p2) {
        return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      }
      function getNiceGridSpacing(viewport) {
        const desiredSpacingScreen = 50; // pixels
        let spacingWorld = desiredSpacingScreen / viewport.viewScale;
        let exponent = Math.floor(Math.log10(spacingWorld));
        let fraction = spacingWorld / Math.pow(10, exponent);
        let niceFraction;
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
        return niceFraction * Math.pow(10, exponent);
      }

      // ─────────────────────────────────────────────────────────────
      // MTEXT parsing functions (for formatted text)
      // ─────────────────────────────────────────────────────────────

      function parseMTEXTContent(rawText, defaultSize, defaultFont, defaultColor) {
        rawText = rawText.replace(/%%d/g, "°").replace(/%%c/g, "Ø");
        let defaultStyle = {
          scale: 1,
          font: defaultFont,
          underline: false,
          bold: false,
          italic: false,
          color: defaultColor
        };
        let result = parseFormattedText(rawText, 0, defaultStyle);
        return result.segments;
      }
      function parseFormattedText(text, pos, currentStyle) {
        let segments = [];
        let currentSegment = { text: "", style: Object.assign({}, currentStyle) };
        while (pos < text.length) {
          let ch = text[pos];
          if (ch === '{') {
            if (currentSegment.text) {
              segments.push(currentSegment);
              currentSegment = { text: "", style: Object.assign({}, currentStyle) };
            }
            let groupResult = parseGroup(text, pos + 1, Object.assign({}, currentStyle));
            segments.push(...groupResult.segments);
            pos = groupResult.pos;
          } else if (ch === '}') {
            if (currentSegment.text) segments.push(currentSegment);
            return { segments: segments, pos: pos + 1 };
          } else if (ch === '\\') {
            if (text.substr(pos, 2) === '\\P') {
              if (currentSegment.text) segments.push(currentSegment);
              segments.push({ paragraphBreak: true });
              pos += 2;
              currentSegment = { text: "", style: Object.assign({}, currentStyle) };
              continue;
            } else if (text.substr(pos, 2) === '\\L') {
              currentStyle.underline = true;
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\l') {
              currentStyle.underline = false;
              pos += 2;
              continue;
            } else {
              currentSegment.text += ch;
              pos++;
            }
          } else {
            currentSegment.text += ch;
            pos++;
          }
        }
        if (currentSegment.text) segments.push(currentSegment);
        return { segments: segments, pos: pos };
      }
      function parseGroup(text, pos, currentStyle) {
        if (text.substr(pos, 2) === '\\H') {
          pos += 2;
          let multiplierStr = "";
          while (pos < text.length && text[pos] !== 'x') {
            multiplierStr += text[pos];
            pos++;
          }
          let multiplier = parseFloat(multiplierStr);
          pos++; // skip 'x'
          if (text[pos] === ';') pos++;
          let newStyle = Object.assign({}, currentStyle);
          newStyle.scale = currentStyle.scale * multiplier;
          let result = parseFormattedText(text, pos, newStyle);
          return { segments: result.segments, pos: result.pos };
        } else if (text.substr(pos, 2) === '\\F') {
          pos += 2;
          let fontName = "";
          while (pos < text.length && text[pos] !== ';') {
            fontName += text[pos];
            pos++;
          }
          if (text[pos] === ';') pos++;
          let newStyle = Object.assign({}, currentStyle);
          newStyle.font = fontName;
          let result = parseFormattedText(text, pos, newStyle);
          return { segments: result.segments, pos: result.pos };
        } else {
          return parseFormattedText(text, pos, currentStyle);
        }
      }
      function measureSegment(segment, defaultSize, viewport) {
        let size = defaultSize * (segment.style.scale || 1) * viewport.viewScale;
        let font = segment.style.font || "sans-serif";
        let weight = segment.style.bold ? "bold " : "";
        let italic = segment.style.italic ? "italic " : "";
        let ctx = measureSegment.ctx || (measureSegment.ctx = document.createElement("canvas").getContext("2d"));
        ctx.font = italic + weight + size + "px " + font;
        return ctx.measureText(segment.text).width;
      }
      function wrapMTEXTSegments(segments, maxWidth, defaultSize, viewport) {
        let lines = [];
        let currentLine = [];
        let currentLineWidth = 0;
        segments.forEach(seg => {
          if (seg.paragraphBreak) {
            lines.push(currentLine);
            currentLine = [];
            currentLineWidth = 0;
            return;
          }
          let tokens = seg.text.split(/(\s+)/);
          tokens.forEach(token => {
            if (token === "") return;
            let tokenSegment = { text: token, style: seg.style };
            let tokenWidth = measureSegment(tokenSegment, defaultSize, viewport);
            if (currentLineWidth + tokenWidth > maxWidth && currentLine.length > 0) {
              lines.push(currentLine);
              currentLine = [];
              currentLineWidth = 0;
            }
            currentLine.push(tokenSegment);
            currentLineWidth += tokenWidth;
          });
        });
        if (currentLine.length > 0) lines.push(currentLine);
        return lines;
      }

      // ─────────────────────────────────────────────────────────────
      // DXF Style helper (color, line width, dash)
      // ─────────────────────────────────────────────────────────────

      class DXFStyle {
        static ACI_COLORS = {
          0: "#000000", 1: "#FF0000", 2: "#FFFF00", 3: "#00FF00", 4: "#00FFFF",
          5: "#0000FF", 6: "#FF00FF", 7: "#FFFFFF", 8: "#808080", 9: "#C0C0C0",
          10: "#FF6600", 11: "#FF9900", 12: "#FFCC00", 13: "#CCFF00", 14: "#99FF00",
          15: "#66FF00", 16: "#33FF00", 17: "#00FF33", 18: "#00FF66", 19: "#00FF99",
          20: "#00FFCC", 21: "#00FFFF", 22: "#00CCFF", 23: "#0099FF", 24: "#0066FF",
          25: "#0033FF", 26: "#0000FF", 27: "#3300FF", 28: "#6600FF", 29: "#9900FF",
          30: "#CC00FF", 31: "#FF00FF", 32: "#FF00CC", 33: "#FF0099", 34: "#FF0066",
          35: "#FF0033"
        };
        static getACIColor(aci) {
          if (DXFStyle.ACI_COLORS.hasOwnProperty(aci)) return DXFStyle.ACI_COLORS[aci];
          return DXFStyle.ACI_COLORS[7] || "#FFFFFF";
        }
        static getEntityColor(entity, dxfDoc) {
          // When color rendering is disabled, return the default DXF color (ACI 7)
          if (!renderSettings.renderColor) return DXFStyle.ACI_COLORS[7] || "#FFFFFF";
          if (entity.raw["420"]) {
            let tc = parseInt(entity.raw["420"]);
            let hex = tc.toString(16).padStart(6, "0");
            return "#" + hex;
          }
          let colorIndex = parseInt(entity.raw["62"]);
          if (isNaN(colorIndex) || colorIndex === 0 || colorIndex === 256) {
            if (
              entity.raw["8"] &&
              dxfDoc.layers &&
              dxfDoc.layers[entity.raw["8"]] &&
              dxfDoc.layers[entity.raw["8"]]["62"]
            )
              colorIndex = parseInt(dxfDoc.layers[entity.raw["8"]]["62"]);
            else return DXFStyle.ACI_COLORS[7] || "#FFFFFF";
          }
          return DXFStyle.getACIColor(colorIndex);
        }
        static getLineWidth(entity, viewport) {
          if (!renderSettings.renderThickness) {
            return 1 / viewport.viewScale;
          }
          let width;
          if (entity.raw["39"] && parseFloat(entity.raw["39"]) !== 0) {
            let thickness = parseFloat(entity.raw["39"]);
            width = Math.max(1, thickness * 3.78);
          } else if (entity.raw["370"]) {
            let lw_mm = parseInt(entity.raw["370"]) / 100;
            width = Math.max(1, lw_mm * 3.78);
          } else {
            width = 1;
          }
          if (renderSettings.renderWidth) {
            return width / viewport.viewScale;
          } else {
            return width;
          }
        }
        static getEntityLineDash(entity, viewport, dxfDoc) {
          if (!renderSettings.renderLinetype) return [];
          let linetypeName = entity.raw["6"];
          if (!linetypeName || linetypeName.toUpperCase() === "BYLAYER") {
            if (
              entity.raw["8"] &&
              dxfDoc.layers &&
              dxfDoc.layers[entity.raw["8"]] &&
              dxfDoc.layers[entity.raw["8"]]["6"]
            )
              linetypeName = dxfDoc.layers[entity.raw["8"]]["6"];
          }
          if (!linetypeName) return [];
          if (dxfDoc.linetypes && dxfDoc.linetypes[linetypeName]) {
            let ltype = dxfDoc.linetypes[linetypeName];
            if (ltype.pattern && ltype.pattern.length > 0)
              return ltype.pattern.map(d => d * viewport.viewScale);
          }
          return [];
        }
      }

      // ─────────────────────────────────────────────────────────────
      // Base DXF entity class (common behavior)
      // ─────────────────────────────────────────────────────────────

      class DXFEntity {
        constructor(type) {
          this.type = type;
          this.raw = {};
        }
        getColor(dxfDoc) {
          return DXFStyle.getEntityColor(this, dxfDoc);
        }
        getLineWidth(viewport) {
          return DXFStyle.getLineWidth(this, viewport);
        }
        getLineDash(viewport, dxfDoc) {
          return DXFStyle.getEntityLineDash(this, viewport, dxfDoc);
        }
        applyStyle(ctx, viewport, dxfDoc) {
          ctx.lineWidth = this.getLineWidth(viewport);
          let color = this.getColor(dxfDoc);
          ctx.strokeStyle = color;
          ctx.fillStyle = color;
          let dash = this.getLineDash(viewport, dxfDoc);
          if (dash && dash.length > 0) ctx.setLineDash(dash);
        }
        // Each subclass must implement draw(ctx, viewport, dxfDoc)
      }

      // ─────────────────────────────────────────────────────────────
      // DXFEntity subclasses for different entity types
      // ─────────────────────────────────────────────────────────────

      class DXFLine extends DXFEntity {
        constructor() {
          super("LINE");
          this.x1 = 0;
          this.y1 = 0;
          this.x2 = 0;
          this.y2 = 0;
        }
        static parse(lines, i) {
          let line = new DXFLine();
          i += 2; // skip "0" "LINE"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            switch (code) {
              case "10":
                line.x1 = parseFloat(value);
                break;
              case "20":
                line.y1 = parseFloat(value);
                break;
              case "11":
                line.x2 = parseFloat(value);
                break;
              case "21":
                line.y2 = parseFloat(value);
                break;
              default:
                line.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: line, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["LINE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.moveTo(this.x1, this.y1);
          ctx.lineTo(this.x2, this.y2);
          ctx.stroke();
        }
      }

      class DXFCircle extends DXFEntity {
        constructor() {
          super("CIRCLE");
          this.cx = 0;
          this.cy = 0;
          this.r = 0;
        }
        static parse(lines, i) {
          let circle = new DXFCircle();
          i += 2; // skip "0" "CIRCLE"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            switch (code) {
              case "10":
                circle.cx = parseFloat(value);
                break;
              case "20":
                circle.cy = parseFloat(value);
                break;
              case "40":
                circle.r = parseFloat(value);
                break;
              default:
                circle.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: circle, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["CIRCLE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.arc(this.cx, this.cy, this.r, 0, 2 * Math.PI);
          ctx.stroke();
        }
      }

      class DXFArc extends DXFEntity {
        constructor() {
          super("ARC");
          this.cx = 0;
          this.cy = 0;
          this.r = 0;
          this.startAngle = 0;
          this.endAngle = 0;
        }
        static parse(lines, i) {
          let arc = new DXFArc();
          i += 2; // skip "0" "ARC"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            switch (code) {
              case "10":
                arc.cx = parseFloat(value);
                break;
              case "20":
                arc.cy = parseFloat(value);
                break;
              case "40":
                arc.r = parseFloat(value);
                break;
              case "50":
                arc.startAngle = parseFloat(value);
                break;
              case "51":
                arc.endAngle = parseFloat(value);
                break;
              default:
                arc.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: arc, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["ARC"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let startRad = DXFUtils.degToRad(this.startAngle);
          let endRad = DXFUtils.degToRad(this.endAngle);
          ctx.beginPath();
          ctx.arc(this.cx, this.cy, this.r, startRad, endRad);
          ctx.stroke();
        }
      }

      class DXFPolyline extends DXFEntity {
        constructor() {
          super("POLYLINE");
          this.vertices = [];
          this.closed = false;
        }
        static parse(lines, i) {
          let polyline = new DXFPolyline();
          i += 2; // skip "0" "POLYLINE"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0" && (lines[i + 1].trim() === "VERTEX" || lines[i + 1].trim() === "SEQEND"))
              break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            if (code === "70") {
              let flag = parseInt(value);
              polyline.closed = (flag & 1) !== 0;
            } else {
              polyline.raw[code] = value;
            }
            i += 2;
          }
          // Parse vertices
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            if (code === "0" && value === "VERTEX") {
              let vertex = {};
              i += 2; // skip "0" "VERTEX"
              while (i < lines.length) {
                let vCode = lines[i].trim();
                if (vCode === "0") break;
                let vValue = lines[i + 1] ? lines[i + 1].trim() : "";
                if (vCode === "10") vertex.x = parseFloat(vValue);
                else if (vCode === "20") vertex.y = parseFloat(vValue);
                i += 2;
              }
              polyline.vertices.push(vertex);
              continue;
            } else if (code === "0" && value === "SEQEND") {
              i += 2;
              break;
            } else {
              i += 2;
            }
          }
          return { entity: polyline, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["POLYLINE"]) return;
          if (this.vertices.length === 0) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
          for (let i = 1; i < this.vertices.length; i++) {
            ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
          }
          if (this.closed) ctx.closePath();
          ctx.stroke();
        }
      }

      class DXFLwPolyline extends DXFEntity {
        constructor() {
          super("LWPOLYLINE");
          this.vertices = [];
        }
        static parse(lines, i) {
          let lwpoly = new DXFLwPolyline();
          i += 2; // skip "0" "LWPOLYLINE"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "10") {
              let vertex = { x: parseFloat(lines[i + 1].trim()) };
              i += 2;
              if (i < lines.length && lines[i].trim() === "20") {
                vertex.y = parseFloat(lines[i + 1].trim());
                i += 2;
              }
              lwpoly.vertices.push(vertex);
              continue;
            } else if (code === "0") break;
            else {
              let value = lines[i + 1] ? lines[i + 1].trim() : "";
              lwpoly.raw[code] = value;
              i += 2;
            }
          }
          return { entity: lwpoly, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["LWPOLYLINE"]) return;
          if (this.vertices.length === 0) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
          for (let i = 1; i < this.vertices.length; i++) {
            ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
          }
          ctx.stroke();
        }
      }

      class DXFHatch extends DXFEntity {
        constructor() {
          super("HATCH");
          this.boundary = [];
        }
        static parse(lines, i) {
          let hatch = new DXFHatch();
          i += 2; // skip "0" "HATCH"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            if (code === "10") {
              let x = parseFloat(value);
              i += 2;
              if (i < lines.length && lines[i].trim() === "20") {
                let y = parseFloat(lines[i + 1].trim());
                i += 2;
                hatch.boundary.push({ x: x, y: y });
                continue;
              }
            } else {
              hatch.raw[code] = value;
            }
            i += 2;
          }
          return { entity: hatch, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["HATCH"]) return;
          if (!renderSettings.renderHatch) return;
          if (!this.boundary || this.boundary.length === 0) return;
          let isSolid = false;
          if (this.raw["70"] !== undefined) {
            isSolid = (parseInt(this.raw["70"]) & 1) !== 0;
          }
          if (this.raw["2"]) {
            let patternName = this.raw["2"].toUpperCase();
            if (patternName === "SOLID" || patternName === "*SOLID") {
              isSolid = true;
            }
          }
          if (isSolid) {
            ctx.save();
            let fillColor = DXFStyle.getEntityColor(this, dxfDoc) || "#cccccc";
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = fillColor;
            ctx.lineWidth = 1 / viewport.viewScale;
            ctx.beginPath();
            if (Array.isArray(this.boundary[0])) {
              this.boundary.forEach(loop => {
                if (loop.length > 0) {
                  ctx.moveTo(loop[0].x, loop[0].y);
                  for (let i = 1; i < loop.length; i++) {
                    ctx.lineTo(loop[i].x, loop[i].y);
                  }
                  ctx.closePath();
                }
              });
            } else {
              ctx.moveTo(this.boundary[0].x, this.boundary[0].y);
              for (let i = 1; i < this.boundary.length; i++) {
                ctx.lineTo(this.boundary[i].x, this.boundary[i].y);
              }
              ctx.closePath();
            }
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          } else {
            ctx.save();
            ctx.beginPath();
            if (Array.isArray(this.boundary[0])) {
              this.boundary.forEach(loop => {
                if (loop.length > 0) {
                  ctx.moveTo(loop[0].x, loop[0].y);
                  for (let i = 1; i < loop.length; i++) {
                    ctx.lineTo(loop[i].x, loop[i].y);
                  }
                  ctx.closePath();
                }
              });
            } else {
              ctx.moveTo(this.boundary[0].x, this.boundary[0].y);
              for (let i = 1; i < this.boundary.length; i++) {
                ctx.lineTo(this.boundary[i].x, this.boundary[i].y);
              }
              ctx.closePath();
            }
            ctx.clip();
            let patternAngle = DXFUtils.degToRad(parseFloat(this.raw["52"]) || 0);
            let spacing = parseFloat(this.raw["41"]) || 10;
            let bbox = computeBBox(this.boundary);
            let corners = [
              { x: bbox.minX, y: bbox.minY },
              { x: bbox.maxX, y: bbox.minY },
              { x: bbox.maxX, y: bbox.maxY },
              { x: bbox.minX, y: bbox.maxY }
            ];
            let rotatedCorners = corners.map(pt => DXFUtils.rotatePoint(pt.x, pt.y, -patternAngle));
            let rotatedXs = rotatedCorners.map(pt => pt.x);
            let rotatedYs = rotatedCorners.map(pt => pt.y);
            let minXRot = Math.min(...rotatedXs);
            let maxXRot = Math.max(...rotatedXs);
            let minYRot = Math.min(...rotatedYs);
            let maxYRot = Math.max(...rotatedYs);
            ctx.save();
            ctx.rotate(-patternAngle);
            ctx.beginPath();
            for (let y = minYRot - spacing; y <= maxYRot + spacing; y += spacing) {
              ctx.moveTo(minXRot - spacing, y);
              ctx.lineTo(maxXRot + spacing, y);
            }
            ctx.strokeStyle = DXFStyle.getEntityColor(this, dxfDoc);
            ctx.lineWidth = 1 / viewport.viewScale;
            ctx.stroke();
            ctx.restore();
            ctx.restore();
          }
        }
      }

      class DXFDimension extends DXFEntity {
        constructor() {
          super("DIMENSION");
          this.p1 = { x: 0, y: 0 };
          this.p2 = { x: 0, y: 0 };
          this.defPt = null;
          this.text = "";
        }
        static parse(lines, i) {
          let dim = new DXFDimension();
          i += 2; // skip "0" "DIMENSION"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            switch (code) {
              case "10":
                dim.p1.x = parseFloat(value);
                break;
              case "20":
                dim.p1.y = parseFloat(value);
                break;
              case "11":
                dim.p2.x = parseFloat(value);
                break;
              case "21":
                dim.p2.y = parseFloat(value);
                break;
              case "13":
              case "23":
                if (!dim.defPt) dim.defPt = { x: 0, y: 0 };
                if (code === "13") dim.defPt.x = parseFloat(value);
                else dim.defPt.y = parseFloat(value);
                break;
              case "1":
                dim.text = value;
                break;
              default:
                dim.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: dim, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["DIMENSION"]) return;
          let p1 = this.p1;
          let p2 = this.p2;
          let dx = p2.x - p1.x,
            dy = p2.y - p1.y;
          let baselineLength = Math.sqrt(dx * dx + dy * dy);
          if (baselineLength === 0) return;
          let u = { x: dx / baselineLength, y: dy / baselineLength };
          let v = { x: -u.y, y: u.x };
          let mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
          let offsetDistance;
          if (this.defPt) {
            offsetDistance = (this.defPt.x - mid.x) * v.x + (this.defPt.y - mid.y) * v.y;
          } else {
            offsetDistance = 5;
          }
          let p1_dim = { x: p1.x + v.x * offsetDistance, y: p1.y + v.y * offsetDistance };
          let p2_dim = { x: p2.x + v.x * offsetDistance, y: p2.y + v.y * offsetDistance };
          let dimText = this.text.trim();
          if (dimText === "" || dimText === "<>") {
            dimText = baselineLength.toFixed(2);
          }
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p1_dim.x, p1_dim.y);
          ctx.moveTo(p2.x, p2.y);
          ctx.lineTo(p2_dim.x, p2_dim.y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(p1_dim.x, p1_dim.y);
          ctx.lineTo(p2_dim.x, p2_dim.y);
          ctx.stroke();
          function drawArrow(pt, direction) {
            const arrowSize = 3;
            const arrowAngle = Math.PI / 6;
            let leftAngle = Math.atan2(direction.y, direction.x) + arrowAngle;
            let rightAngle = Math.atan2(direction.y, direction.x) - arrowAngle;
            let left = {
              x: pt.x - arrowSize * Math.cos(leftAngle),
              y: pt.y - arrowSize * Math.sin(leftAngle)
            };
            let right = {
              x: pt.x - arrowSize * Math.cos(rightAngle),
              y: pt.y - arrowSize * Math.sin(rightAngle)
            };
            ctx.beginPath();
            ctx.moveTo(pt.x, pt.y);
            ctx.lineTo(left.x, left.y);
            ctx.lineTo(right.x, right.y);
            ctx.closePath();
            ctx.fill();
          }
          let arrowDir = { x: p2_dim.x - p1_dim.x, y: p2_dim.y - p1_dim.y };
          let arrowLen = Math.sqrt(arrowDir.x * arrowDir.x + arrowDir.y * arrowDir.y);
          if (arrowLen !== 0) {
            arrowDir.x /= arrowLen;
            arrowDir.y /= arrowLen;
            drawArrow(p1_dim, arrowDir);
            drawArrow(p2_dim, { x: -arrowDir.x, y: -arrowDir.y });
          }
          let dimLineMid = { x: (p1_dim.x + p2_dim.x) / 2, y: (p1_dim.y + p2_dim.y) / 2 };
          let angle = Math.atan2(u.y, u.x);
          if (angle > Math.PI / 2 || angle < -Math.PI / 2) angle += Math.PI;
          ctx.save();
          ctx.translate(dimLineMid.x, dimLineMid.y);
          ctx.rotate(angle);
          const fontSize = 12;
          ctx.font = `${fontSize}px sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(dimText, 0, 0);
          ctx.restore();
        }
      }

      class DXFMTEXT extends DXFEntity {
        constructor() {
          super("MTEXT");
          this.position = { x: 0, y: 0 };
          this.height = 12;
          this.rotation = 0;
          this.rawText = "";
          this.font = "sans-serif";
          this.maxWidth = 0;
          this.align = 1;
        }
        static parse(lines, i) {
          let mtext = new DXFMTEXT();
          i += 2; // skip "0" "MTEXT"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            switch (code) {
              case "10":
                mtext.position.x = parseFloat(value);
                break;
              case "20":
                mtext.position.y = parseFloat(value);
                break;
              case "40":
                mtext.height = parseFloat(value);
                break;
              case "50":
                mtext.rotation = parseFloat(value);
                break;
              case "1":
                mtext.rawText = value;
                break;
              case "7":
                mtext.font = value;
                break;
              case "41":
                mtext.maxWidth = parseFloat(value);
                break;
              case "71":
                mtext.align = parseInt(value);
                break;
              default:
                mtext.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: mtext, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["MTEXT"]) return;
          let x = this.position.x,
            y = this.position.y;
          let defaultSize = this.height;
          let rotation = this.rotation ? DXFUtils.degToRad(this.rotation) : 0;
          let rawText = this.rawText || "";
          let defaultFont = this.font || "sans-serif";
          let defaultColor = this.getColor(dxfDoc);
          let parsedSegments = parseMTEXTContent(rawText, defaultSize, defaultFont, defaultColor);
          let paragraphs = [],
            currentParagraph = [];
          parsedSegments.forEach(seg => {
            if (seg.paragraphBreak) {
              paragraphs.push(currentParagraph);
              currentParagraph = [];
            } else {
              currentParagraph.push(seg);
            }
          });
          if (currentParagraph.length > 0) paragraphs.push(currentParagraph);
          let maxWidth = this.maxWidth || 0;
          let wrappedLines = [];
          if (maxWidth > 0) {
            let maxWidthScreen = maxWidth * viewport.viewScale;
            paragraphs.forEach(para => {
              let lines = wrapMTEXTSegments(para, maxWidthScreen, defaultSize, viewport);
              wrappedLines.push(...lines);
            });
          } else {
            wrappedLines = paragraphs;
          }
          let align = this.align || 1;
          let hAlign = align % 3,
            vAlign = Math.floor((align - 1) / 3);
          let lineHeight = defaultSize * viewport.viewScale * 1.2;
          let totalHeight = wrappedLines.length * lineHeight;
          let lineWidths = [],
            maxLineWidth = 0;
          wrappedLines.forEach(line => {
            let width = line.reduce((sum, seg) => sum + measureSegment(seg, defaultSize, viewport), 0);
            lineWidths.push(width);
            if (width > maxLineWidth) maxLineWidth = width;
          });
          let offsetY = (vAlign === 1)
            ? -totalHeight / 2
            : (vAlign === 2 ? -totalHeight : 0);
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          let screenPos = viewport.worldToScreen(x, y);
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(-rotation);
          ctx.translate(0, offsetY);
          for (let i = 0; i < wrappedLines.length; i++) {
            let line = wrappedLines[i],
              lineWidth = lineWidths[i],
              offsetX =
                hAlign === 2
                  ? (maxLineWidth - lineWidth) / 2
                  : (hAlign === 0 ? (maxLineWidth - lineWidth) : 0);
            ctx.save();
            ctx.translate(offsetX, i * lineHeight);
            let xPos = 0;
            line.forEach(seg => {
              let segStyle = seg.style,
                segSize = defaultSize * (segStyle.scale || 1) * viewport.viewScale,
                segFont = segStyle.font || defaultFont,
                segWeight = segStyle.bold ? "bold " : "",
                segItalic = segStyle.italic ? "italic " : "";
              ctx.font = segItalic + segWeight + segSize + "px " + segFont;
              ctx.fillStyle = segStyle.color || defaultColor;
              ctx.textBaseline = "alphabetic";
              ctx.fillText(seg.text, xPos, 0);
              if (segStyle.underline) {
                let metrics = ctx.measureText(seg.text);
                let underlineY =
                  metrics.actualBoundingBoxDescent !== undefined
                    ? metrics.actualBoundingBoxDescent + 2
                    : segSize * 0.3;
                ctx.beginPath();
                ctx.moveTo(xPos, underlineY);
                ctx.lineTo(xPos + metrics.width, underlineY);
                ctx.lineWidth = Math.max(1, segSize / 15);
                ctx.strokeStyle = ctx.fillStyle;
                ctx.stroke();
              }
              xPos += ctx.measureText(seg.text).width;
            });
            ctx.restore();
          }
          ctx.restore();
        }
      }

      class DXFSpline extends DXFEntity {
        constructor() {
          super("SPLINE");
          this.degree = null;
          this.knots = [];
          this.controlPoints = [];
          this.fitPoints = [];
        }
        static parse(lines, i) {
          let spline = new DXFSpline();
          i += 2; // skip "0" "SPLINE"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            switch (code) {
              case "70":
                spline.raw["70"] = value;
                break;
              case "71":
                spline.degree = parseInt(value);
                break;
              case "72":
                spline.raw["72"] = value;
                break;
              case "73":
                spline.raw["73"] = value;
                break;
              case "74":
                spline.raw["74"] = value;
                break;
              case "40":
                spline.knots.push(parseFloat(value));
                break;
              case "10":
                {
                  let pt = { x: parseFloat(value) };
                  i += 2;
                  if (i < lines.length && lines[i].trim() === "20") {
                    pt.y = parseFloat(lines[i + 1].trim());
                    i += 2;
                  } else {
                    pt.y = 0;
                    i -= 2;
                  }
                  spline.controlPoints.push(pt);
                  continue;
                }
              case "11":
                {
                  let pt = { x: parseFloat(value) };
                  i += 2;
                  if (i < lines.length && lines[i].trim() === "21") {
                    pt.y = parseFloat(lines[i + 1].trim());
                    i += 2;
                  } else {
                    pt.y = 0;
                    i -= 2;
                  }
                  spline.fitPoints.push(pt);
                  continue;
                }
              default:
                spline.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: spline, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["SPLINE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let samplePoints = [];
          if (
            this.controlPoints &&
            this.controlPoints.length >= (this.degree + 1) &&
            this.knots &&
            this.knots.length > 0 &&
            this.degree !== null
          ) {
            let k = this.degree;
            let cp = this.controlPoints;
            let knots = this.knots;
            let t_min = knots[k];
            let t_max = knots[knots.length - k - 1];
            let numSamples = 50;
            for (let i = 0; i <= numSamples; i++) {
              let t = t_min + (t_max - t_min) * (i / numSamples);
              let pt = deBoor(k, cp, knots, t);
              samplePoints.push(pt);
            }
          } else if (this.fitPoints && this.fitPoints.length >= 2) {
            samplePoints = this.fitPoints;
          } else {
            return;
          }
          ctx.beginPath();
          ctx.moveTo(samplePoints[0].x, samplePoints[0].y);
          for (let i = 1; i < samplePoints.length; i++) {
            ctx.lineTo(samplePoints[i].x, samplePoints[i].y);
          }
          ctx.stroke();
        }
      }
      // de Boor algorithm for B‑spline evaluation
      function deBoor(k, cp, knots, t) {
        let n = cp.length - 1;
        let i = k;
        for (; i <= n; i++) {
          if (t < knots[i + 1]) {
            break;
          }
        }
        if (i > n) i = n;
        let d = [];
        for (let j = 0; j <= k; j++) {
          d[j] = { x: cp[i - k + j].x, y: cp[i - k + j].y };
        }
        for (let r = 1; r <= k; r++) {
          for (let j = k; j >= r; j--) {
            let index = i - k + j;
            let denominator = knots[index + k - r + 1] - knots[index];
            let alpha = denominator === 0 ? 0 : (t - knots[index]) / denominator;
            d[j].x = (1 - alpha) * d[j - 1].x + alpha * d[j].x;
            d[j].y = (1 - alpha) * d[j - 1].y + alpha * d[j].y;
          }
        }
        return d[k];
      }

      class DXFInsert extends DXFEntity {
        constructor() {
          super("INSERT");
          this.blockName = "";
          this.insertionPoint = { x: 0, y: 0 };
          this.scale = { x: 1, y: 1 };
          this.rotation = 0;
          this.attribs = [];
        }
        static parse(lines, i) {
          let insert = new DXFInsert();
          i += 2; // skip "0" "INSERT"
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            switch (code) {
              case "2":
                insert.blockName = value;
                break;
              case "10":
                insert.insertionPoint.x = parseFloat(value);
                break;
              case "20":
                insert.insertionPoint.y = parseFloat(value);
                break;
              case "41":
                insert.scale.x = parseFloat(value);
                break;
              case "42":
                insert.scale.y = parseFloat(value);
                break;
              case "50":
                insert.rotation = parseFloat(value);
                break;
              default:
                insert.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: insert, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["INSERT"]) return;
          ctx.save();
          let block = dxfDoc.blocks[this.blockName];
          if (block) {
            let insX = this.insertionPoint.x;
            let insY = this.insertionPoint.y;
            let scaleX = this.scale.x;
            let scaleY = this.scale.y;
            let rotation = DXFUtils.degToRad(this.rotation);
            let bp = block.basePoint || { x: 0, y: 0 };
            ctx.translate(insX, insY);
            ctx.rotate(rotation);
            ctx.scale(scaleX, scaleY);
            ctx.translate(-bp.x, -bp.y);
            block.entities.forEach(be => {
              if (renderSettings.entity[be.type] !== false) {
                be.draw(ctx, viewport, dxfDoc);
              }
            });
            if (this.attribs)
              this.attribs.forEach(attr => {
                if (renderSettings.entity[attr.type] !== false) attr.draw(ctx, viewport, dxfDoc);
              });
          }
          ctx.restore();
        }
      }

      class DXFText extends DXFEntity {
        // Used for both TEXT and ATTRIB
        constructor(type) {
          super(type);
          this.position = { x: 0, y: 0 };
          this.height = 12;
          this.rotation = 0;
          this.text = "";
          this.font = "sans-serif";
        }
        static parse(lines, i) {
          let textEntity = new DXFText(lines[i + 1].trim()); // type: TEXT or ATTRIB
          i += 2; // skip "0" "TEXT" (or ATTRIB)
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            switch (code) {
              case "10":
                textEntity.position.x = parseFloat(value);
                break;
              case "20":
                textEntity.position.y = parseFloat(value);
                break;
              case "40":
                textEntity.height = parseFloat(value);
                break;
              case "50":
                textEntity.rotation = parseFloat(value);
                break;
              case "1":
                textEntity.text = value;
                break;
              case "7":
                textEntity.font = value;
                break;
              default:
                textEntity.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: textEntity, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity[this.type]) return;
          let x = this.position.x,
            y = this.position.y;
          let height = this.height;
          let rotation = this.rotation ? DXFUtils.degToRad(this.rotation) : 0;
          let text = this.text;
          let screen = viewport.worldToScreen(x, y);
          let screenFontSize = height * viewport.viewScale;
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.translate(screen.x, screen.y);
          ctx.rotate(-rotation);
          ctx.fillStyle = this.getColor(dxfDoc);
          ctx.font = `${screenFontSize}px ${this.font}`;
          ctx.textBaseline = "alphabetic";
          ctx.fillText(text, 0, 0);
          ctx.restore();
        }
      }

      // Fallback for unrecognized entity types.
      class GenericDXFEntity extends DXFEntity {
        constructor(type) {
          super(type);
        }
        static parse(lines, i) {
          let generic = new GenericDXFEntity(lines[i + 1].trim());
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            generic.raw[code] = value;
            i += 2;
          }
          return { entity: generic, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          // Do nothing.
        }
      }

      // ─────────────────────────────────────────────────────────────
      // DXF Block and Document classes
      // ─────────────────────────────────────────────────────────────

      class DXFBlock {
        constructor(name) {
          this.name = name;
          this.basePoint = { x: 0, y: 0 };
          this.entities = [];
        }
      }

      class DXFDocument {
        constructor() {
          this.entities = [];
          this.blocks = {};
          this.layers = {};
          this.linetypes = {};
        }
      }

      // ─────────────────────────────────────────────────────────────
      // DXF Parser (parses the DXF text into a DXFDocument)
      // ─────────────────────────────────────────────────────────────

      class DXFParser {
        parse(text) {
          const lines = text.split(/\r\n|\n/);
          let dxf = new DXFDocument();
          let i = 0;
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            if (code === "0" && value === "SECTION") {
              i += 2;
              if (lines[i].trim() === "2") {
                let sectionName = lines[i + 1].trim();
                i += 2;
                if (sectionName === "TABLES") {
                  let tableResult = this.parseTables(lines, i);
                  dxf.layers = tableResult.layers;
                  dxf.linetypes = tableResult.linetypes;
                  i = tableResult.nextIndex;
                } else if (sectionName === "BLOCKS") {
                  while (i < lines.length) {
                    code = lines[i].trim();
                    value = lines[i + 1] ? lines[i + 1].trim() : "";
                    if (code === "0" && value === "ENDSEC") {
                      i += 2;
                      break;
                    }
                    if (code === "0" && value === "BLOCK") {
                      let block = new DXFBlock("");
                      i += 2;
                      while (i < lines.length) {
                        code = lines[i].trim();
                        value = lines[i + 1] ? lines[i + 1].trim() : "";
                        if (code === "0" && (value === "ENDBLK" || 
                            ["LINE", "CIRCLE", "ARC", "LWPOLYLINE", "POLYLINE", "TEXT", "MTEXT", "DIMENSION", "HATCH", "SPLINE"].includes(value))) {
                          break;
                        }
                        if (code === "2") {
                          block.name = value;
                        } else if (code === "10") {
                          block.basePoint.x = parseFloat(value);
                        } else if (code === "20") {
                          block.basePoint.y = parseFloat(value);
                        }
                        i += 2;
                      }
                      while (i < lines.length) {
                        code = lines[i].trim();
                        value = lines[i + 1] ? lines[i + 1].trim() : "";
                        if (code === "0" && value === "ENDBLK") {
                          i += 2;
                          break;
                        }
                        if (code === "0") {
                          let result = this.parseEntity(lines, i);
                          if (result) {
                            block.entities.push(result.entity);
                            i = result.nextIndex;
                            continue;
                          }
                        }
                        i += 2;
                      }
                      dxf.blocks[block.name] = block;
                      continue;
                    }
                    i += 2;
                  }
                } else if (sectionName === "ENTITIES") {
                  while (i < lines.length) {
                    code = lines[i].trim();
                    value = lines[i + 1] ? lines[i + 1].trim() : "";
                    if (code === "0" && value === "ENDSEC") {
                      i += 2;
                      break;
                    }
                    if (code === "0") {
                      let result = this.parseEntity(lines, i);
                      if (result) {
                        let entity = result.entity;
                        i = result.nextIndex;
                        if (entity.type === "INSERT") {
                          entity.attribs = [];
                          while (i < lines.length) {
                            let codePeek = lines[i].trim();
                            let valuePeek = lines[i + 1] ? lines[i + 1].trim() : "";
                            if (codePeek === "0" && valuePeek === "ATTRIB") {
                              let attribResult = this.parseEntity(lines, i);
                              if (attribResult) {
                                entity.attribs.push(attribResult.entity);
                                i = attribResult.nextIndex;
                                continue;
                              }
                            }
                            break;
                          }
                        }
                        dxf.entities.push(entity);
                        continue;
                      }
                    }
                    i += 2;
                  }
                } else {
                  while (i < lines.length) {
                    code = lines[i].trim();
                    value = lines[i + 1] ? lines[i + 1].trim() : "";
                    if (code === "0" && value === "ENDSEC") {
                      i += 2;
                      break;
                    }
                    i += 2;
                  }
                }
              }
              continue;
            }
            i += 2;
          }
          return dxf;
        }
        parseTables(lines, i) {
          let layers = {};
          let linetypes = {};
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = lines[i + 1] ? lines[i + 1].trim() : "";
            if (code === "0" && value === "ENDSEC") {
              i += 2;
              break;
            }
            if (code === "0" && value === "TABLE") {
              i += 2;
              let tableName = lines[i + 1] ? lines[i + 1].trim() : "";
              i += 2;
              if (tableName === "LAYER") {
                while (i < lines.length) {
                  code = lines[i].trim();
                  value = lines[i + 1] ? lines[i + 1].trim() : "";
                  if (code === "0" && (value === "ENDTAB" || value === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  if (code === "0" && value === "LAYER") {
                    let layer = {};
                    i += 2;
                    while (i < lines.length) {
                      code = lines[i].trim();
                      if (code === "0") break;
                      value = lines[i + 1] ? lines[i + 1].trim() : "";
                      if (code === "2") layer.name = value;
                      else if (code === "62") layer["62"] = value;
                      else if (code === "6") layer["6"] = value;
                      i += 2;
                    }
                    if (layer.name) layers[layer.name] = layer;
                  } else {
                    i += 2;
                  }
                }
              } else if (tableName === "LTYPE") {
                while (i < lines.length) {
                  code = lines[i].trim();
                  value = lines[i + 1] ? lines[i + 1].trim() : "";
                  if (code === "0" && (value === "ENDTAB" || value === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  if (code === "0" && value === "LTYPE") {
                    let ltype = {};
                    i += 2;
                    while (i < lines.length) {
                      code = lines[i].trim();
                      if (code === "0") break;
                      value = lines[i + 1] ? lines[i + 1].trim() : "";
                      if (code === "2") ltype.name = value;
                      else if (code === "3") ltype.description = value;
                      else if (code === "72") ltype.flags = value;
                      else if (code === "73") ltype.elements = parseInt(value);
                      else if (code === "40") ltype.patternLength = parseFloat(value);
                      else if (code === "49") {
                        if (!ltype.pattern) ltype.pattern = [];
                        ltype.pattern.push(parseFloat(value));
                      }
                      i += 2;
                    }
                    if (ltype.name) linetypes[ltype.name] = ltype;
                  } else {
                    i += 2;
                  }
                }
              } else {
                while (i < lines.length) {
                  code = lines[i].trim();
                  value = lines[i + 1] ? lines[i + 1].trim() : "";
                  if (code === "0" && (value === "ENDTAB" || value === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  i += 2;
                }
              }
            } else {
              i += 2;
            }
          }
          return { layers, linetypes, nextIndex: i };
        }
        parseEntity(lines, i) {
          if (i >= lines.length) return null;
          let code = lines[i].trim();
          let value = lines[i + 1] ? lines[i + 1].trim() : "";
          if (code !== "0") return null;
          switch (value) {
            case "LINE":
              return DXFLine.parse(lines, i);
            case "CIRCLE":
              return DXFCircle.parse(lines, i);
            case "ARC":
              return DXFArc.parse(lines, i);
            case "POLYLINE":
              return DXFPolyline.parse(lines, i);
            case "LWPOLYLINE":
              return DXFLwPolyline.parse(lines, i);
            case "HATCH":
              return DXFHatch.parse(lines, i);
            case "DIMENSION":
              return DXFDimension.parse(lines, i);
            case "MTEXT":
              return DXFMTEXT.parse(lines, i);
            case "SPLINE":
              return DXFSpline.parse(lines, i);
            case "INSERT":
              return DXFInsert.parse(lines, i);
            case "TEXT":
            case "ATTRIB":
              return DXFText.parse(lines, i);
            default:
              return GenericDXFEntity.parse(lines, i);
          }
        }
      }

      // ─────────────────────────────────────────────────────────────
      // Viewport: holds view transformation parameters
      // ─────────────────────────────────────────────────────────────

      class Viewport {
        constructor(canvas) {
          this.canvas = canvas;
          this.baseScale = 1;
          this.baseOffsetX = 0;
          this.baseOffsetY = 0;
          this.viewScale = 1;
          this.viewOffsetX = 0;
          this.viewOffsetY = 0;
        }
        reset() {
          this.viewScale = this.baseScale;
          this.viewOffsetX = this.baseOffsetX;
          this.viewOffsetY = this.baseOffsetY;
        }
        setInitialView(dxfDoc) {
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          function considerPoint(x, y) {
            if (isNaN(x) || isNaN(y)) return;
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
          function processEntity(entity) {
            switch (entity.type) {
              case "LINE":
                considerPoint(entity.x1, entity.y1);
                considerPoint(entity.x2, entity.y2);
                break;
              case "CIRCLE":
                {
                  let cx = entity.cx,
                    cy = entity.cy,
                    r = entity.r;
                  considerPoint(cx - r, cy - r);
                  considerPoint(cx + r, cy + r);
                }
                break;
              case "ARC":
                {
                  let cx = entity.cx,
                    cy = entity.cy,
                    r = entity.r;
                  considerPoint(cx - r, cy - r);
                  considerPoint(cx + r, cy + r);
                }
                break;
              case "POLYLINE":
              case "LWPOLYLINE":
                if (entity.vertices) entity.vertices.forEach(v => considerPoint(v.x, v.y));
                break;
              case "TEXT":
              case "MTEXT":
              case "ATTRIB":
              case "DIMENSION":
                considerPoint(entity.position.x, entity.position.y);
                break;
              case "HATCH":
                if (entity.boundary && entity.boundary.length > 0) {
                  entity.boundary.forEach(pt => considerPoint(pt.x, pt.y));
                }
                break;
              case "INSERT":
                considerPoint(entity.insertionPoint.x, entity.insertionPoint.y);
                break;
              case "SPLINE":
                if (entity.fitPoints && entity.fitPoints.length > 0) {
                  entity.fitPoints.forEach(pt => considerPoint(pt.x, pt.y));
                } else if (entity.controlPoints && entity.controlPoints.length > 0) {
                  entity.controlPoints.forEach(pt => considerPoint(pt.x, pt.y));
                }
                break;
            }
          }
          dxfDoc.entities.forEach(processEntity);
          for (let name in dxfDoc.blocks) {
            let block = dxfDoc.blocks[name];
            considerPoint(block.basePoint.x, block.basePoint.y);
            if (block.entities) block.entities.forEach(processEntity);
          }
          if (minX === Infinity) {
            minX = -100;
            minY = -100;
            maxX = 100;
            maxY = 100;
          }
          let drawingWidth = maxX - minX,
            drawingHeight = maxY - minY;
          let scaleX = this.canvas.width / drawingWidth,
            scaleY = this.canvas.height / drawingHeight;
          this.baseScale = 0.9 * Math.min(scaleX, scaleY);
          let centerX = (minX + maxX) / 2,
            centerY = (minY + maxY) / 2;
          this.viewScale = this.baseScale;
          this.baseOffsetX = this.canvas.width / 2 - this.baseScale * centerX;
          this.baseOffsetY = this.canvas.height / 2 + this.baseScale * centerY;
          this.viewOffsetX = this.baseOffsetX;
          this.viewOffsetY = this.baseOffsetY;
        }
        worldToScreen(x, y) {
          return {
            x: this.viewScale * x + this.viewOffsetX,
            y: -this.viewScale * y + this.viewOffsetY
          };
        }
        screenToWorld(sx, sy) {
          return {
            x: (sx - this.viewOffsetX) / this.viewScale,
            y: -(sy - this.viewOffsetY) / this.viewScale
          };
        }
      }

      // ─────────────────────────────────────────────────────────────
      // DXF Viewer (main application class)
      // ─────────────────────────────────────────────────────────────

      class DXFViewer {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          this.viewport = new Viewport(canvas);
          this.dxfDoc = new DXFDocument();
          this.parser = new DXFParser();
          this.gridEnabled = false;
          this.isPanning = false;
          this.lastPanPoint = { x: 0, y: 0 };
          this.ongoingTouches = [];
          this.lastTouchDistance = null;
          this.lastTouchCenter = null;
          this.registerEventHandlers();
          window.addEventListener("resize", () => this.onResize());
          this.onResize();
        }
        onResize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          if (this.dxfDoc.entities.length > 0) {
            this.viewport.setInitialView(this.dxfDoc);
          }
          this.draw();
        }
        loadDXF(text) {
          let dxfParsed = this.parser.parse(text);
          if (dxfParsed.entities.length === 0 && Object.keys(dxfParsed.blocks).length === 0) {
            alert("No supported entities found in DXF.");
            return;
          }
          this.dxfDoc = dxfParsed;
          this.viewport.setInitialView(this.dxfDoc);
          this.draw();
        }
        toggleGrid() {
          this.gridEnabled = !this.gridEnabled;
          this.draw();
        }
        resetView() {
          this.viewport.reset();
          this.draw();
        }
        draw() {
          const ctx = this.ctx;
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          ctx.restore();
          ctx.setTransform(
            this.viewport.viewScale,
            0,
            0,
            -this.viewport.viewScale,
            this.viewport.viewOffsetX,
            this.viewport.viewOffsetY
          );
          if (this.gridEnabled) this.drawGrid();
          this.dxfDoc.entities.forEach(entity => {
            if (renderSettings.entity[entity.type] !== false) {
              entity.draw(ctx, this.viewport, this.dxfDoc);
            }
          });
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        drawGrid() {
          let gridSpacing = getNiceGridSpacing(this.viewport);
          let topLeft = this.viewport.screenToWorld(0, 0);
          let bottomRight = this.viewport.screenToWorld(this.canvas.width, this.canvas.height);
          let startX = Math.floor(topLeft.x / gridSpacing) * gridSpacing;
          let endX = Math.ceil(bottomRight.x / gridSpacing) * gridSpacing;
          let startY = Math.floor(bottomRight.y / gridSpacing) * gridSpacing;
          let endY = Math.ceil(topLeft.y / gridSpacing) * gridSpacing;
          const ctx = this.ctx;
          ctx.save();
          ctx.lineWidth = 1 / this.viewport.viewScale;
          ctx.strokeStyle = "#444444";
          ctx.beginPath();
          for (let x = startX; x <= endX; x += gridSpacing) {
            ctx.moveTo(x, startY);
            ctx.lineTo(x, endY);
          }
          for (let y = startY; y <= endY; y += gridSpacing) {
            ctx.moveTo(startX, y);
            ctx.lineTo(endX, y);
          }
          ctx.stroke();
          ctx.restore();
        }
        registerEventHandlers() {
          this.canvas.addEventListener("mousedown", (e) => {
            this.isPanning = true;
            this.lastPanPoint = { x: e.clientX, y: e.clientY };
          });
          this.canvas.addEventListener("mousemove", (e) => {
            if (this.isPanning) {
              let dx = e.clientX - this.lastPanPoint.x;
              let dy = e.clientY - this.lastPanPoint.y;
              this.lastPanPoint = { x: e.clientX, y: e.clientY };
              this.viewport.viewOffsetX += dx;
              this.viewport.viewOffsetY += dy;
              this.draw();
            }
          });
          this.canvas.addEventListener("mouseup", () => (this.isPanning = false));
          this.canvas.addEventListener("mouseleave", () => (this.isPanning = false));
          this.canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            const zoomIntensity = 0.001;
            let factor = 1 - e.deltaY * zoomIntensity;
            let mouseX = e.clientX;
            let mouseY = e.clientY;
            this.viewport.viewOffsetX = mouseX - factor * (mouseX - this.viewport.viewOffsetX);
            this.viewport.viewOffsetY = mouseY - factor * (mouseY - this.viewport.viewOffsetY);
            this.viewport.viewScale *= factor;
            this.draw();
          });
          this.canvas.addEventListener("touchstart", (e) => this.handleTouchStart(e), { passive: false });
          this.canvas.addEventListener("touchmove", (e) => this.handleTouchMove(e), { passive: false });
          this.canvas.addEventListener("touchend", (e) => this.handleTouchEnd(e), { passive: false });
          this.canvas.addEventListener("touchcancel", (e) => this.handleTouchEnd(e), { passive: false });
        }
        getTouchPos(evt) {
          let rect = this.canvas.getBoundingClientRect();
          return Array.from(evt.touches).map((t) => ({
            x: t.clientX - rect.left,
            y: t.clientY - rect.top
          }));
        }
        handleTouchStart(evt) {
          evt.preventDefault();
          let touches = this.getTouchPos(evt);
          this.ongoingTouches = touches;
          if (touches.length === 2) {
            this.lastTouchDistance = getDistance(touches[0], touches[1]);
            this.lastTouchCenter = getCenter(touches[0], touches[1]);
          } else if (touches.length === 1) {
            this.lastPanPoint = touches[0];
          }
        }
        handleTouchMove(evt) {
          evt.preventDefault();
          let touches = this.getTouchPos(evt);
          if (touches.length === 2 && this.ongoingTouches.length >= 2) {
            let newDistance = getDistance(touches[0], touches[1]);
            let factor = newDistance / this.lastTouchDistance;
            let newCenter = getCenter(touches[0], touches[1]);
            this.viewport.viewOffsetX = newCenter.x - factor * (newCenter.x - this.viewport.viewOffsetX);
            this.viewport.viewOffsetY = newCenter.y - factor * (newCenter.y - this.viewport.viewOffsetY);
            this.viewport.viewScale *= factor;
            this.lastTouchDistance = newDistance;
            this.lastTouchCenter = newCenter;
          } else if (touches.length === 1 && this.ongoingTouches.length === 1) {
            let dx = touches[0].x - this.lastPanPoint.x;
            let dy = touches[0].y - this.lastPanPoint.y;
            this.viewport.viewOffsetX += dx;
            this.viewport.viewOffsetY += dy;
            this.lastPanPoint = touches[0];
          }
          this.ongoingTouches = touches;
          this.draw();
        }
        handleTouchEnd(evt) {
          evt.preventDefault();
          let touches = this.getTouchPos(evt);
          this.ongoingTouches = touches;
          if (touches.length < 2) {
            this.lastTouchDistance = null;
            this.lastTouchCenter = null;
          }
          if (touches.length === 0) this.isPanning = false;
        }
      }

      // ─────────────────────────────────────────────────────────────
      // Initialization: attach file and toolbar handlers, then create viewer
      // ─────────────────────────────────────────────────────────────

      const canvas = document.getElementById("canvas");
      const viewer = new DXFViewer(canvas);

      document.getElementById("dxfFile").addEventListener("change", function (e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (event) {
          const text = event.target.result;
          let dxf = viewer.parser.parse(text);
          if (dxf.entities.length === 0 && Object.keys(dxf.blocks).length === 0) {
            alert("No supported entities found in DXF.");
            return;
          }
          viewer.loadDXF(text);
        };
        reader.readAsText(file);
      });

      document.getElementById("resetView").addEventListener("click", function () {
        viewer.resetView();
      });
      document.getElementById("toggleGrid").addEventListener("click", function () {
        viewer.toggleGrid();
      });

      // Toggle the rendering options modal overlay
      const optionsOverlay = document.getElementById("optionsOverlay");
      const renderOptions = document.getElementById("renderOptions");

      document.getElementById("toggleRenderOptions").addEventListener("click", function () {
        optionsOverlay.style.display = "block";
      });

      // When clicking on the overlay (but not the popup), dismiss the options.
      optionsOverlay.addEventListener("click", function (e) {
        if (e.target === optionsOverlay) {
          optionsOverlay.style.display = "none";
        }
      });
      // Prevent clicks inside the popup from propagating to the overlay.
      renderOptions.addEventListener("click", function (e) {
        e.stopPropagation();
      });

      // Listen for changes to entity type checkboxes.
      document.querySelectorAll(".entity-toggle").forEach(checkbox => {
        checkbox.addEventListener("change", function (e) {
          const type = e.target.getAttribute("data-type");
          renderSettings.entity[type] = e.target.checked;
          viewer.draw();
        });
      });

      // Listen for changes to rendering option checkboxes.
      document.getElementById("toggleLinetype").addEventListener("change", function (e) {
        renderSettings.renderLinetype = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleHatch").addEventListener("change", function (e) {
        renderSettings.renderHatch = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleColor").addEventListener("change", function (e) {
        renderSettings.renderColor = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleThickness").addEventListener("change", function (e) {
        renderSettings.renderThickness = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleWidth").addEventListener("change", function (e) {
        renderSettings.renderWidth = !e.target.checked;
        viewer.draw();
      });

      // Initial draw
      viewer.draw();
    </script>
  </body>
</html>
