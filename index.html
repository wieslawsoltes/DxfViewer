<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Web DXF Viewer</title>
  <style>
    /* Basic styling for full‐screen canvas and toolbar */
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
    }
    #toolbar button,
    #toolbar input {
      margin: 4px 0;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div>
      <input type="file" id="dxfFile" accept=".dxf" />
    </div>
    <div>
      <button id="resetView">Reset View</button>
    </div>
    <div>
      <button id="toggleGrid">Toggle Grid</button>
    </div>
    <div style="margin-top:8px;">
      <small>Use mouse wheel to zoom and drag to pan.</small>
    </div>
  </div>
  <canvas id="canvas"></canvas>
  <script>
    // Global variables
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let drawing = null; // will hold the parsed DXF data
    let baseScale = 1, baseOffsetX = 0, baseOffsetY = 0;
    let viewScale = 1, viewOffsetX = 0, viewOffsetY = 0;
    let gridEnabled = true;

    // Variables for panning
    let isPanning = false;
    let startPan = { x: 0, y: 0 };

    // Resize canvas to full window size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // if a drawing is loaded, recompute initial transform
      if (drawing && drawing.entities && drawing.entities.length) {
        setInitialView();
        draw();
      } else {
        draw(); // just clear canvas
      }
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // File input handler
    document.getElementById("dxfFile").addEventListener("change", function (e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (event) {
        const text = event.target.result;
        drawing = parseDXF(text);
        if (drawing.entities.length === 0) {
          alert("No entities found in DXF or unsupported format.");
          return;
        }
        setInitialView();
        draw();
      };
      reader.readAsText(file);
    });

    // Reset view button
    document.getElementById("resetView").addEventListener("click", function () {
      viewScale = baseScale;
      viewOffsetX = baseOffsetX;
      viewOffsetY = baseOffsetY;
      draw();
    });

    // Toggle grid button
    document.getElementById("toggleGrid").addEventListener("click", function () {
      gridEnabled = !gridEnabled;
      draw();
    });

    // Mouse events for panning
    canvas.addEventListener("mousedown", function (e) {
      isPanning = true;
      startPan = { x: e.clientX, y: e.clientY };
    });
    canvas.addEventListener("mousemove", function (e) {
      if (isPanning) {
        const dx = e.clientX - startPan.x;
        const dy = e.clientY - startPan.y;
        startPan = { x: e.clientX, y: e.clientY };
        viewOffsetX += dx;
        viewOffsetY += dy;
        draw();
      }
    });
    canvas.addEventListener("mouseup", () => (isPanning = false));
    canvas.addEventListener("mouseleave", () => (isPanning = false));

    // Wheel event for zooming (zoom relative to mouse pointer)
    canvas.addEventListener("wheel", function (e) {
      e.preventDefault();
      const zoomIntensity = 0.001;
      const delta = e.deltaY;
      const factor = 1 - delta * zoomIntensity;
      // Get mouse position relative to canvas
      const mouseX = e.clientX;
      const mouseY = e.clientY;
      // Adjust offset so that zoom is centered on mouse pointer
      viewOffsetX = mouseX - factor * (mouseX - viewOffsetX);
      viewOffsetY = mouseY - factor * (mouseY - viewOffsetY);
      viewScale *= factor;
      draw();
    });

    // --- DXF Parsing ---------------------------------------------------
    // A simple DXF parser that:
    // • finds the ENTITIES section,
    // • reads entities (starting with group code "0") and
    // • supports LINE, CIRCLE, and ARC.
    function parseDXF(text) {
      const lines = text.split(/\r\n|\n/);
      let i = 0;
      let entities = [];
      // Find the ENTITIES section
      while (i < lines.length) {
        if (lines[i].trim() === "0" && lines[i + 1] && lines[i + 1].trim() === "SECTION") {
          i += 2;
          if (lines[i].trim() === "2" && lines[i + 1] && lines[i + 1].trim() === "ENTITIES") {
            i += 2; // skip the "2" and "ENTITIES" lines
            break;
          }
        }
        i++;
      }
      // Parse entities until ENDSEC
      while (i < lines.length) {
        const code = lines[i].trim();
        const value = lines[i + 1] ? lines[i + 1].trim() : "";
        if (code === "0" && value === "ENDSEC") {
          break;
        }
        if (code === "0") {
          // New entity starts here
          const entityType = value;
          let entity = { type: entityType };
          i += 2;
          // Read entity properties until the next entity (code "0") or end of section
          while (i < lines.length) {
            const nextCode = lines[i].trim();
            if (nextCode === "0") break;
            const nextValue = lines[i + 1] ? lines[i + 1].trim() : "";
            // For simplicity, store property by its code. (Extend as needed.)
            entity[nextCode] = nextValue;
            i += 2;
          }
          // Only add supported entities
          if (["LINE", "CIRCLE", "ARC"].includes(entityType)) {
            entities.push(entity);
          }
        } else {
          i += 2;
        }
      }
      return { entities: entities };
    }

    // --- Compute Bounding Box and Initial Transform --------------------
    // Computes the drawing’s bounding box and sets an initial scale and offset
    // so that the drawing fits nicely inside the canvas.
    function setInitialView() {
      if (!drawing || !drawing.entities.length) return;
      let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
      drawing.entities.forEach((entity) => {
        if (entity.type === "LINE") {
          const x1 = parseFloat(entity["10"]);
          const y1 = parseFloat(entity["20"]);
          const x2 = parseFloat(entity["11"]);
          const y2 = parseFloat(entity["21"]);
          minX = Math.min(minX, x1, x2);
          minY = Math.min(minY, y1, y2);
          maxX = Math.max(maxX, x1, x2);
          maxY = Math.max(maxY, y1, y2);
        } else if (entity.type === "CIRCLE") {
          const cx = parseFloat(entity["10"]);
          const cy = parseFloat(entity["20"]);
          const r = parseFloat(entity["40"]);
          minX = Math.min(minX, cx - r);
          minY = Math.min(minY, cy - r);
          maxX = Math.max(maxX, cx + r);
          maxY = Math.max(maxY, cy + r);
        } else if (entity.type === "ARC") {
          // For simplicity, include the full circle’s bounds.
          const cx = parseFloat(entity["10"]);
          const cy = parseFloat(entity["20"]);
          const r = parseFloat(entity["40"]);
          minX = Math.min(minX, cx - r);
          minY = Math.min(minY, cy - r);
          maxX = Math.max(maxX, cx + r);
          maxY = Math.max(maxY, cy + r);
        }
      });
      // Compute scale factors (leave a margin by using 90% of available space)
      const drawingWidth = maxX - minX;
      const drawingHeight = maxY - minY;
      const scaleX = canvas.width / drawingWidth;
      const scaleY = canvas.height / drawingHeight;
      baseScale = 0.9 * Math.min(scaleX, scaleY);
      // Center of drawing
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      // We will use a transform that maps (x, y) to:
      //   (viewOffsetX + viewScale*x, viewOffsetY - viewScale*y)
      // (note the minus sign to flip the Y-axis, as DXF’s Y increases upward)
      baseOffsetX = canvas.width / 2 - baseScale * centerX;
      baseOffsetY = canvas.height / 2 + baseScale * centerY;
      // Set current view to base view
      viewScale = baseScale;
      viewOffsetX = baseOffsetX;
      viewOffsetY = baseOffsetY;
    }

    // --- Drawing Functions ---------------------------------------------
    function draw() {
      // Clear the canvas
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      // Set transform: scale and flip y axis
      ctx.setTransform(viewScale, 0, 0, -viewScale, viewOffsetX, viewOffsetY);

      // Optionally draw a grid (drawn in world coordinates)
      if (gridEnabled) drawGrid();

      // Draw each DXF entity
      if (drawing && drawing.entities) {
        drawing.entities.forEach((entity) => {
          drawEntity(entity);
        });
      }
    }

    // Draw a simple grid in the DXF coordinate space
    function drawGrid() {
      const gridSpacing = 10; // change as needed
      // Determine grid bounds (in world coordinates) from canvas corners
      const invScale = 1 / viewScale;
      const topLeft = screenToWorld(0, 0);
      const bottomRight = screenToWorld(canvas.width, canvas.height);
      const startX = Math.floor(topLeft.x / gridSpacing) * gridSpacing;
      const endX = Math.ceil(bottomRight.x / gridSpacing) * gridSpacing;
      const startY = Math.floor(bottomRight.y / gridSpacing) * gridSpacing;
      const endY = Math.ceil(topLeft.y / gridSpacing) * gridSpacing;
      ctx.save();
      ctx.lineWidth = 0.5 / viewScale;
      ctx.strokeStyle = "#ddd";
      ctx.beginPath();
      for (let x = startX; x <= endX; x += gridSpacing) {
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
      }
      for (let y = startY; y <= endY; y += gridSpacing) {
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
      }
      ctx.stroke();
      ctx.restore();
    }

    // Draw an individual DXF entity
    function drawEntity(entity) {
      ctx.save();
      ctx.lineWidth = 1 / viewScale;
      ctx.strokeStyle = "#000";
      ctx.fillStyle = "#000";

      if (entity.type === "LINE") {
        const x1 = parseFloat(entity["10"]);
        const y1 = parseFloat(entity["20"]);
        const x2 = parseFloat(entity["11"]);
        const y2 = parseFloat(entity["21"]);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      } else if (entity.type === "CIRCLE") {
        const cx = parseFloat(entity["10"]);
        const cy = parseFloat(entity["20"]);
        const r = parseFloat(entity["40"]);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, 2 * Math.PI);
        ctx.stroke();
      } else if (entity.type === "ARC") {
        const cx = parseFloat(entity["10"]);
        const cy = parseFloat(entity["20"]);
        const r = parseFloat(entity["40"]);
        const startAngle = degToRad(parseFloat(entity["50"] || "0"));
        const endAngle = degToRad(parseFloat(entity["51"] || "0"));
        ctx.beginPath();
        ctx.arc(cx, cy, r, startAngle, endAngle);
        ctx.stroke();
      }
      ctx.restore();
    }

    // Utility: convert degrees to radians.
    function degToRad(deg) {
      return (deg * Math.PI) / 180;
    }

    // Convert screen (pixel) coordinates to world (DXF) coordinates.
    function screenToWorld(sx, sy) {
      // Inverse of: (x, y) -> (viewOffsetX + viewScale*x, viewOffsetY - viewScale*y)
      const x = (sx - viewOffsetX) / viewScale;
      const y = -(sy - viewOffsetY) / viewScale;
      return { x: x, y: y };
    }

    // Initial draw (empty scene)
    draw();
  </script>
</body>
</html>
