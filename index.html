<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Improved Web DXF Viewer – Enhanced MTEXT, HATCH & VIEWPORT Rendering</title>
    <style>
      /* Fullscreen canvas and toolbar styling */
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        user-select: none;
      }
      #toolbar {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 110;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
      }
      #toolbar button,
      #toolbar input,
      #toolbar select {
        margin: 4px 0;
      }
      .optionsOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.3);
        z-index: 200;
      }
      .popupContent {
        position: absolute;
        top: 50px;
        left: 10px;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
        max-height: 400px;
        overflow-y: auto;
      }
      canvas {
        display: block;
        touch-action: none;
      }
      /* New: Entity List panel styling */
      #entityList {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
        max-height: 90%;
        overflow-y: auto;
        font-size: 12px;
      }
      #entityList ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      #entityList li {
        padding: 4px 6px;
        cursor: pointer;
        border-bottom: 1px solid #ccc;
      }
      #entityList li:hover {
        background: #eee;
      }
      /* New: Tooltip styling */
      #entityTooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(255, 255, 255, 0.9);
        padding: 4px;
        border: 1px solid #ccc;
        border-radius: 3px;
        font-size: 12px;
        display: none;
        z-index: 150;
      }
    </style>
  </head>
  <body>
    <div id="toolbar">
      <div>
        <input type="file" id="dxfFile" accept=".dxf" />
      </div>
      <!-- New: layout selection dropdown -->
      <div>
        <select id="layoutSelect">
          <option value="model">Model Space</option>
          <option value="paper">Paper Space</option>
        </select>
      </div>
      <div>
        <button id="zoomExtents">Zoom Extents</button>
        <button id="toggleGrid">Toggle Grid</button>
      </div>
      <div style="margin-top:8px;">
        <button id="toggleEntityOptions">Entity Options</button>
        <button id="toggleOtherOptions">Other Options</button>
      </div>
      <div style="margin-top:8px;">
        <small>Pan with mouse/touch; wheel or pinch to zoom.</small>
      </div>
    </div>

    <!-- New: Entity List panel -->
    <div id="entityList">
      <strong>Entities</strong>
      <ul></ul>
    </div>
    
    <!-- Overlays for popups -->
    <div id="entityOptionsOverlay" class="optionsOverlay">
      <div id="entityOptionsPopup" class="popupContent">
        <div><strong>Entity Types</strong></div>
        <div style="margin:8px 0;">
          <button id="selectAllEntities">Select All</button>
          <button id="deselectAllEntities">Select None</button>
        </div>
        <label><input type="checkbox" class="entity-toggle" data-type="LINE" checked /> LINE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="CIRCLE" checked /> CIRCLE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="ARC" checked /> ARC</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="POLYLINE" checked /> POLYLINE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="LWPOLYLINE" checked /> LWPOLYLINE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="HATCH" checked /> HATCH</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="DIMENSION" checked /> DIMENSION</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="MTEXT" checked /> MTEXT</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="SPLINE" checked /> SPLINE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="INSERT" checked /> INSERT</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="TEXT" checked /> TEXT</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="ATTRIB" checked /> ATTRIB</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="ELLIPSE" checked /> ELLIPSE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="3DFACE" checked /> 3DFACE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="SOLID" checked /> SOLID</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="VIEWPORT" checked /> VIEWPORT</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="3DSOLID" checked /> 3DSOLID</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="ACAD_PROXY_ENTITY" checked /> ACAD_PROXY_ENTITY</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="ATTDEF" checked /> ATTDEF</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="BODY" checked /> BODY</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="HELIX" checked /> HELIX</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="IMAGE" checked /> IMAGE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="LEADER" checked /> LEADER</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="LIGHT" checked /> LIGHT</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="MESH" checked /> MESH</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="MLINE" checked /> MLINE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="MLEADERSTYLE" checked /> MLEADERSTYLE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="MLEADER" checked /> MLEADER</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="OLEFRAME" checked /> OLEFRAME</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="OLE2FRAME" checked /> OLE2FRAME</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="POINT" checked /> POINT</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="RAY" checked /> RAY</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="REGION" checked /> REGION</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="SECTION" checked /> SECTION</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="SHAPE" checked /> SHAPE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="TOLERANCE" checked /> TOLERANCE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="TRACE" checked /> TRACE</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="UNDERLAY" checked /> UNDERLAY</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="VERTEX" checked /> VERTEX</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="WIPEOUT" checked /> WIPEOUT</label><br />
        <label><input type="checkbox" class="entity-toggle" data-type="XLINE" checked /> XLINE</label><br />
      </div>
    </div>

    <div id="otherOptionsOverlay" class="optionsOverlay">
      <div id="otherOptionsPopup" class="popupContent">
        <div><strong>Rendering Options</strong></div>
        <label>
          <input type="checkbox" id="toggleLinetype" /> Disable Linetype Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleColor" /> Disable Color Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleThickness" /> Disable Thickness Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleWidth" /> Disable Width Rendering
        </label><br />
        <label>
          <input type="checkbox" id="toggleTransparency" /> Disable Transparency Rendering
        </label><br />
      </div>
    </div>

    <!-- New: Tooltip element -->
    <div id="entityTooltip"></div>

    <canvas id="canvas"></canvas>

    <script>
      // ─────────────────────────────────────────────────────────────
      // GLOBAL RENDER SETTINGS
      // ─────────────────────────────────────────────────────────────
      const renderSettings = {
        entity: {
          LINE: true,
          CIRCLE: true,
          ARC: true,
          POLYLINE: true,
          LWPOLYLINE: true,
          HATCH: true,
          DIMENSION: true,
          MTEXT: true,
          SPLINE: true,
          INSERT: true,
          TEXT: true,
          ATTRIB: true,
          ELLIPSE: true,
          "3DFACE": true,
          SOLID: true,
          VIEWPORT: true
        },
        renderLinetype: true,
        renderColor: true,
        renderThickness: true,
        renderWidth: true,
        renderTransparency: true
      };

      // ─────────────────────────────────────────────────────────────
      // UTILITY FUNCTIONS & CLASSES
      // ─────────────────────────────────────────────────────────────
      class DXFUtils {
        static degToRad(deg) {
          return (deg * Math.PI) / 180;
        }
        static rotatePoint(x, y, angle) {
          return {
            x: x * Math.cos(angle) - y * Math.sin(angle),
            y: x * Math.sin(angle) + y * Math.cos(angle)
          };
        }
      }
      function getDistance(p1, p2) {
        return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
      }
      function getCenter(p1, p2) {
        return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      }
      function computeBBox(pointsOrLoops) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        if (!pointsOrLoops || pointsOrLoops.length === 0) return { minX, minY, maxX, maxY };
        if (Array.isArray(pointsOrLoops[0])) {
          pointsOrLoops.forEach(loop => {
            loop.forEach(pt => {
              minX = Math.min(minX, pt.x);
              minY = Math.min(minY, pt.y);
              maxX = Math.max(maxX, pt.x);
              maxY = Math.max(maxY, pt.y);
            });
          });
        } else {
          pointsOrLoops.forEach(pt => {
            minX = Math.min(minX, pt.x);
            minY = Math.min(minY, pt.y);
            maxX = Math.max(maxX, pt.x);
            maxY = Math.max(maxY, pt.y);
          });
        }
        return { minX, minY, maxX, maxY };
      }
      function getNiceGridSpacing(viewport) {
        const desiredSpacingScreen = 50;
        let spacingWorld = desiredSpacingScreen / viewport.viewScale;
        let exponent = Math.floor(Math.log10(spacingWorld));
        let fraction = spacingWorld / Math.pow(10, exponent);
        let niceFraction;
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
        return niceFraction * Math.pow(10, exponent);
      }

      // ─────────────────────────────────────────────────────────────
      // MTEXT Parsing Helpers (Enhanced)
      // ─────────────────────────────────────────────────────────────
      // Helper: Replace DXF special sequences with proper Unicode characters
      function substituteSpecialSequences(rawText) {
        return rawText
          .replace(/%%d/g, "⌀")   // Replace diameter (%%d) with Unicode diameter sign
          .replace(/%%c/g, "Ø")    // Replace %%c with Ø (or adjust per your needs)
          .replace(/\\P/g, "\n");  // Convert \P to newline (paragraph break)
      }

      // Main MTEXT parser entry point.
      function parseMTEXTContent(rawText, defaultSize, defaultFont, defaultColor) {
        // First substitute any known special sequences.
        rawText = substituteSpecialSequences(rawText);
        let defaultStyle = {
          scale: 1,
          font: defaultFont,
          underline: false,
          overline: false,
          bold: false,
          italic: false,
          color: defaultColor
        };
        let result = parseFormattedText(rawText, 0, defaultStyle);
        return result.segments;
      }

      // Recursively parse formatted text starting at a given position.
      function parseFormattedText(text, pos, currentStyle) {
        let segments = [];
        let currentSegment = { text: "", style: Object.assign({}, currentStyle) };
        while (pos < text.length) {
          let ch = text[pos];
          if (ch === '{') {
            // Push current pending text before recursing into a group.
            if (currentSegment.text) {
              segments.push(currentSegment);
              currentSegment = { text: "", style: Object.assign({}, currentStyle) };
            }
            let groupResult = parseGroup(text, pos + 1, Object.assign({}, currentStyle));
            segments.push(...groupResult.segments);
            pos = groupResult.pos;
            continue;
          } else if (ch === '}') {
            // End of current group – push any pending text and return.
            if (currentSegment.text) segments.push(currentSegment);
            return { segments: segments, pos: pos + 1 };
          } else if (ch === '^') {
            // Handle caret escape sequences (e.g. ^J for paragraph break)
            pos++;
            if (pos < text.length) {
              let nextChar = text[pos];
              if (nextChar === 'I') {
                currentSegment.text += '\t';
              } else if (nextChar === 'J') {
                if (currentSegment.text) segments.push(currentSegment);
                segments.push({ paragraphBreak: true });
                currentSegment = { text: "", style: Object.assign({}, currentStyle) };
              } else if (nextChar === 'M') {
                // Future expansion: handle any additional caret commands
              } else {
                // Unknown caret sequence: output literally with a placeholder symbol
                currentSegment.text += '▯' + nextChar;
              }
              pos++;
              continue;
            }
          } else if (ch === '\\') {
            // Process backslash commands.
            if (text.substr(pos, 2) === '\\P') {
              if (currentSegment.text) segments.push(currentSegment);
              segments.push({ paragraphBreak: true });
              pos += 2;
              currentSegment = { text: "", style: Object.assign({}, currentStyle) };
              continue;
            } else if (text.substr(pos, 2) === '\\L') {
              currentStyle.underline = true;
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\l') {
              currentStyle.underline = false;
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\O') {
              currentStyle.overline = true;
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\o') {
              currentStyle.overline = false;
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\B') {
              currentStyle.bold = true;
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\b') {
              currentStyle.bold = false;
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\I') {
              currentStyle.italic = true;
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\i') {
              currentStyle.italic = false;
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\C') {
              pos += 2;
              let colorCode = "";
              while (pos < text.length && text[pos] !== ';') {
                colorCode += text[pos];
                pos++;
              }
              if (text[pos] === ';') pos++;
              currentStyle.color = DXFStyle.getACIColor(parseInt(colorCode, 10));
              continue;
            } else if (text.substr(pos, 2) === '\\S') {
              // Handle stacked text: the string before the separator is top text, after is bottom.
              pos += 2;
              let stackedStr = "";
              while (pos < text.length && text[pos] !== ';') {
                stackedStr += text[pos];
                pos++;
              }
              if (text[pos] === ';') pos++;
              let parts = stackedStr.split('^');
              let topText = parts[0] || "";
              let bottomText = parts[1] || "";
              if (currentSegment.text) {
                segments.push(currentSegment);
                currentSegment = { text: "", style: Object.assign({}, currentStyle) };
              }
              segments.push({
                stacked: { top: topText, bottom: bottomText },
                style: Object.assign({}, currentStyle)
              });
              continue;
            } else if (text.substr(pos, 2) === '\\{') {
              currentSegment.text += '{';
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\}') {
              currentSegment.text += '}';
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\~') {
              currentSegment.text += "\u00A0"; // non-breaking space
              pos += 2;
              continue;
            } else if (text.substr(pos, 2) === '\\A') {
              pos += 2;
              let arg = "";
              while (pos < text.length && /[0-9\-]/.test(text[pos])) {
                arg += text[pos];
                pos++;
              }
              if (text[pos] === ';') pos++;
              currentStyle.inlineAlignment = parseInt(arg, 10) || 0;
              continue;
            } else if (text.substr(pos, 2) === '\\W') {
              pos += 2;
              let arg = "";
              while (pos < text.length && /[0-9eE\.\+\-]/.test(text[pos])) {
                arg += text[pos];
                pos++;
              }
              if (text[pos] === 'x') pos++;
              if (text[pos] === ';') pos++;
              currentStyle.widthScale = parseFloat(arg) || 1;
              continue;
            } else if (text.substr(pos, 2) === '\\T') {
              pos += 2;
              let arg = "";
              while (pos < text.length && /[0-9eE\.\+\-]/.test(text[pos])) {
                arg += text[pos];
                pos++;
              }
              if (text[pos] === ';') pos++;
              currentStyle.tracking = parseFloat(arg) || 0;
              continue;
            } else if (text.substr(pos, 2) === '\\Q') {
              pos += 2;
              let arg = "";
              while (pos < text.length && /[0-9eE\.\+\-]/.test(text[pos])) {
                arg += text[pos];
                pos++;
              }
              if (text[pos] === ';') pos++;
              currentStyle.oblique = parseFloat(arg) || 0;
              continue;
            } else if (text.substr(pos, 2) === '\\F') {
              pos += 2;
              let fontName = "";
              while (pos < text.length && text[pos] !== ';') {
                fontName += text[pos];
                pos++;
              }
              if (text[pos] === ';') pos++;
              currentStyle.font = fontName;
              continue;
            } else {
              // If the command is not recognized, output the backslash and the next char literally.
              currentSegment.text += '\\';
              pos++;
              continue;
            }
          } else {
            currentSegment.text += ch;
            pos++;
          }
        }
        if (currentSegment.text) segments.push(currentSegment);
        return { segments: segments, pos: pos };
      }

      // Handle groups such as \H (height scaling) and \F (font change) that open a nested style group.
      function parseGroup(text, pos, currentStyle) {
        if (text.substr(pos, 2) === '\\H') {
          pos += 2;
          let multiplierStr = "";
          while (pos < text.length && text[pos] !== 'x') {
            multiplierStr += text[pos];
            pos++;
          }
          let multiplier = parseFloat(multiplierStr);
          pos++; // skip the 'x'
          if (text[pos] === ';') pos++;
          let newStyle = Object.assign({}, currentStyle);
          newStyle.scale = currentStyle.scale * multiplier;
          let result = parseFormattedText(text, pos, newStyle);
          return { segments: result.segments, pos: result.pos };
        } else if (text.substr(pos, 2) === '\\F') {
          pos += 2;
          let fontName = "";
          while (pos < text.length && text[pos] !== ';') {
            fontName += text[pos];
            pos++;
          }
          if (text[pos] === ';') pos++;
          let newStyle = Object.assign({}, currentStyle);
          newStyle.font = fontName;
          let result = parseFormattedText(text, pos, newStyle);
          return { segments: result.segments, pos: result.pos };
        } else {
          return parseFormattedText(text, pos, currentStyle);
        }
      }

      // ─────────────────────────────────────────────────────────────
      // Text Measurement Helpers (for MTEXT)
      // ─────────────────────────────────────────────────────────────
      function measureSegment(segment, defaultSize, viewport) {
        let size = defaultSize * (segment.style.scale || 1);
        let font = segment.style.font || "sans-serif";
        let weight = segment.style.bold ? "bold " : "";
        let italic = segment.style.italic ? "italic " : "";
        let key = segment.text + "|" + font + "|" + weight + "|" + italic + "|" + size;
        if (!measureSegment.cache) {
          measureSegment.cache = {};
          measureSegment.ctx = document.createElement("canvas").getContext("2d");
        }
        if (measureSegment.cache[key] !== undefined) {
          return measureSegment.cache[key];
        }
        let ctx = measureSegment.ctx;
        ctx.font = italic + weight + size + "px " + font;
        let measured = ctx.measureText(segment.text).width;
        if (segment.style.tracking) {
          measured += segment.text.length > 0 ? segment.style.tracking * (segment.text.length - 1) : 0;
        }
        if (segment.style.widthScale && segment.style.widthScale !== 1) {
          measured *= segment.style.widthScale;
        }
        measureSegment.cache[key] = measured;
        return measured;
      }
      function wrapMTEXTSegments(segments, maxWidth, defaultSize, viewport) {
        let lines = [];
        let currentLine = [];
        let currentLineWidth = 0;
        segments.forEach(seg => {
          if (seg.paragraphBreak) {
            lines.push(currentLine);
            currentLine = [];
            currentLineWidth = 0;
            return;
          }
          let tokens = seg.text.split(/(\s+)/);
          tokens.forEach(token => {
            if (token === "") return;
            let tokenSegment = { text: token, style: seg.style };
            let tokenWidth = measureSegment(tokenSegment, defaultSize, viewport);
            if (currentLineWidth + tokenWidth > maxWidth && currentLine.length > 0) {
              lines.push(currentLine);
              currentLine = [];
              currentLineWidth = 0;
            }
            currentLine.push(tokenSegment);
            currentLineWidth += tokenWidth;
          });
        });
        if (currentLine.length > 0) lines.push(currentLine);
        return lines;
      }

      // ─────────────────────────────────────────────────────────────
      // DXF Style Helpers (including improved color & linetype)
      // ─────────────────────────────────────────────────────────────
      class DXFStyle {
        static ACI_COLORS = {
          0: "#000000", 1: "#FF0000", 2: "#FFFF00", 3: "#00FF00", 4: "#00FFFF",
          5: "#0000FF", 6: "#FF00FF", 7: "#FFFFFF", 8: "#808080", 9: "#C0C0C0",
          10: "#FF6600", 11: "#FF9900", 12: "#FFCC00", 13: "#CCFF00", 14: "#99FF00",
          15: "#66FF00", 16: "#33FF00", 17: "#00FF33", 18: "#00FF66", 19: "#00FF99"
        };
        static getACIColor(aci) {
          if (DXFStyle.ACI_COLORS.hasOwnProperty(aci)) {
            return DXFStyle.ACI_COLORS[aci];
          }
          return DXFStyle.ACI_COLORS[7] || "#FFFFFF";
        }
        static getEntityColor(entity, dxfDoc) {
          if (!renderSettings.renderColor) return DXFStyle.ACI_COLORS[7];
          if (entity.raw["420"]) {
            let tc = parseInt(entity.raw["420"], 10);
            let hex = tc.toString(16).padStart(6, "0");
            return "#" + hex;
          }
          let colorIndex = parseInt(entity.raw["62"]);
          if (isNaN(colorIndex)) colorIndex = 256;
          if (colorIndex === 257) colorIndex = 7;
          if (colorIndex === 0 || colorIndex === 256) {
            let layerName = entity.raw["8"];
            if (layerName && dxfDoc.layers && dxfDoc.layers[layerName] && dxfDoc.layers[layerName]["62"]) {
              colorIndex = parseInt(dxfDoc.layers[layerName]["62"]);
              if (colorIndex === 257) colorIndex = 7;
            } else {
              colorIndex = 7;
            }
          }
          return DXFStyle.getACIColor(colorIndex);
        }
        static getLineWidth(entity, viewport) {
          if (!renderSettings.renderThickness) return 1 / viewport.viewScale;
          let width;
          if (entity.raw["39"] && parseFloat(entity.raw["39"]) !== 0) {
            let thickness = parseFloat(entity.raw["39"]);
            width = Math.max(1, thickness * 3.78);
          } else if (entity.raw["370"]) {
            let lw_mm = parseInt(entity.raw["370"]) / 100;
            width = Math.max(1, lw_mm * 3.78);
          } else {
            width = 1;
          }
          return renderSettings.renderWidth ? width / viewport.viewScale : width;
        }
        static getEntityLineDash(entity, viewport, dxfDoc) {
          if (!renderSettings.renderLinetype) return [];
          let linetypeName = entity.raw["6"];
          if (!linetypeName || linetypeName.toUpperCase() === "BYLAYER") {
            let layerName = entity.raw["8"];
            if (layerName && dxfDoc.layers && dxfDoc.layers[layerName] && dxfDoc.layers[layerName]["6"]) {
              linetypeName = dxfDoc.layers[layerName]["6"];
            }
          }
          if (!linetypeName) return [];
          linetypeName = linetypeName.toUpperCase();

          // Use entity-specific linetype scale if provided, otherwise fallback to header $LTSCALE.
          let patternScale = 1.0;
          if (entity.raw["48"]) {
            patternScale = parseFloat(entity.raw["48"]) || 1.0;
          } else if (dxfDoc.header && dxfDoc.header["$LTSCALE"]) {
            patternScale = parseFloat(dxfDoc.header["$LTSCALE"]) || 1.0;
          }
          // For paper space, optionally incorporate $CELTSCALE.
          if (entity.raw["67"] && parseInt(entity.raw["67"], 10) === 1 && dxfDoc.header && dxfDoc.header["$CELTSCALE"]) {
            patternScale *= parseFloat(dxfDoc.header["$CELTSCALE"]);
          }

          if (dxfDoc.linetypes && dxfDoc.linetypes[linetypeName]) {
            let ltype = dxfDoc.linetypes[linetypeName];
            if (ltype.pattern && ltype.pattern.length > 0) {
              const dashArray = ltype.pattern.map(d => {
                const absValue = Math.abs(d);
                const dashLength = (absValue === 0 ? 0.5 : absValue);
                return dashLength * patternScale;
              });
              return dashArray;
            }
          }
          return [];
        }
      }

      // ─────────────────────────────────────────────────────────────
      // Base DXF Entity Class
      // ─────────────────────────────────────────────────────────────
      class DXFEntity {
        constructor(type) {
          this.type = type;
          this.raw = {};
        }
        getColor(dxfDoc) {
          return DXFStyle.getEntityColor(this, dxfDoc);
        }
        getLineWidth(viewport) {
          return DXFStyle.getLineWidth(this, viewport);
        }
        getLineDash(viewport, dxfDoc) {
          return DXFStyle.getEntityLineDash(this, viewport, dxfDoc);
        }
        applyStyle(ctx, viewport, dxfDoc) {
          ctx.setLineDash([]);
          ctx.lineWidth = this.getLineWidth(viewport);
          let color = this.getColor(dxfDoc);
          ctx.strokeStyle = color;
          ctx.fillStyle = color;
          let dash = this.getLineDash(viewport, dxfDoc);
          if (dash && dash.length > 0) ctx.setLineDash(dash);
          if (renderSettings.renderTransparency && this.raw["440"] !== undefined) {
            let transpValue = parseInt(this.raw["440"], 10);
            ctx.globalAlpha = 1 - (transpValue / 255);
          } else {
            ctx.globalAlpha = 1;
          }
        }
      }

      // ─────────────────────────────────────────────────────────────
      // DXF Entity Classes (LINE, CIRCLE, ARC, etc.)
      // ─────────────────────────────────────────────────────────────
      class DXFLine extends DXFEntity {
        constructor() {
          super("LINE");
          this.x1 = 0; this.y1 = 0;
          this.x2 = 0; this.y2 = 0;
        }
        static parse(lines, i) {
          let line = new DXFLine();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": line.x1 = parseFloat(value); break;
              case "20": line.y1 = parseFloat(value); break;
              case "11": line.x2 = parseFloat(value); break;
              case "21": line.y2 = parseFloat(value); break;
              default: line.raw[code] = value; break;
            }
            i += 2;
          }
          return { entity: line, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["LINE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.moveTo(this.x1, this.y1);
          ctx.lineTo(this.x2, this.y2);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFCircle extends DXFEntity {
        constructor() {
          super("CIRCLE");
          this.cx = 0; this.cy = 0; this.r = 0;
        }
        static parse(lines, i) {
          let circle = new DXFCircle();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": circle.cx = parseFloat(value); break;
              case "20": circle.cy = parseFloat(value); break;
              case "40": circle.r = parseFloat(value); break;
              default: circle.raw[code] = value; break;
            }
            i += 2;
          }
          return { entity: circle, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["CIRCLE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.arc(this.cx, this.cy, this.r, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFArc extends DXFEntity {
        constructor() {
          super("ARC");
          this.cx = 0; this.cy = 0; this.r = 0;
          this.startAngle = 0; this.endAngle = 0;
        }
        static parse(lines, i) {
          let arc = new DXFArc();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": arc.cx = parseFloat(value); break;
              case "20": arc.cy = parseFloat(value); break;
              case "40": arc.r = parseFloat(value); break;
              case "50": arc.startAngle = parseFloat(value); break;
              case "51": arc.endAngle = parseFloat(value); break;
              default: arc.raw[code] = value; break;
            }
            i += 2;
          }
          return { entity: arc, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["ARC"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let startRad = DXFUtils.degToRad(this.startAngle);
          let endRad = DXFUtils.degToRad(this.endAngle);
          if (endRad < startRad) endRad += 2 * Math.PI;
          ctx.beginPath();
          ctx.arc(this.cx, this.cy, this.r, startRad, endRad);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFPolyline extends DXFEntity {
        constructor() {
          super("POLYLINE");
          this.vertices = [];
          this.closed = false;
        }
        static parse(lines, i) {
          let polyline = new DXFPolyline();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0" && (lines[i + 1] || "").trim() === "VERTEX") break;
            if (code === "0" && (lines[i + 1] || "").trim() === "SEQEND") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "70") {
              let flag = parseInt(value);
              polyline.closed = (flag & 1) !== 0;
            } else {
              polyline.raw[code] = value;
            }
            i += 2;
          }
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "SEQEND") {
              i += 2;
              break;
            }
            if (code === "0" && value === "VERTEX") {
              i += 2;
              let vx = 0, vy = 0;
              while (i < lines.length) {
                let vCode = lines[i].trim();
                if (vCode === "0") break;
                let vValue = (lines[i + 1] || "").trim();
                if (vCode === "10") vx = parseFloat(vValue);
                else if (vCode === "20") vy = parseFloat(vValue);
                i += 2;
              }
              polyline.vertices.push({ x: vx, y: vy });
            } else {
              i += 2;
            }
          }
          return { entity: polyline, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["POLYLINE"]) return;
          if (this.vertices.length === 0) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
          for (let j = 1; j < this.vertices.length; j++) {
            ctx.lineTo(this.vertices[j].x, this.vertices[j].y);
          }
          if (this.closed) ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFLwPolyline extends DXFEntity {
        constructor() {
          super("LWPOLYLINE");
          this.vertices = [];
          this.closed = false;
          this.elevation = 0; // optional elevation for all vertices
        }
        static parse(lines, i) {
          let lwpoly = new DXFLwPolyline();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "70":
                // Bit 1 (value 1) indicates a closed polyline.
                lwpoly.closed = (parseInt(value, 10) & 1) !== 0;
                break;
              case "38":
                // Optional elevation (all vertices lie in a plane with this elevation)
                lwpoly.elevation = parseFloat(value);
                break;
              case "10": {
                // Parse a vertex
                let x = parseFloat(value);
                i += 2;
                let y = 0;
                if (i < lines.length && lines[i].trim() === "20") {
                  y = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                }
                // Optional: constant width at this vertex (start width, group 40; end width, group 41)
                let widthStart = null, widthEnd = null;
                if (i < lines.length && lines[i].trim() === "40") {
                  widthStart = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                }
                if (i < lines.length && lines[i].trim() === "41") {
                  widthEnd = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                }
                // Group code 42 is for bulge (arc definition)
                let bulge = 0;
                if (i < lines.length && lines[i].trim() === "42") {
                  bulge = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                }
                lwpoly.vertices.push({ x, y, bulge, widthStart, widthEnd });
                continue; // already advanced i inside the block
              }
              default:
                lwpoly.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: lwpoly, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["LWPOLYLINE"]) return;
          if (this.vertices.length === 0) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          const n = this.vertices.length;
          // Determine the iteration count: for closed polylines, loop over all vertices;
          // for open ones, draw from vertex 0 to vertex n-1.
          const count = this.closed ? n : n - 1;
          // Move to first vertex
          ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
          for (let j = 0; j < count; j++) {
            let curr = this.vertices[j];
            // For closed polylines use modulo; for open, next vertex is j+1
            let next = this.vertices[this.closed ? (j + 1) % n : j + 1];
            if (Math.abs(curr.bulge) > 1e-9) {
              // Bulge is defined as tan(angle/4); so the sweep angle is:
              let a = 4 * Math.atan(curr.bulge); // (a is signed)
              // Compute the chord length between the current and next vertices:
              let chord = getDistance(curr, next);
              // Avoid division by zero for extremely small arcs
              if (Math.abs(Math.sin(Math.abs(a) / 2)) < 1e-9) {
                ctx.lineTo(next.x, next.y);
                continue;
              }
              // Radius of the arc: r = chord / (2*sin(|a|/2))
              let r = chord / (2 * Math.sin(Math.abs(a) / 2));
              // Distance from chord midpoint to arc center:
              let h = r * Math.cos(Math.abs(a) / 2);
              // Chord midpoint:
              let mx = (curr.x + next.x) / 2;
              let my = (curr.y + next.y) / 2;
              // Chord direction unit vector:
              let dx = next.x - curr.x, dy = next.y - curr.y;
              let len = Math.sqrt(dx * dx + dy * dy);
              let ux = dx / len, uy = dy / len;
              // Determine the perpendicular vector.
              // For a positive bulge, the arc is drawn to the left of the chord (relative to its direction).
              let perp = curr.bulge > 0 ? { x: -uy, y: ux } : { x: uy, y: -ux };
              // Compute the arc center:
              let cx = mx + perp.x * h;
              let cy = my + perp.y * h;
              // Start angle: angle from center to current vertex.
              let startAngle = Math.atan2(curr.y - cy, curr.x - cx);
              // End angle: add the sweep angle a.
              let endAngle = startAngle + a;
              // In canvas arc, the anticlockwise flag is set to true when a is negative.
              let anticlockwise = a < 0;
              ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
            } else {
              // Straight segment
              ctx.lineTo(next.x, next.y);
            }
          }
          if (this.closed) ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // ─────────────────────────────────────────────────────────────
      // HATCH ENTITY
      // ─────────────────────────────────────────────────────────────
      function sampleArc(center, radius, startAngle, endAngle, numSegments = 20) {
        let points = [];
        for (let i = 0; i <= numSegments; i++) {
          let t = startAngle + (endAngle - startAngle) * (i / numSegments);
          points.push({ x: center.x + radius * Math.cos(t), y: center.y + radius * Math.sin(t) });
        }
        return points;
      }
      function sampleEllipse(center, major, minor, rotation, startParam, endParam, numSegments = 20) {
        let points = [];
        if (endParam < startParam) endParam += 2 * Math.PI;
        for (let i = 0; i <= numSegments; i++) {
          let t = startParam + (endParam - startParam) * (i / numSegments);
          let x = center.x + major * Math.cos(t) * Math.cos(rotation) - minor * Math.sin(t) * Math.sin(rotation);
          let y = center.y + major * Math.cos(t) * Math.sin(rotation) + minor * Math.sin(t) * Math.cos(rotation);
          points.push({ x, y });
        }
        return points;
      }
      class DXFHatch extends DXFEntity {
        constructor() {
          super("HATCH");
          this.boundaryLoops = [];
          this.isSolid = false;
          this.patternName = "";
          this.patternAngle = 0;
          this.patternScale = 1;
          this.patternOffset = { x: 0, y: 0 };
        }
        static parse(lines, i) {
          let hatch = new DXFHatch();
          i += 2;
          let boundaryLoopCount = 0;
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0") break;
            if (code === "70") {
              hatch.isSolid = (parseInt(value, 10) & 1) !== 0;
            } else if (code === "2") {
              hatch.patternName = value.toUpperCase();
            } else if (code === "91") {
              boundaryLoopCount = parseInt(value, 10);
            } else if (code === "92") {
              let edgeCount = parseInt(value, 10);
              i += 2;
              let loopPoints = [];
              for (let j = 0; j < edgeCount; j++) {
                let edgeType = 1;
                if (lines[i] && lines[i].trim() === "72") {
                  edgeType = parseInt(lines[i + 1].trim(), 10);
                  i += 2;
                }
                let edgePoints = [];
                if (edgeType === 1) {
                  let start = {}, end = {};
                  while (i < lines.length) {
                    let c = lines[i].trim();
                    let v = (lines[i + 1] || "").trim();
                    if (c === "10") { start.x = parseFloat(v); }
                    else if (c === "20") { start.y = parseFloat(v); }
                    else if (c === "11") { end.x = parseFloat(v); }
                    else if (c === "21") { end.y = parseFloat(v); }
                    else break;
                    i += 2;
                  }
                  if (start.x !== undefined && start.y !== undefined && end.x !== undefined && end.y !== undefined) {
                    edgePoints = [start, end];
                  }
                } else if (edgeType === 2) {
                  let center = {}, radius = 0, startAngle = 0, endAngle = 0;
                  while (i < lines.length) {
                    let c = lines[i].trim();
                    let v = (lines[i + 1] || "").trim();
                    if (c === "10") { center.x = parseFloat(v); }
                    else if (c === "20") { center.y = parseFloat(v); }
                    else if (c === "40") { radius = parseFloat(v); }
                    else if (c === "50") { startAngle = DXFUtils.degToRad(parseFloat(v)); }
                    else if (c === "51") { endAngle = DXFUtils.degToRad(parseFloat(v)); }
                    else break;
                    i += 2;
                  }
                  if (endAngle < startAngle) endAngle += 2 * Math.PI;
                  edgePoints = sampleArc(center, radius, startAngle, endAngle);
                } else if (edgeType === 3) {
                  let center = {}, majorVec = {}, ratio = 1, startParam = 0, endParam = 0;
                  while (i < lines.length) {
                    let c = lines[i].trim();
                    let v = (lines[i + 1] || "").trim();
                    if (c === "10") { center.x = parseFloat(v); }
                    else if (c === "20") { center.y = parseFloat(v); }
                    else if (c === "11") { majorVec.x = parseFloat(v); }
                    else if (c === "21") { majorVec.y = parseFloat(v); }
                    else if (c === "40") { ratio = parseFloat(v); }
                    else if (c === "50") { startParam = parseFloat(v); }
                    else if (c === "51") { endParam = parseFloat(v); }
                    else break;
                    i += 2;
                  }
                  let majorLength = Math.sqrt((majorVec.x || 0) ** 2 + (majorVec.y || 0) ** 2);
                  let minorLength = majorLength * ratio;
                  let rotation = Math.atan2(majorVec.y || 0, majorVec.x || 0);
                  edgePoints = sampleEllipse(center, majorLength, minorLength, rotation, startParam, endParam);
                } else if (edgeType === 4) {
                  let splinePoints = [];
                  while (i < lines.length) {
                    let c = lines[i].trim();
                    if (["0", "92", "93"].includes(c)) break;
                    if (c === "10") {
                      let pt = { x: parseFloat(lines[i + 1].trim()) };
                      i += 2;
                      if (i < lines.length && lines[i].trim() === "20") {
                        pt.y = parseFloat(lines[i + 1].trim());
                        i += 2;
                      } else {
                        pt.y = 0;
                        i -= 2;
                      }
                      splinePoints.push(pt);
                    } else {
                      i += 2;
                    }
                  }
                  edgePoints = splinePoints;
                } else {
                  while (i < lines.length) {
                    let c = lines[i].trim();
                    if (c === "0" || c === "92" || c === "93") break;
                    i += 2;
                  }
                }
                if (loopPoints.length > 0 && edgePoints.length > 0) {
                  let last = loopPoints[loopPoints.length - 1];
                  let first = edgePoints[0];
                  if (Math.abs(last.x - first.x) < 1e-6 && Math.abs(last.y - first.y) < 1e-6) {
                    edgePoints.shift();
                  }
                }
                loopPoints.push(...edgePoints);
              }
              hatch.boundaryLoops.push(loopPoints);
              continue;
            } else {
              hatch.raw[code] = value;
            }
            i += 2;
          }
          if (hatch.raw["52"]) {
            hatch.patternAngle = parseFloat(hatch.raw["52"]);
          }
          if (hatch.raw["41"]) {
            hatch.patternScale = parseFloat(hatch.raw["41"]);
          }
          return { entity: hatch, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["HATCH"]) return;
          if (this.boundaryLoops.length === 0) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let fillColor = this.getColor(dxfDoc);
          ctx.save();
          this.drawLoopsPath(ctx);
          if (this.isSolid || (this.patternName && this.patternName.toUpperCase().includes("SOLID"))) {
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = fillColor;
            ctx.lineWidth = 1 / viewport.viewScale;
            ctx.stroke();
          } else {
            ctx.clip();
            let bbox = computeBBox(this.boundaryLoops);
            let patternAngleRad = DXFUtils.degToRad(this.patternAngle);
            let spacing = (this.patternScale || 1) * 10;
            ctx.save();
            let origin = { x: bbox.minX, y: bbox.minY };
            ctx.translate(origin.x, origin.y);
            ctx.rotate(patternAngleRad);
            let pts = [
              { x: bbox.minX - origin.x, y: bbox.minY - origin.y },
              { x: bbox.maxX - origin.x, y: bbox.minY - origin.y },
              { x: bbox.maxX - origin.x, y: bbox.maxY - origin.y },
              { x: bbox.minX - origin.x, y: bbox.maxY - origin.y }
            ];
            let tMinX = Math.min(...pts.map(p => p.x));
            let tMaxX = Math.max(...pts.map(p => p.x));
            let tMinY = Math.min(...pts.map(p => p.y));
            let tMaxY = Math.max(...pts.map(p => p.y));
            tMinY -= spacing;
            tMaxY += spacing;
            ctx.beginPath();
            for (let y = tMinY; y <= tMaxY; y += spacing) {
              ctx.moveTo(tMinX, y);
              ctx.lineTo(tMaxX, y);
            }
            ctx.strokeStyle = fillColor;
            ctx.lineWidth = 1 / viewport.viewScale;
            ctx.stroke();
            ctx.restore();
          }
          ctx.restore();
          ctx.globalAlpha = 1;
        }
        drawLoopsPath(ctx) {
          ctx.beginPath();
          this.boundaryLoops.forEach(loop => {
            if (loop.length > 0) {
              ctx.moveTo(loop[0].x, loop[0].y);
              for (let i = 1; i < loop.length; i++) {
                ctx.lineTo(loop[i].x, loop[i].y);
              }
              ctx.closePath();
            }
          });
        }
      }

      class DXFDimension extends DXFEntity {
        constructor() {
          super("DIMENSION");
          this.p1 = { x: 0, y: 0 };
          this.p2 = { x: 0, y: 0 };
          this.defPt = null;
          this.text = "";
        }
        static parse(lines, i) {
          let dim = new DXFDimension();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": dim.p1.x = parseFloat(value); break;
              case "20": dim.p1.y = parseFloat(value); break;
              case "11": dim.p2.x = parseFloat(value); break;
              case "21": dim.p2.y = parseFloat(value); break;
              case "13":
              case "23":
                if (!dim.defPt) dim.defPt = { x: 0, y: 0 };
                if (code === "13") dim.defPt.x = parseFloat(value);
                else dim.defPt.y = parseFloat(value);
                break;
              case "1":
                dim.text = value;
                break;
              default:
                dim.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: dim, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["DIMENSION"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);

          // Use $DIMSCALE only for text measurement; do not alter drawing points.
          let dimScale = (dxfDoc.header && dxfDoc.header["$DIMSCALE"])
            ? parseFloat(dxfDoc.header["$DIMSCALE"]) : 1;

          let p1 = this.p1, p2 = this.p2;
          let dx = p2.x - p1.x;
          let dy = p2.y - p1.y;
          let baselineLength = Math.sqrt(dx * dx + dy * dy);
          if (baselineLength < 1e-9) {
            ctx.globalAlpha = 1;
            return;
          }

          // Unit vector along baseline and its perpendicular (pointing to the left)
          let u = { x: dx / baselineLength, y: dy / baselineLength };
          let v = { x: -u.y, y: u.x };

          let mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
          // Default offset if no definition point is provided
          let offsetDistance = 5;
          if (this.defPt) {
            // Project the difference (defPt - mid) onto v (no extra inversion)
            offsetDistance = (this.defPt.x - mid.x) * v.x + (this.defPt.y - mid.y) * v.y;
          }

          // Compute the offset (dimension) line endpoints
          let p1_dim = { x: p1.x + v.x * offsetDistance, y: p1.y + v.y * offsetDistance };
          let p2_dim = { x: p2.x + v.x * offsetDistance, y: p2.y + v.y * offsetDistance };

          // Draw extension lines and the dimension line itself
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p1_dim.x, p1_dim.y);
          ctx.moveTo(p2.x, p2.y);
          ctx.lineTo(p2_dim.x, p2_dim.y);
          ctx.moveTo(p1_dim.x, p1_dim.y);
          ctx.lineTo(p2_dim.x, p2_dim.y);
          ctx.stroke();

          // Draw arrow heads at both ends
          function drawArrow(pt, direction) {
            const arrowSize = 3;
            const arrowAngle = Math.PI / 6;
            let baseAngle = Math.atan2(direction.y, direction.x);
            let left = {
              x: pt.x - arrowSize * Math.cos(baseAngle + arrowAngle),
              y: pt.y - arrowSize * Math.sin(baseAngle + arrowAngle)
            };
            let right = {
              x: pt.x - arrowSize * Math.cos(baseAngle - arrowAngle),
              y: pt.y - arrowSize * Math.sin(baseAngle - arrowAngle)
            };
            ctx.beginPath();
            ctx.moveTo(pt.x, pt.y);
            ctx.lineTo(left.x, left.y);
            ctx.lineTo(right.x, right.y);
            ctx.closePath();
            ctx.fill();
          }
          let arrowDir = { x: p2_dim.x - p1_dim.x, y: p2_dim.y - p1_dim.y };
          let arrowLen = Math.sqrt(arrowDir.x * arrowDir.x + arrowDir.y * arrowDir.y);
          if (arrowLen > 1e-9) {
            arrowDir.x /= arrowLen;
            arrowDir.y /= arrowLen;
            drawArrow(p1_dim, arrowDir);
            drawArrow(p2_dim, { x: -arrowDir.x, y: -arrowDir.y });
          }

          // Determine dimension text: if text is empty or "<>", use the scaled baseline length.
          let dimText = this.text.trim();
          if (!dimText || dimText === "<>") {
            dimText = (baselineLength * dimScale).toFixed(2);
          }
          let dimLineMid = { x: (p1_dim.x + p2_dim.x) / 2, y: (p1_dim.y + p2_dim.y) / 2 };

          // Compute the text rotation based on the offset dimension line
          let textAngle = Math.atan2(p2_dim.y - p1_dim.y, p2_dim.x - p1_dim.x);
          // Ensure text remains upright
          if (textAngle > Math.PI / 2) textAngle -= Math.PI;
          if (textAngle < -Math.PI / 2) textAngle += Math.PI;

          let defaultTextHeight = (dxfDoc.header && dxfDoc.header["$DIMTXT"])
            ? parseFloat(dxfDoc.header["$DIMTXT"]) : 12;
          ctx.save();
          ctx.translate(dimLineMid.x, dimLineMid.y);
          ctx.rotate(textAngle);
          ctx.font = defaultTextHeight + "px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(dimText, 0, 0);
          ctx.restore();

          ctx.globalAlpha = 1;
        }
      }

      class DXFMTEXT extends DXFEntity {
        constructor() {
          super("MTEXT");
          this.position = { x: 0, y: 0 };
          this.height = 12;
          this.rotation = 0;
          this.rawText = "";
          this.font = "sans-serif";
          this.maxWidth = 0;
          this.align = 1;
        }
        static parse(lines, i) {
          let mtext = new DXFMTEXT();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": mtext.position.x = parseFloat(value); break;
              case "20": mtext.position.y = parseFloat(value); break;
              case "40": mtext.height = parseFloat(value); break;
              case "50": mtext.rotation = parseFloat(value); break;
              case "1":
                // First chunk of text replaces previous text.
                mtext.rawText = value;
                break;
              case "3":
                // Continuation lines: add a newline before appending.
                mtext.rawText += "\n" + value;
                break;
              case "7": mtext.font = value; break;
              case "41": mtext.maxWidth = parseFloat(value); break;
              case "71": mtext.align = parseInt(value); break;
              default:
                mtext.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: mtext, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["MTEXT"]) return;
          let { x, y } = this.position;
          let defaultSize = this.height;
          let rotation = this.rotation ? DXFUtils.degToRad(this.rotation) : 0;
          let rawText = this.rawText || "";
          let defaultFont = this.font || "sans-serif";
          let defaultColor = this.getColor(dxfDoc);
          this.applyStyle(ctx, viewport, dxfDoc);
          let parsedSegments = parseMTEXTContent(rawText, defaultSize, defaultFont, defaultColor);
          let paragraphs = [], currentParagraph = [];
          parsedSegments.forEach(seg => {
            if (seg.paragraphBreak) {
              paragraphs.push(currentParagraph);
              currentParagraph = [];
            } else {
              currentParagraph.push(seg);
            }
          });
          if (currentParagraph.length > 0) paragraphs.push(currentParagraph);
          let maxWidthWorld = this.maxWidth || 0;
          let wrappedLines = [];
          if (maxWidthWorld > 0) {
            paragraphs.forEach(para => {
              let lines = wrapMTEXTSegments(para, maxWidthWorld, defaultSize, viewport);
              wrappedLines.push(...lines);
            });
          } else {
            wrappedLines = paragraphs;
          }
          let align = this.align || 1;
          let hAlign = align % 3; 
          if (hAlign === 0) hAlign = 3; 
          let vAlign = Math.floor((align - 1) / 3);
          let lineHeight = defaultSize * 1.2;
          let totalHeight = wrappedLines.length * lineHeight;
          let lineWidths = [];
          let maxLineWidth = 0;
          wrappedLines.forEach(line => {
            let width = line.reduce((sum, seg) => sum + measureSegment(seg, defaultSize, viewport), 0);
            lineWidths.push(width);
            if (width > maxLineWidth) maxLineWidth = width;
          });
          let offsetY = 0;
          if (vAlign === 1) offsetY = -totalHeight / 2;
          else if (vAlign === 2) offsetY = -totalHeight;
          ctx.save();
          ctx.translate(x, y);
          // Apply an extra vertical scale to cancel the global flip:
          ctx.scale(1, -1);
          // Use positive rotation since the flip is undone
          ctx.rotate(rotation);
          ctx.translate(0, -offsetY);
          for (let i = 0; i < wrappedLines.length; i++) {
            let line = wrappedLines[i];
            let lw = lineWidths[i];
            let offsetX = 0;
            if (hAlign === 2) offsetX = (maxLineWidth - lw) / 2;
            else if (hAlign === 3) offsetX = (maxLineWidth - lw);
            ctx.save();
            ctx.translate(offsetX, i * lineHeight);
            let xPos = 0;
            line.forEach(seg => {
              ctx.save();
              let segSize = defaultSize * (seg.style.scale || 1);
              let segFont = seg.style.font || defaultFont;
              let segWeight = seg.style.bold ? "bold " : "";
              let segItalic = seg.style.italic ? "italic " : "";
              ctx.font = segItalic + segWeight + segSize + "px " + segFont;
              ctx.fillStyle = seg.style.color || defaultColor;
              ctx.textBaseline = "alphabetic";
              let tracking = seg.style.tracking || 0;
              let widthScale = seg.style.widthScale || 1;
              let oblique = seg.style.oblique || 0;
              if (oblique !== 0) {
                let tanOblique = Math.tan(oblique * Math.PI / 180);
                ctx.transform(1, 0, tanOblique, 1, 0, 0);
              }
              let measuredWidth = measureSegment(seg, defaultSize, viewport);
              if (tracking === 0 && widthScale === 1 && oblique === 0) {
                ctx.fillText(seg.text, xPos, 0);
                xPos += measuredWidth;
              } else {
                for (let j = 0; j < seg.text.length; j++) {
                  let ch = seg.text[j];
                  ctx.fillText(ch, xPos, 0);
                  let charWidth = ctx.measureText(ch).width;
                  xPos += (charWidth + tracking) * widthScale;
                }
              }
              if (seg.style.underline) {
                let metrics = ctx.measureText(seg.text);
                let underlineY = (metrics.actualBoundingBoxDescent !== undefined)
                  ? metrics.actualBoundingBoxDescent + 2 : segSize * 0.3;
                ctx.beginPath();
                ctx.moveTo(xPos - measuredWidth, underlineY);
                ctx.lineTo(xPos, underlineY);
                ctx.lineWidth = Math.max(1, segSize / 15);
                ctx.strokeStyle = ctx.fillStyle;
                ctx.stroke();
              }
              if (seg.style.overline) {
                let metrics = ctx.measureText(seg.text);
                let overlineY = -(metrics.actualBoundingBoxAscent !== undefined
                  ? metrics.actualBoundingBoxAscent : segSize * 0.3);
                ctx.beginPath();
                ctx.moveTo(xPos - measuredWidth, overlineY);
                ctx.lineTo(xPos, overlineY);
                ctx.lineWidth = Math.max(1, segSize / 15);
                ctx.strokeStyle = ctx.fillStyle;
                ctx.stroke();
              }
              ctx.restore();
            });
            ctx.restore();
          }
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      }

      class DXFSpline extends DXFEntity {
        constructor() {
          super("SPLINE");
          this.degree = null;
          this.knots = [];
          this.controlPoints = [];
          this.fitPoints = [];
        }
        static parse(lines, i) {
          let spline = new DXFSpline();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "70": spline.raw["70"] = value; break;
              case "71": spline.degree = parseInt(value, 10); break;
              case "72": spline.raw["72"] = value; break;
              case "73": spline.raw["73"] = value; break;
              case "74": spline.raw["74"] = value; break;
              case "40":
                spline.knots.push(parseFloat(value));
                break;
              case "10": {
                let pt = { x: parseFloat(value) };
                i += 2;
                if (i < lines.length && lines[i].trim() === "20") {
                  pt.y = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                } else {
                  pt.y = 0;
                  i -= 2;
                }
                spline.controlPoints.push(pt);
                continue;
              }
              case "11": {
                let pt = { x: parseFloat(value) };
                i += 2;
                if (i < lines.length && lines[i].trim() === "21") {
                  pt.y = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                } else {
                  pt.y = 0;
                  i -= 2;
                }
                spline.fitPoints.push(pt);
                continue;
              }
              default:
                spline.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: spline, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["SPLINE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let samplePoints = [];
          if (this.controlPoints.length >= (this.degree + 1) && this.knots.length > 0 && this.degree != null) {
            let k = this.degree;
            let cp = this.controlPoints;
            let knots = this.knots;
            let t_min = knots[k];
            let t_max = knots[knots.length - k - 1];
            let numSamples = 50;
            for (let i = 0; i <= numSamples; i++) {
              let t = t_min + (t_max - t_min) * (i / numSamples);
              let pt = deBoor(k, cp, knots, t);
              samplePoints.push(pt);
            }
          } else if (this.fitPoints && this.fitPoints.length >= 2) {
            samplePoints = this.fitPoints;
          } else {
            return;
          }
          ctx.beginPath();
          ctx.moveTo(samplePoints[0].x, samplePoints[0].y);
          for (let i = 1; i < samplePoints.length; i++) {
            ctx.lineTo(samplePoints[i].x, samplePoints[i].y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }
      function deBoor(k, cp, knots, t) {
        let n = cp.length - 1;
        let i = k;
        for (; i <= n; i++) {
          if (t < knots[i + 1]) break;
        }
        if (i > n) i = n;
        let d = [];
        for (let j = 0; j <= k; j++) {
          d[j] = { x: cp[i - k + j].x, y: cp[i - k + j].y };
        }
        for (let r = 1; r <= k; r++) {
          for (let j = k; j >= r; j--) {
            let idx = i - k + j;
            let denom = knots[idx + k - r + 1] - knots[idx];
            let alpha = (denom === 0) ? 0 : (t - knots[idx]) / denom;
            d[j].x = (1 - alpha) * d[j - 1].x + alpha * d[j].x;
            d[j].y = (1 - alpha) * d[j - 1].y + alpha * d[j].y;
          }
        }
        return d[k];
      }

      class DXFInsert extends DXFEntity {
        constructor() {
          super("INSERT");
          this.blockName = "";
          this.insertionPoint = { x: 0, y: 0 };
          this.scale = { x: 1, y: 1 };
          this.rotation = 0;
          this.attribs = [];
        }
        static parse(lines, i) {
          let insert = new DXFInsert();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "2":
                insert.blockName = value;
                break;
              case "10":
                insert.insertionPoint.x = parseFloat(value);
                break;
              case "20":
                insert.insertionPoint.y = parseFloat(value);
                break;
              case "41":
                insert.scale.x = parseFloat(value);
                break;
              case "42":
                insert.scale.y = parseFloat(value);
                break;
              case "50":
                insert.rotation = parseFloat(value);
                break;
              case "67":
                insert.spaceFlag = parseInt(value, 10);
                break;
              default:
                insert.raw[code] = value;
                break;
            }
            i += 2;
          }
          if (insert.scale.x !== 1 && insert.scale.y === 1) {
            insert.scale.y = insert.scale.x;
          }
          return { entity: insert, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["INSERT"]) return;
          let block = dxfDoc.blocks[this.blockName];
          if (!block) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.save();

          // Adjust insertion point using $INSBASE if available.
          let insBase = { x: 0, y: 0 };
          if (dxfDoc.header && dxfDoc.header["$INSBASE"]) {
            insBase = dxfDoc.header["$INSBASE"];
          }
          let adjustedInsertionPoint = {
            x: this.insertionPoint.x - insBase.x,
            y: this.insertionPoint.y - insBase.y
          };

          let { x: scaleX, y: scaleY } = this.scale;
          let angle = DXFUtils.degToRad(this.rotation);
          let bp = block.basePoint || { x: 0, y: 0 };
          ctx.translate(adjustedInsertionPoint.x, adjustedInsertionPoint.y);
          ctx.rotate(angle);
          ctx.scale(scaleX, scaleY);
          ctx.translate(-bp.x, -bp.y);

          block.entities.forEach(e => {
            if (renderSettings.entity[e.type] !== false) {
              e.draw(ctx, viewport, dxfDoc);
            }
          });
          this.attribs.forEach(attr => {
            if (renderSettings.entity[attr.type] !== false) {
              attr.draw(ctx, viewport, dxfDoc);
            }
          });
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      }

      class DXFText extends DXFEntity {
        constructor(type) {
          super(type);
          this.position = { x: 0, y: 0 };
          this.height = 12;
          this.rotation = 0;
          this.text = "";
          this.font = "sans-serif";
        }
        static parse(lines, i) {
          let textEntity = new DXFText((lines[i + 1] || "").trim());
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": textEntity.position.x = parseFloat(value); break;
              case "20": textEntity.position.y = parseFloat(value); break;
              case "40": textEntity.height = parseFloat(value); break;
              case "50": textEntity.rotation = parseFloat(value); break;
              case "1":
              case "3":
                textEntity.text += value;
                break;
              case "7": textEntity.font = value; break;
              default:
                textEntity.raw[code] = value;
                break;
            }
            i += 2;
          }
          return { entity: textEntity, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity[this.type]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let x = this.position.x, y = this.position.y;
          let height = this.height;
          let rotation = this.rotation ? DXFUtils.degToRad(this.rotation) : 0;
          let text = this.text;
          let defaultSize = this.height;
          let defaultFont = this.font || "sans-serif";
          let defaultColor = this.getColor(dxfDoc);
          let rawText = this.text || "";
          let parsedSegments = parseMTEXTContent(rawText, defaultSize, defaultFont, defaultColor);
          let paragraphs = [], currentParagraph = [];
          parsedSegments.forEach(seg => {
            if (seg.paragraphBreak) {
              paragraphs.push(currentParagraph);
              currentParagraph = [];
            } else {
              currentParagraph.push(seg);
            }
          });
          if (currentParagraph.length > 0) paragraphs.push(currentParagraph);
          let maxWidthWorld = this.maxWidth || 0;
          let wrappedLines = [];
          if (maxWidthWorld > 0) {
            paragraphs.forEach(para => {
              let lines = wrapMTEXTSegments(para, maxWidthWorld, defaultSize, viewport);
              wrappedLines.push(...lines);
            });
          } else {
            wrappedLines = paragraphs;
          }
          let align = this.align || 1;
          let hAlign = align % 3; 
          if (hAlign === 0) hAlign = 3; 
          let vAlign = Math.floor((align - 1) / 3);
          let lineHeight = defaultSize * 1.2;
          let totalHeight = wrappedLines.length * lineHeight;
          let lineWidths = [];
          let maxLineWidth = 0;
          wrappedLines.forEach(line => {
            let width = line.reduce((sum, seg) => sum + measureSegment(seg, defaultSize, viewport), 0);
            lineWidths.push(width);
            if (width > maxLineWidth) maxLineWidth = width;
          });
          let offsetY = 0;
          if (vAlign === 1) offsetY = -totalHeight / 2;
          else if (vAlign === 2) offsetY = -totalHeight;
          ctx.save();
          ctx.translate(x, y);
          ctx.scale(1, -1);
          ctx.rotate(rotation);
          ctx.translate(0, -offsetY);
          for (let i = 0; i < wrappedLines.length; i++) {
            let line = wrappedLines[i];
            let lw = lineWidths[i];
            let offsetX = 0;
            if (hAlign === 2) offsetX = (maxLineWidth - lw) / 2;
            else if (hAlign === 3) offsetX = (maxLineWidth - lw);
            ctx.save();
            ctx.translate(offsetX, i * lineHeight);
            let xPos = 0;
            line.forEach(seg => {
              ctx.save();
              let segSize = defaultSize * (seg.style.scale || 1);
              let segFont = seg.style.font || defaultFont;
              let segWeight = seg.style.bold ? "bold " : "";
              let segItalic = seg.style.italic ? "italic " : "";
              ctx.font = segItalic + segWeight + segSize + "px " + segFont;
              ctx.fillStyle = seg.style.color || defaultColor;
              ctx.textBaseline = "alphabetic";
              let tracking = seg.style.tracking || 0;
              let widthScale = seg.style.widthScale || 1;
              let oblique = seg.style.oblique || 0;
              if (oblique !== 0) {
                let tanOblique = Math.tan(oblique * Math.PI / 180);
                ctx.transform(1, 0, tanOblique, 1, 0, 0);
              }
              let measuredWidth = measureSegment(seg, defaultSize, viewport);
              if (tracking === 0 && widthScale === 1 && oblique === 0) {
                ctx.fillText(seg.text, xPos, 0);
                xPos += measuredWidth;
              } else {
                for (let j = 0; j < seg.text.length; j++) {
                  let ch = seg.text[j];
                  ctx.fillText(ch, xPos, 0);
                  let charWidth = ctx.measureText(ch).width;
                  xPos += (charWidth + tracking) * widthScale;
                }
              }
              if (seg.style.underline) {
                let metrics = ctx.measureText(seg.text);
                let underlineY = (metrics.actualBoundingBoxDescent !== undefined)
                  ? metrics.actualBoundingBoxDescent + 2 : segSize * 0.3;
                ctx.beginPath();
                ctx.moveTo(xPos - measuredWidth, underlineY);
                ctx.lineTo(xPos, underlineY);
                ctx.lineWidth = Math.max(1, segSize / 15);
                ctx.strokeStyle = ctx.fillStyle;
                ctx.stroke();
              }
              if (seg.style.overline) {
                let metrics = ctx.measureText(seg.text);
                let overlineY = -(metrics.actualBoundingBoxAscent !== undefined
                  ? metrics.actualBoundingBoxAscent : segSize * 0.3);
                ctx.beginPath();
                ctx.moveTo(xPos - measuredWidth, overlineY);
                ctx.lineTo(xPos, overlineY);
                ctx.lineWidth = Math.max(1, segSize / 15);
                ctx.strokeStyle = ctx.fillStyle;
                ctx.stroke();
              }
              ctx.restore();
            });
            ctx.restore();
          }
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      }

      class DXFEllipse extends DXFEntity {
        constructor() {
          super("ELLIPSE");
          this.cx = 0; this.cy = 0;
          this.mx = 0; this.my = 0;
          this.ratio = 1;
          this.startParam = 0;
          this.endParam = 2 * Math.PI;
        }
        static parse(lines, i) {
          let ell = new DXFEllipse();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": ell.cx = parseFloat(value); break;
              case "20": ell.cy = parseFloat(value); break;
              case "11": ell.mx = parseFloat(value); break;
              case "21": ell.my = parseFloat(value); break;
              case "40": ell.ratio = parseFloat(value); break;
              case "41": ell.startParam = parseFloat(value); break;
              case "42": ell.endParam = parseFloat(value); break;
              default: ell.raw[code] = value; break;
            }
            i += 2;
          }
          return { entity: ell, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["ELLIPSE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let rx = Math.sqrt(this.mx * this.mx + this.my * this.my);
          let ry = rx * this.ratio;
          let angle = Math.atan2(this.my, this.mx);
          ctx.save();
          ctx.beginPath();
          ctx.translate(this.cx, this.cy);
          ctx.rotate(angle);
          ctx.ellipse(0, 0, rx, ry, 0, this.startParam, this.endParam);
          ctx.stroke();
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      }

      class DXF3DFace extends DXFEntity {
        constructor() {
          super("3DFACE");
          this.points = [];
        }
        static parse(lines, i) {
          let face = new DXF3DFace();
          i += 2;
          let corners = [];
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10" || code === "11" || code === "12" || code === "13") {
              let x = parseFloat(value);
              i += 2;
              let y = 0;
              if (i < lines.length && lines[i].trim() === (parseInt(code) + 10).toString()) {
                y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                i -= 2;
              }
              corners.push({ x, y });
              continue;
            } else {
              face.raw[code] = value;
            }
            i += 2;
          }
          face.points = corners;
          return { entity: face, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["3DFACE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.points.length < 3) return;
          ctx.beginPath();
          ctx.moveTo(this.points[0].x, this.points[0].y);
          for (let i = 1; i < this.points.length; i++) {
            ctx.lineTo(this.points[i].x, this.points[i].y);
          }
          if (this.points.length === 3 || this.points.length === 4) ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFSolid extends DXFEntity {
        constructor() {
          super("SOLID");
          this.points = [];
        }
        static parse(lines, i) {
          let solid = new DXFSolid();
          i += 2;
          let corners = [];
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10" || code === "11" || code === "12" || code === "13") {
              let x = parseFloat(value);
              i += 2;
              let y = 0;
              if (i < lines.length && lines[i].trim() === (parseInt(code) + 10).toString()) {
                y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                i -= 2;
              }
              corners.push({ x, y });
              continue;
            }
            solid.raw[code] = value;
            i += 2;
          }
          solid.points = corners;
          return { entity: solid, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["SOLID"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.points.length < 3) return;
          ctx.beginPath();
          ctx.moveTo(this.points[0].x, this.points[0].y);
          for (let i = 1; i < this.points.length; i++) {
            ctx.lineTo(this.points[i].x, this.points[i].y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class DXFViewport extends DXFEntity {
        constructor() {
          super("VIEWPORT");
          this.lowerLeft = { x: 0, y: 0 };
          this.upperRight = { x: 0, y: 0 };
          this.center = { x: 0, y: 0 };
          this.viewCenter = { x: 0, y: 0 };
          this.viewTarget = { x: 0, y: 0 };
          this.lensLength = 50;
          this.viewHeight = 1;
        }
        static parse(lines, i) {
          let vp = new DXFViewport();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            switch (code) {
              case "10": vp.lowerLeft.x = parseFloat(value); break;
              case "20": vp.lowerLeft.y = parseFloat(value); break;
              case "11": vp.upperRight.x = parseFloat(value); break;
              case "21": vp.upperRight.y = parseFloat(value); break;
              case "12": vp.center.x = parseFloat(value); break;
              case "22": vp.center.y = parseFloat(value); break;
              case "13": vp.viewCenter.x = parseFloat(value); break;
              case "23": vp.viewCenter.y = parseFloat(value); break;
              case "14": vp.viewTarget.x = parseFloat(value); break;
              case "24": vp.viewTarget.y = parseFloat(value); break;
              case "40": vp.lensLength = parseFloat(value); break;
              case "45": vp.viewHeight = parseFloat(value); break;
              default: vp.raw[code] = value; break;
            }
            i += 2;
          }
          return { entity: vp, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["VIEWPORT"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.rect(
            this.lowerLeft.x,
            this.lowerLeft.y,
            this.upperRight.x - this.lowerLeft.x,
            this.upperRight.y - this.lowerLeft.y
          );
          ctx.stroke();
          let centerX = (this.lowerLeft.x + this.upperRight.x) / 2;
          let centerY = (this.lowerLeft.y + this.upperRight.y) / 2;
          ctx.beginPath();
          ctx.moveTo(centerX - 5, centerY);
          ctx.lineTo(centerX + 5, centerY);
          ctx.moveTo(centerX, centerY - 5);
          ctx.lineTo(centerX, centerY + 5);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // 3DSOLID – a 3D solid entity (full support is very complex; here we provide a placeholder)
      class DXF3DSolid extends DXFEntity {
        constructor() {
          super("3DSOLID");
        }
        static parse(lines, i) {
          let solid = new DXF3DSolid();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            solid.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: solid, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["3DSOLID"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          // As a placeholder, simply write the entity type.
          ctx.font = "10px sans-serif";
          ctx.fillText("3DSOLID", 0, 0);
          ctx.globalAlpha = 1;
        }
      }

      // ACAD_PROXY_ENTITY – proxy entities (often unsupported in viewers)
      class DXFAcadProxyEntity extends DXFEntity {
        constructor() {
          super("ACAD_PROXY_ENTITY");
        }
        static parse(lines, i) {
          let proxy = new DXFAcadProxyEntity();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            proxy.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: proxy, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          // Do not render proxy entities.
        }
      }

      // ATTDEF – attribute definition (similar to text)
      class DXFAttDef extends DXFEntity {
        constructor() {
          super("ATTDEF");
          this.position = { x: 0, y: 0 };
          this.text = "";
        }
        static parse(lines, i) {
          let attdef = new DXFAttDef();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10") attdef.position.x = parseFloat(value);
            else if (code === "20") attdef.position.y = parseFloat(value);
            else if (code === "1") attdef.text = value;
            else attdef.raw[code] = value;
            i += 2;
          }
          return { entity: attdef, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["ATTDEF"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.font = "12px sans-serif";
          ctx.fillText(this.text, this.position.x, this.position.y);
          ctx.globalAlpha = 1;
        }
      }

      // BODY – a 3D body (placeholder implementation)
      class DXFBody extends DXFEntity {
        constructor() {
          super("BODY");
        }
        static parse(lines, i) {
          let body = new DXFBody();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            body.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: body, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          // For now, no drawing (or you could draw a bounding box if available)
        }
      }

      // HELIX – a helical curve; here we sample points along a helix
      class DXFHelix extends DXFEntity {
        constructor() {
          super("HELIX");
          this.startPoint = { x: 0, y: 0 };
          this.radius = 0;
          this.turns = 1;
          this.height = 0; // total rise (if needed)
        }
        static parse(lines, i) {
          let helix = new DXFHelix();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10") helix.startPoint.x = parseFloat(value);
            else if (code === "20") helix.startPoint.y = parseFloat(value);
            else if (code === "40") helix.radius = parseFloat(value);
            else if (code === "41") helix.turns = parseFloat(value);
            else if (code === "42") helix.height = parseFloat(value);
            else helix.raw[code] = value;
            i += 2;
          }
          return { entity: helix, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["HELIX"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          let pts = [];
          let segments = 50;
          for (let i = 0; i <= segments; i++) {
            let t = i / segments;
            let angle = t * this.turns * 2 * Math.PI;
            let x = this.startPoint.x + this.radius * Math.cos(angle);
            let y = this.startPoint.y + this.radius * Math.sin(angle);
            pts.push({ x, y });
          }
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          pts.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // IMAGE – represents an external raster image (placeholder)
      class DXFImage extends DXFEntity {
        constructor() {
          super("IMAGE");
          this.position = { x: 0, y: 0 };
          this.width = 0;
          this.height = 0;
          this.imagePath = "";
        }
        static parse(lines, i) {
          let img = new DXFImage();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10") img.position.x = parseFloat(value);
            else if (code === "20") img.position.y = parseFloat(value);
            else if (code === "40") img.width = parseFloat(value);
            else if (code === "41") img.height = parseFloat(value);
            else if (code === "1") img.imagePath = value;
            else img.raw[code] = value;
            i += 2;
          }
          return { entity: img, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["IMAGE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          // Draw a placeholder rectangle with a label.
          ctx.strokeRect(this.position.x, this.position.y, this.width, this.height);
          ctx.font = "10px sans-serif";
          ctx.fillText("IMAGE", this.position.x, this.position.y);
          ctx.globalAlpha = 1;
        }
      }

      // LEADER – a leader (arrowed line) to annotate objects
      class DXFLeader extends DXFEntity {
        constructor() {
          super("LEADER");
          this.vertices = [];
        }
        static parse(lines, i) {
          let leader = new DXFLeader();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") {
              let pt = { x: parseFloat((lines[i + 1] || "").trim()) };
              i += 2;
              if (i < lines.length && lines[i].trim() === "20") {
                pt.y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                pt.y = 0;
                i -= 2;
              }
              leader.vertices.push(pt);
              continue;
            }
            leader.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: leader, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["LEADER"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.vertices.length < 2) return;
          ctx.beginPath();
          ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
          this.vertices.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // LIGHT – a light source entity (symbolic representation)
      class DXFLight extends DXFEntity {
        constructor() {
          super("LIGHT");
          this.position = { x: 0, y: 0 };
        }
        static parse(lines, i) {
          let light = new DXFLight();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") light.position.x = parseFloat((lines[i + 1] || "").trim());
            else if (code === "20") light.position.y = parseFloat((lines[i + 1] || "").trim());
            else light.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: light, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["LIGHT"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.arc(this.position.x, this.position.y, 5 / viewport.viewScale, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.font = "10px sans-serif";
          ctx.fillText("Light", this.position.x, this.position.y);
          ctx.globalAlpha = 1;
        }
      }

      // MESH – a mesh entity (vertices and faces; here a very basic placeholder)
      class DXFMesh extends DXFEntity {
        constructor() {
          super("MESH");
          this.vertices = [];
          this.faces = [];
        }
        static parse(lines, i) {
          let mesh = new DXFMesh();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            mesh.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: mesh, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["MESH"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          // Draw vertices as small circles (detailed face rendering is omitted)
          this.vertices.forEach(pt => {
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, 2 / viewport.viewScale, 0, 2 * Math.PI);
            ctx.fill();
          });
          ctx.globalAlpha = 1;
        }
      }

      // MLINE – multiline entity (treated similar to a polyline)
      class DXFMLINE extends DXFEntity {
        constructor() {
          super("MLINE");
          this.vertices = [];
        }
        static parse(lines, i) {
          let mline = new DXFMLINE();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") {
              let pt = { x: parseFloat((lines[i + 1] || "").trim()) };
              i += 2;
              if (i < lines.length && lines[i].trim() === "20") {
                pt.y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                pt.y = 0;
                i -= 2;
              }
              mline.vertices.push(pt);
              continue;
            }
            mline.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: mline, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["MLINE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.vertices.length < 2) return;
          ctx.beginPath();
          ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
          this.vertices.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // MLEADERSTYLE – style definition for mleader (not drawn)
      class DXFMLeaderStyle extends DXFEntity {
        constructor() {
          super("MLEADERSTYLE");
        }
        static parse(lines, i) {
          let style = new DXFMLeaderStyle();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            style.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: style, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          // Style definitions are not rendered.
        }
      }

      // MLEADER – multileader entity (a leader with attached annotation)
      class DXFMLeader extends DXFEntity {
        constructor() {
          super("MLEADER");
          this.vertices = [];
          this.text = "";
        }
        static parse(lines, i) {
          let mleader = new DXFMLeader();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") {
              let pt = { x: parseFloat((lines[i + 1] || "").trim()) };
              i += 2;
              if (i < lines.length && lines[i].trim() === "20") {
                pt.y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                pt.y = 0;
                i -= 2;
              }
              mleader.vertices.push(pt);
              continue;
            }
            if (code === "1") {
              mleader.text = (lines[i + 1] || "").trim();
              i += 2;
              continue;
            }
            mleader.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: mleader, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["MLEADER"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.vertices.length < 2) return;
          ctx.beginPath();
          ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
          this.vertices.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
          ctx.stroke();
          if (this.text) {
            ctx.font = "10px sans-serif";
            ctx.fillText(this.text, this.vertices[this.vertices.length - 1].x, this.vertices[this.vertices.length - 1].y);
          }
          ctx.globalAlpha = 1;
        }
      }

      // OLEFRAME – a frame for embedded OLE objects (placeholder)
      class DXFOLEFrame extends DXFEntity {
        constructor() {
          super("OLEFRAME");
          this.position = { x: 0, y: 0 };
          this.width = 0;
          this.height = 0;
        }
        static parse(lines, i) {
          let ole = new DXFOLEFrame();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10") ole.position.x = parseFloat(value);
            else if (code === "20") ole.position.y = parseFloat(value);
            else if (code === "40") ole.width = parseFloat(value);
            else if (code === "41") ole.height = parseFloat(value);
            else ole.raw[code] = value;
            i += 2;
          }
          return { entity: ole, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["OLEFRAME"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.strokeRect(this.position.x, this.position.y, this.width, this.height);
          ctx.fillText("OLEFRAME", this.position.x, this.position.y);
          ctx.globalAlpha = 1;
        }
      }

      // OLE2FRAME – similar to OLEFRAME
      class DXFOLE2Frame extends DXFEntity {
        constructor() {
          super("OLE2FRAME");
          this.position = { x: 0, y: 0 };
          this.width = 0;
          this.height = 0;
        }
        static parse(lines, i) {
          let ole = new DXFOLE2Frame();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10") ole.position.x = parseFloat(value);
            else if (code === "20") ole.position.y = parseFloat(value);
            else if (code === "40") ole.width = parseFloat(value);
            else if (code === "41") ole.height = parseFloat(value);
            else ole.raw[code] = value;
            i += 2;
          }
          return { entity: ole, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["OLE2FRAME"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.strokeRect(this.position.x, this.position.y, this.width, this.height);
          ctx.fillText("OLE2FRAME", this.position.x, this.position.y);
          ctx.globalAlpha = 1;
        }
      }

      // POINT – a simple point entity
      class DXFPoint extends DXFEntity {
        constructor() {
          super("POINT");
          this.position = { x: 0, y: 0 };
        }
        static parse(lines, i) {
          let pt = new DXFPoint();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") pt.position.x = parseFloat((lines[i + 1] || "").trim());
            else if (code === "20") pt.position.y = parseFloat((lines[i + 1] || "").trim());
            else pt.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: pt, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["POINT"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.arc(this.position.x, this.position.y, 2 / viewport.viewScale, 0, 2 * Math.PI);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      // RAY – an infinite ray entity
      class DXFRay extends DXFEntity {
        constructor() {
          super("RAY");
          this.point = { x: 0, y: 0 };
          this.direction = { x: 1, y: 0 };
        }
        static parse(lines, i) {
          let ray = new DXFRay();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10") ray.point.x = parseFloat(value);
            else if (code === "20") ray.point.y = parseFloat(value);
            else if (code === "11") ray.direction.x = parseFloat(value);
            else if (code === "21") ray.direction.y = parseFloat(value);
            else ray.raw[code] = value;
            i += 2;
          }
          return { entity: ray, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["RAY"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          const factor = 10000; // a large number to simulate infinity
          let p1 = { x: this.point.x - this.direction.x * factor, y: this.point.y - this.direction.y * factor };
          let p2 = { x: this.point.x + this.direction.x * factor, y: this.point.y + this.direction.y * factor };
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // REGION – a region (similar to hatch boundaries)
      class DXFRegion extends DXFEntity {
        constructor() {
          super("REGION");
          this.boundaryLoops = [];
        }
        static parse(lines, i) {
          let region = new DXFRegion();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            // Example: handle a loop defined by group code 92 (edge count)
            if (code === "92") {
              let count = parseInt((lines[i + 1] || "").trim());
              i += 2;
              let loop = [];
              for (let j = 0; j < count; j++) {
                let x = 0, y = 0;
                if (lines[i].trim() === "10") {
                  x = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                }
                if (lines[i].trim() === "20") {
                  y = parseFloat((lines[i + 1] || "").trim());
                  i += 2;
                }
                loop.push({ x, y });
              }
              region.boundaryLoops.push(loop);
              continue;
            }
            region.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: region, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["REGION"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.boundaryLoops.length === 0) return;
          ctx.beginPath();
          this.boundaryLoops.forEach(loop => {
            if (loop.length > 0) {
              ctx.moveTo(loop[0].x, loop[0].y);
              loop.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
              ctx.closePath();
            }
          });
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // SECTION – a section entity (used for section views; not drawn)
      class DXFSection extends DXFEntity {
        constructor() {
          super("SECTION");
        }
        static parse(lines, i) {
          let section = new DXFSection();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0" && (lines[i + 1] || "").trim() === "ENDSEC") {
              i += 2;
              break;
            }
            section.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: section, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          // Not drawn.
        }
      }

      // SHAPE – a shape (using a shape font)
      class DXFShape extends DXFEntity {
        constructor() {
          super("SHAPE");
          this.position = { x: 0, y: 0 };
          this.text = "";
        }
        static parse(lines, i) {
          let shape = new DXFShape();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10") shape.position.x = parseFloat(value);
            else if (code === "20") shape.position.y = parseFloat(value);
            else if (code === "1") shape.text = value;
            else shape.raw[code] = value;
            i += 2;
          }
          return { entity: shape, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["SHAPE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.font = "12px sans-serif";
          ctx.fillText(this.text, this.position.x, this.position.y);
          ctx.globalAlpha = 1;
        }
      }

      // SUN – a sun entity (for lighting)
      class DXFSun extends DXFEntity {
        constructor() {
          super("SUN");
          this.position = { x: 0, y: 0 };
        }
        static parse(lines, i) {
          let sun = new DXFSun();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") sun.position.x = parseFloat((lines[i + 1] || "").trim());
            else if (code === "20") sun.position.y = parseFloat((lines[i + 1] || "").trim());
            else sun.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: sun, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["SUN"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.beginPath();
          ctx.arc(this.position.x, this.position.y, 5 / viewport.viewScale, 0, 2 * Math.PI);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      // SURFACE – a surface entity (placeholder)
      class DXFSurface extends DXFEntity {
        constructor() {
          super("SURFACE");
          this.vertices = [];
        }
        static parse(lines, i) {
          let surface = new DXFSurface();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") {
              let pt = { x: parseFloat((lines[i + 1] || "").trim()) };
              i += 2;
              if (i < lines.length && lines[i].trim() === "20") {
                pt.y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                pt.y = 0;
                i -= 2;
              }
              surface.vertices.push(pt);
              continue;
            }
            surface.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: surface, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["SURFACE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.vertices.length < 3) return;
          ctx.beginPath();
          ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
          this.vertices.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
          ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // TABLE – a table definition (not rendered)
      class DXFTable extends DXFEntity {
        constructor() {
          super("TABLE");
        }
        static parse(lines, i) {
          let table = new DXFTable();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0" && (lines[i + 1] || "").trim() === "ENDTAB") {
              i += 2;
              break;
            }
            table.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: table, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          // Table definitions are not drawn.
        }
      }

      // TOLERANCE – a tolerance annotation entity
      class DXFTolerance extends DXFEntity {
        constructor() {
          super("TOLERANCE");
          this.position = { x: 0, y: 0 };
          this.text = "";
        }
        static parse(lines, i) {
          let tol = new DXFTolerance();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") tol.position.x = parseFloat((lines[i + 1] || "").trim());
            else if (code === "20") tol.position.y = parseFloat((lines[i + 1] || "").trim());
            else if (code === "1") tol.text = (lines[i + 1] || "").trim();
            else tol.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: tol, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["TOLERANCE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.font = "10px sans-serif";
          ctx.fillText(this.text, this.position.x, this.position.y);
          ctx.globalAlpha = 1;
        }
      }

      // TRACE – similar to SOLID but often only an outline
      class DXFTrace extends DXFEntity {
        constructor() {
          super("TRACE");
          this.points = [];
        }
        static parse(lines, i) {
          let trace = new DXFTrace();
          i += 2;
          let corners = [];
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (["10", "11", "12", "13"].includes(code)) {
              let x = parseFloat((lines[i + 1] || "").trim());
              i += 2;
              let y = 0;
              if (i < lines.length && lines[i].trim() === (parseInt(code) + 10).toString()) {
                y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                i -= 2;
              }
              corners.push({ x, y });
              continue;
            }
            trace.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          trace.points = corners;
          return { entity: trace, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["TRACE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.points.length < 3) return;
          ctx.beginPath();
          ctx.moveTo(this.points[0].x, this.points[0].y);
          this.points.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
          ctx.closePath();
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // UNDERLAY – an underlay reference (placeholder)
      class DXFUnderlay extends DXFEntity {
        constructor() {
          super("UNDERLAY");
          this.position = { x: 0, y: 0 };
          this.width = 0;
          this.height = 0;
        }
        static parse(lines, i) {
          let underlay = new DXFUnderlay();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") underlay.position.x = parseFloat((lines[i + 1] || "").trim());
            else if (code === "20") underlay.position.y = parseFloat((lines[i + 1] || "").trim());
            else if (code === "40") underlay.width = parseFloat((lines[i + 1] || "").trim());
            else if (code === "41") underlay.height = parseFloat((lines[i + 1] || "").trim());
            else underlay.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: underlay, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["UNDERLAY"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          ctx.strokeRect(this.position.x, this.position.y, this.width, this.height);
          ctx.fillText("UNDERLAY", this.position.x, this.position.y);
          ctx.globalAlpha = 1;
        }
      }

      // VERTEX – a vertex used inside a polyline (usually not drawn standalone)
      class DXFVertex extends DXFEntity {
        constructor() {
          super("VERTEX");
          this.position = { x: 0, y: 0 };
        }
        static parse(lines, i) {
          let vertex = new DXFVertex();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") vertex.position.x = parseFloat((lines[i + 1] || "").trim());
            else if (code === "20") vertex.position.y = parseFloat((lines[i + 1] || "").trim());
            else vertex.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: vertex, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          // Typically, vertices are only used as part of another entity.
        }
      }

      // WIPEOUT – a wipeout entity that masks underlying content
      class DXFWipeout extends DXFEntity {
        constructor() {
          super("WIPEOUT");
          this.boundary = [];
        }
        static parse(lines, i) {
          let wipeout = new DXFWipeout();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            if (code === "10") {
              let pt = { x: parseFloat((lines[i + 1] || "").trim()) };
              i += 2;
              if (i < lines.length && lines[i].trim() === "20") {
                pt.y = parseFloat((lines[i + 1] || "").trim());
                i += 2;
              } else {
                pt.y = 0;
                i -= 2;
              }
              wipeout.boundary.push(pt);
              continue;
            }
            wipeout.raw[code] = (lines[i + 1] || "").trim();
            i += 2;
          }
          return { entity: wipeout, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["WIPEOUT"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          if (this.boundary.length < 3) return;
          ctx.beginPath();
          ctx.moveTo(this.boundary[0].x, this.boundary[0].y);
          this.boundary.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
          ctx.closePath();
          ctx.fillStyle = "#000"; // typically the wipeout is drawn opaque
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      // XLINE – an infinite construction line
      class DXFXLine extends DXFEntity {
        constructor() {
          super("XLINE");
          this.point = { x: 0, y: 0 };
          this.direction = { x: 1, y: 0 };
        }
        static parse(lines, i) {
          let xline = new DXFXLine();
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            if (code === "10") xline.point.x = parseFloat(value);
            else if (code === "20") xline.point.y = parseFloat(value);
            else if (code === "11") xline.direction.x = parseFloat(value);
            else if (code === "21") xline.direction.y = parseFloat(value);
            else xline.raw[code] = value;
            i += 2;
          }
          return { entity: xline, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {
          if (!renderSettings.entity["XLINE"]) return;
          this.applyStyle(ctx, viewport, dxfDoc);
          const factor = 10000;
          let p1 = { x: this.point.x - this.direction.x * factor, y: this.point.y - this.direction.y * factor };
          let p2 = { x: this.point.x + this.direction.x * factor, y: this.point.y + this.direction.y * factor };
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      class GenericDXFEntity extends DXFEntity {
        static parse(lines, i) {
          let type = (lines[i + 1] || "").trim();
          let gen = new GenericDXFEntity(type);
          i += 2;
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            gen.raw[code] = value;
            i += 2;
          }
          return { entity: gen, nextIndex: i };
        }
        draw(ctx, viewport, dxfDoc) {}
      }

      // ─────────────────────────────────────────────────────────────
      // BLOCK / DOCUMENT CLASSES
      // ─────────────────────────────────────────────────────────────
      class DXFBlock {
        constructor(name) {
          this.name = name;
          this.basePoint = { x: 0, y: 0 };
          this.entities = [];
        }
      }
      class DXFDocument {
        constructor() {
          this.entities = [];
          this.blocks = {};
          this.layers = {};
          this.linetypes = {};
          this.appids = {};
          this.blockRecords = {};
          this.dimstyles = {};
          this.styles = {};
          this.ucs = {};
          this.views = {};
          this.vports = {};
        }
      }

      // ─────────────────────────────────────────────────────────────
      // DXF PARSER CLASS
      // ─────────────────────────────────────────────────────────────
      class DXFParser {
        parse(text) {
          const lines = text.split(/\r\n|\n/);
          let dxf = new DXFDocument();
          let i = 0;
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "SECTION") {
              i += 2;
              let sectionName = (lines[i + 1] || "").trim();
              i += 2;
              switch (sectionName) {
                case "HEADER":
                  let headerResult = this.parseHeader(lines, i);
                  dxf.header = headerResult.header;
                  i = headerResult.nextIndex;
                  break;
                case "TABLES":
                  // existing handling…
                  let tablesResult = this.parseTables(lines, i);
                  dxf.layers = tablesResult.layers;
                  dxf.linetypes = tablesResult.linetypes;
                  i = tablesResult.nextIndex;
                  break;
                case "BLOCKS":
                  i = this.parseBlocks(lines, i, dxf);
                  break;
                case "ENTITIES":
                  i = this.parseEntities(lines, i, dxf);
                  break;
                default:
                  // Skip any other sections.
                  while (i < lines.length) {
                    if (lines[i].trim() === "0" && (lines[i + 1] || "").trim() === "ENDSEC") {
                      i += 2;
                      break;
                    }
                    i += 2;
                  }
                  break;
              }
            } else {
              i += 2;
            }
          }
          return dxf;
        }
        parseHeader(lines, i) {
          let header = {};
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            // When we reach the end of the header section
            if (code === "0" && value === "ENDSEC") {
              i += 2;
              break;
            }
            if (code === "9") {
              // Group code 9 starts a header variable name.
              let varName = value;
              i += 2;
              // Next group code(s) give the variable’s value.
              // For example, $INSBASE might be defined with codes 10 and 20.
              // Here you can check the following code(s) and store them accordingly.
              let varValue = {};
              while (i < lines.length && lines[i].trim() !== "0") {
                let subCode = lines[i].trim();
                let subValue = (lines[i + 1] || "").trim();
                if (subCode === "10" || subCode === "20" || subCode === "30") {
                  // For points, store as a coordinate object.
                  if (!varValue.x && subCode === "10") { varValue.x = parseFloat(subValue); }
                  else if (!varValue.y && subCode === "20") { varValue.y = parseFloat(subValue); }
                  else if (!varValue.z && subCode === "30") { varValue.z = parseFloat(subValue); }
                } else {
                  // For scalar values, simply store the parsed value.
                  varValue[subCode] = subValue;
                }
                i += 2;
              }
              header[varName] = varValue;
            } else {
              i += 2;
            }
          }
          return { header, nextIndex: i };
        }
        parseGenericTableEntry(lines, i) {
          let entry = {};
          // Read group codes until the next row begins (code "0") or end-of-table:
          while (i < lines.length) {
            let code = lines[i].trim();
            if (code === "0") break;
            let value = (lines[i + 1] || "").trim();
            entry[code] = value;
            i += 2;
          }
          return { entry, nextIndex: i };
        }
        parseTables(lines, i) {
          // Prepare containers for all supported table types:
          let tables = {
            LAYER: {},
            LTYPE: {},
            APPID: {},
            BLOCK_RECORD: {},
            DIMSTYLE: {},
            STYLE: {},
            UCS: {},
            VIEW: {},
            VPORT: {}
          };

          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "ENDSEC") {
              i += 2;
              break;
            }
            if (code === "0" && value === "TABLE") {
              i += 2;
              // The next table name is given by group code 2:
              let tableName = (lines[i + 1] || "").trim();
              i += 2;
              // For LAYER and LTYPE we use our existing specialized code…
              if (tableName === "LAYER") {
                while (i < lines.length) {
                  let c = lines[i].trim();
                  let v = (lines[i + 1] || "").trim();
                  if (c === "0" && (v === "ENDTAB" || v === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  if (c === "0" && v === "LAYER") {
                    let layer = {};
                    i += 2;
                    while (i < lines.length) {
                      let lc = lines[i].trim();
                      if (lc === "0") break;
                      let lv = (lines[i + 1] || "").trim();
                      if (lc === "2") layer.name = lv;
                      else if (lc === "62") layer["62"] = lv;
                      else if (lc === "6") layer["6"] = lv;
                      i += 2;
                    }
                    if (layer.name) {
                      tables.LAYER[layer.name] = layer;
                    }
                  } else {
                    i += 2;
                  }
                }
              } else if (tableName === "LTYPE") {
                while (i < lines.length) {
                  let c = lines[i].trim();
                  let v = (lines[i + 1] || "").trim();
                  if (c === "0" && (v === "ENDTAB" || v === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  if (c === "0" && v === "LTYPE") {
                    let lt = {};
                    i += 2;
                    while (i < lines.length) {
                      let lc = lines[i].trim();
                      if (lc === "0") break;
                      let lv = (lines[i + 1] || "").trim();
                      if (lc === "2") lt.name = lv;
                      else if (lc === "3") lt.description = lv;
                      else if (lc === "72") lt.flags = lv;
                      else if (lc === "73") lt.elements = parseInt(lv, 10);
                      else if (lc === "40") lt.patternLength = parseFloat(lv);
                      else if (lc === "49") {
                        if (!lt.pattern) lt.pattern = [];
                        lt.pattern.push(parseFloat(lv));
                      }
                      i += 2;
                    }
                    if (lt.name) {
                      tables.LTYPE[lt.name] = lt;
                    }
                  } else {
                    i += 2;
                  }
                }
              }
              // For the other table types, use the generic parser:
              else if (tables.hasOwnProperty(tableName)) {
                let tableEntries = {};
                while (i < lines.length) {
                  let c = lines[i].trim();
                  let v = (lines[i + 1] || "").trim();
                  if (c === "0" && (v === "ENDTAB" || v === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  // Each row should start with "0" and the row type equals the table type
                  if (c === "0" && v === tableName) {
                    i += 2;
                    let result = this.parseGenericTableEntry(lines, i);
                    let entry = result.entry;
                    i = result.nextIndex;
                    // Use group code "2" (if present) as a key; otherwise use an index
                    let key = entry["2"] || Object.keys(tableEntries).length;
                    tableEntries[key] = entry;
                  } else {
                    i += 2;
                  }
                }
                tables[tableName] = tableEntries;
              }
              // For any unknown table type, just skip its contents:
              else {
                while (i < lines.length) {
                  let c = lines[i].trim();
                  let v = (lines[i + 1] || "").trim();
                  if (c === "0" && (v === "ENDTAB" || v === "ENDTABLE")) {
                    i += 2;
                    break;
                  }
                  i += 2;
                }
              }
              continue;
            }
            i += 2;
          }
          // Return the parsed layers, linetypes, and the new tables
          return {
            layers: tables.LAYER,
            linetypes: tables.LTYPE,
            appids: tables.APPID,
            blockRecords: tables.BLOCK_RECORD,
            dimstyles: tables.DIMSTYLE,
            styles: tables.STYLE,
            ucs: tables.UCS,
            views: tables.VIEW,
            vports: tables.VPORT,
            nextIndex: i
          };
        }
        parseBlocks(lines, i, dxf) {
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "ENDSEC") {
              i += 2;
              break;
            }
            if (code === "0" && value === "BLOCK") {
              let block = new DXFBlock("");
              i += 2;
              while (i < lines.length) {
                let c = lines[i].trim();
                if (c === "0") {
                  let v = (lines[i + 1] || "").trim();
                  if (v === "ENDBLK") {
                    i += 2;
                    break;
                  }
                  if (["LINE", "CIRCLE", "ARC", "LWPOLYLINE", "POLYLINE", "TEXT", "MTEXT", "DIMENSION", "HATCH", "SPLINE", "INSERT", "ELLIPSE", "3DFACE", "SOLID", "ATTRIB", "VIEWPORT"].includes(v)) {
                    let entRes = this.parseEntity(lines, i);
                    if (entRes) {
                      block.entities.push(entRes.entity);
                      i = entRes.nextIndex;
                      continue;
                    }
                  }
                }
                let v = (lines[i + 1] || "").trim();
                if (c === "2") {
                  block.name = v;
                } else if (c === "10") {
                  block.basePoint.x = parseFloat(v);
                } else if (c === "20") {
                  block.basePoint.y = parseFloat(v);
                }
                i += 2;
              }
              dxf.blocks[block.name] = block;
              continue;
            }
            i += 2;
          }
          return i;
        }
        parseEntities(lines, i, dxf) {
          while (i < lines.length) {
            let code = lines[i].trim();
            let value = (lines[i + 1] || "").trim();
            if (code === "0" && value === "ENDSEC") {
              i += 2;
              break;
            }
            if (code === "0") {
              let res = this.parseEntity(lines, i);
              if (res) {
                let e = res.entity;
                i = res.nextIndex;
                if (e.type === "INSERT") {
                  e.attribs = [];
                  while (i < lines.length) {
                    let c2 = lines[i].trim();
                    let v2 = (lines[i + 1] || "").trim();
                    if (c2 === "0" && v2 === "ATTRIB") {
                      let ar = this.parseEntity(lines, i);
                      if (ar) {
                        e.attribs.push(ar.entity);
                        i = ar.nextIndex;
                        continue;
                      }
                    }
                    break;
                  }
                }
                dxf.entities.push(e);
                continue;
              }
            }
            i += 2;
          }
          return i;
        }
        parseEntity(lines, i) {
          if (i >= lines.length) return null;
          let code = lines[i].trim();
          let value = (lines[i + 1] || "").trim();
          if (code !== "0") return null;
          switch (value) {
            case "LINE": return DXFLine.parse(lines, i);
            case "CIRCLE": return DXFCircle.parse(lines, i);
            case "ARC": return DXFArc.parse(lines, i);
            case "POLYLINE": return DXFPolyline.parse(lines, i);
            case "LWPOLYLINE": return DXFLwPolyline.parse(lines, i);
            case "HATCH": return DXFHatch.parse(lines, i);
            case "DIMENSION": return DXFDimension.parse(lines, i);
            case "MTEXT": return DXFMTEXT.parse(lines, i);
            case "SPLINE": return DXFSpline.parse(lines, i);
            case "INSERT": return DXFInsert.parse(lines, i);
            case "TEXT":
            case "ATTRIB": return DXFText.parse(lines, i);
            case "ELLIPSE": return DXFEllipse.parse(lines, i);
            case "3DFACE": return DXF3DFace.parse(lines, i);
            case "SOLID": return DXFSolid.parse(lines, i);
            case "VIEWPORT": return DXFViewport.parse(lines, i);
            case "3DSOLID": return DXF3DSolid.parse(lines, i);
            case "ACAD_PROXY_ENTITY": return DXFAcadProxyEntity.parse(lines, i);
            case "ATTDEF": return DXFAttDef.parse(lines, i);
            case "BODY": return DXFBody.parse(lines, i);
            case "HELIX": return DXFHelix.parse(lines, i);
            case "IMAGE": return DXFImage.parse(lines, i);
            case "LEADER": return DXFLeader.parse(lines, i);
            case "LIGHT": return DXFLight.parse(lines, i);
            case "MESH": return DXFMesh.parse(lines, i);
            case "MLINE": return DXFMLINE.parse(lines, i);
            case "MLEADERSTYLE": return DXFMLeaderStyle.parse(lines, i);
            case "MLEADER": return DXFMLeader.parse(lines, i);
            case "OLEFRAME": return DXFOLEFrame.parse(lines, i);
            case "OLE2FRAME": return DXFOLE2Frame.parse(lines, i);
            case "POINT": return DXFPoint.parse(lines, i);
            case "RAY": return DXFRay.parse(lines, i);
            case "REGION": return DXFRegion.parse(lines, i);
            case "SECTION": return DXFSection.parse(lines, i);
            case "SHAPE": return DXFShape.parse(lines, i);
            case "SUN": return DXFSun.parse(lines, i);
            case "SURFACE": return DXFSurface.parse(lines, i);
            case "TABLE": return DXFTable.parse(lines, i);
            case "TOLERANCE": return DXFTolerance.parse(lines, i);
            case "TRACE": return DXFTrace.parse(lines, i);
            case "UNDERLAY": return DXFUnderlay.parse(lines, i);
            case "VERTEX": return DXFVertex.parse(lines, i);
            case "WIPEOUT": return DXFWipeout.parse(lines, i);
            case "XLINE": return DXFXLine.parse(lines, i);
            default: return GenericDXFEntity.parse(lines, i);
          }
        }
      }

      // ─────────────────────────────────────────────────────────────
      // VIEWPORT CLASS (for panning/zooming)
      // ─────────────────────────────────────────────────────────────
      class Viewport {
        constructor(canvas) {
          this.canvas = canvas;
          this.baseScale = 1;
          this.baseOffsetX = 0;
          this.baseOffsetY = 0;
          this.viewScale = 1;
          this.viewOffsetX = 0;
          this.viewOffsetY = 0;
        }
        reset() {
          this.viewScale = this.baseScale;
          this.viewOffsetX = this.baseOffsetX;
          this.viewOffsetY = this.baseOffsetY;
        }
        setInitialView(dxfDoc) {
          let minX, minY, maxX, maxY;
          // Prefer header-defined extents ($EXTMIN and $EXTMAX)
          if (dxfDoc.header && dxfDoc.header["$EXTMIN"] && dxfDoc.header["$EXTMAX"]) {
            minX = dxfDoc.header["$EXTMIN"].x;
            minY = dxfDoc.header["$EXTMIN"].y;
            maxX = dxfDoc.header["$EXTMAX"].x;
            maxY = dxfDoc.header["$EXTMAX"].y;
          }
          // Fall back to limits ($LIMMIN and $LIMMAX)
          else if (dxfDoc.header && dxfDoc.header["$LIMMIN"] && dxfDoc.header["$LIMMAX"]) {
            minX = dxfDoc.header["$LIMMIN"].x;
            minY = dxfDoc.header["$LIMMIN"].y;
            maxX = dxfDoc.header["$LIMMAX"].x;
            maxY = dxfDoc.header["$LIMMAX"].y;
          }
          // Otherwise, compute the bounding box from the entities.
          else {
            minX = Infinity; minY = Infinity;
            maxX = -Infinity; maxY = -Infinity;
            dxfDoc.entities.forEach(entity => {
              let bbox = getEntityBBox(entity);
              if (bbox) {
                minX = Math.min(minX, bbox.minX);
                minY = Math.min(minY, bbox.minY);
                maxX = Math.max(maxX, bbox.maxX);
                maxY = Math.max(maxY, bbox.maxY);
              }
            });
          }
          if (minX === Infinity) { // no valid extents found
            minX = -100; minY = -100; maxX = 100; maxY = 100;
          }
          let dw = maxX - minX, dh = maxY - minY;
          let sx = this.canvas.width / dw, sy = this.canvas.height / dh;
          this.baseScale = 0.9 * Math.min(sx, sy);
          let cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
          this.viewScale = this.baseScale;
          this.baseOffsetX = this.canvas.width / 2 - this.baseScale * cx;
          this.baseOffsetY = this.canvas.height / 2 + this.baseScale * cy;
          this.viewOffsetX = this.baseOffsetX;
          this.viewOffsetY = this.baseOffsetY;
        }
        worldToScreen(x, y) {
          return { x: this.viewScale * x + this.viewOffsetX, y: -this.viewScale * y + this.viewOffsetY };
        }
        screenToWorld(sx, sy) {
          return { x: (sx - this.viewOffsetX) / this.viewScale, y: -(sy - this.viewOffsetY) / this.viewScale };
        }
      }

      // ─────────────────────────────────────────────────────────────
      // DXF VIEWER CLASS (with layout selection support)
      // ─────────────────────────────────────────────────────────────
      class DXFViewer {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          this.viewport = new Viewport(canvas);
          this.dxfDoc = new DXFDocument();
          this.parser = new DXFParser();
          this.gridEnabled = false;
          this.isPanning = false;
          this.lastPanPoint = { x: 0, y: 0 };
          this.ongoingTouches = [];
          this.lastTouchDistance = null;
          this.lastTouchCenter = null;
          this.activeLayout = "model";
          this.registerEventHandlers();
          window.addEventListener("resize", () => this.onResize());
          this.onResize();
        }
        onResize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          if (this.dxfDoc.entities.length > 0) {
            this.viewport.setInitialView(this.dxfDoc);
          }
          this.draw();
        }
        loadDXF(text) {
          let dxfParsed = this.parser.parse(text);
          if (dxfParsed.entities.length === 0 && Object.keys(dxfParsed.blocks).length === 0) {
            alert("No supported entities found in DXF.");
            return;
          }
          this.dxfDoc = dxfParsed;
          this.viewport.setInitialView(this.dxfDoc);
          this.updateEntityList();
          this.draw();
        }
        toggleGrid() {
          this.gridEnabled = !this.gridEnabled;
          this.draw();
        }
        resetView() {
          this.viewport.reset();
          this.draw();
        }
        zoomExtents() {
          this.viewport.setInitialView(this.dxfDoc);
          this.draw();
        }
        shouldRender(entity) {
          // Check for object visibility: if group code 60 is set to 1, skip rendering.
          if (entity.raw["60"] !== undefined && parseInt(entity.raw["60"], 10) === 1) {
            return false;
          }
          // Existing check for VIEWPORT and space flag.
          if (entity.type === "VIEWPORT") {
            return this.activeLayout === "paper";
          }
          // Use dedicated property for space flag if available.
          const flag = (entity.spaceFlag !== undefined)
            ? entity.spaceFlag
            : (entity.raw["67"] ? parseInt(entity.raw["67"], 10) : 0);
          if (this.activeLayout === "model") {
            return (flag === 0 || flag === undefined);
          } else if (this.activeLayout === "paper") {
            return (flag === 1);
          }
          return true;
        }
        draw() {
          let ctx = this.ctx;
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          ctx.restore();
          ctx.setTransform(
            this.viewport.viewScale, 0,
            0, -this.viewport.viewScale,
            this.viewport.viewOffsetX,
            this.viewport.viewOffsetY
          );
          if (this.gridEnabled) {
            this.drawGrid();
          }
          this.dxfDoc.entities.forEach(entity => {
            if (this.shouldRender(entity) && renderSettings.entity[entity.type] !== false) {
              entity.draw(ctx, this.viewport, this.dxfDoc);
            }
          });
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        drawGrid() {
          let spacing = getNiceGridSpacing(this.viewport);
          let tl = this.viewport.screenToWorld(0, 0);
          let br = this.viewport.screenToWorld(this.canvas.width, this.canvas.height);
          let startX = Math.floor(tl.x / spacing) * spacing;
          let endX = Math.ceil(br.x / spacing) * spacing;
          let startY = Math.floor(br.y / spacing) * spacing;
          let endY = Math.ceil(tl.y / spacing) * spacing;
          let ctx = this.ctx;
          ctx.save();
          ctx.lineWidth = 1 / this.viewport.viewScale;
          ctx.strokeStyle = "#444";
          ctx.beginPath();
          for (let x = startX; x <= endX; x += spacing) {
            ctx.moveTo(x, startY);
            ctx.lineTo(x, endY);
          }
          for (let y = startY; y <= endY; y += spacing) {
            ctx.moveTo(startX, y);
            ctx.lineTo(endX, y);
          }
          ctx.stroke();
          ctx.restore();
        }
        registerEventHandlers() {
          this.canvas.addEventListener("mousedown", (e) => {
            this.isPanning = true;
            this.lastPanPoint = { x: e.clientX, y: e.clientY };
          });
          this.canvas.addEventListener("mousemove", (e) => {
            if (this.isPanning) {
              let dx = e.clientX - this.lastPanPoint.x;
              let dy = e.clientY - this.lastPanPoint.y;
              this.lastPanPoint = { x: e.clientX, y: e.clientY };
              this.viewport.viewOffsetX += dx;
              this.viewport.viewOffsetY += dy;
              this.draw();
            }
          });
          this.canvas.addEventListener("mouseup", () => { this.isPanning = false; });
          this.canvas.addEventListener("mouseleave", () => { this.isPanning = false; });
          this.canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            const zoomIntensity = 0.001;
            let factor = 1 - e.deltaY * zoomIntensity;
            let mx = e.clientX, my = e.clientY;
            this.viewport.viewOffsetX = mx - factor * (mx - this.viewport.viewOffsetX);
            this.viewport.viewOffsetY = my - factor * (my - this.viewport.viewOffsetY);
            this.viewport.viewScale *= factor;
            this.draw();
          }, { passive: false });
          this.canvas.addEventListener("touchstart", (e) => this.handleTouchStart(e), { passive: false });
          this.canvas.addEventListener("touchmove", (e) => this.handleTouchMove(e), { passive: false });
          this.canvas.addEventListener("touchend", (e) => this.handleTouchEnd(e), { passive: false });
          this.canvas.addEventListener("touchcancel", (e) => this.handleTouchEnd(e), { passive: false });
        }
        getTouchPos(evt) {
          let rect = this.canvas.getBoundingClientRect();
          return Array.from(evt.touches).map(t => ({ x: t.clientX - rect.left, y: t.clientY - rect.top }));
        }
        handleTouchStart(evt) {
          evt.preventDefault();
          let touches = this.getTouchPos(evt);
          this.ongoingTouches = touches;
          if (touches.length === 2) {
            this.lastTouchDistance = getDistance(touches[0], touches[1]);
            this.lastTouchCenter = getCenter(touches[0], touches[1]);
          } else if (touches.length === 1) {
            this.lastPanPoint = touches[0];
          }
        }
        handleTouchMove(evt) {
          evt.preventDefault();
          let touches = this.getTouchPos(evt);
          if (touches.length === 2 && this.ongoingTouches.length >= 2) {
            let newDist = getDistance(touches[0], touches[1]);
            let factor = newDist / this.lastTouchDistance;
            let newCenter = getCenter(touches[0], touches[1]);
            this.viewport.viewOffsetX = newCenter.x - factor * (newCenter.x - this.viewport.viewOffsetX);
            this.viewport.viewOffsetY = newCenter.y - factor * (newCenter.y - this.viewport.viewOffsetY);
            this.viewport.viewScale *= factor;
            this.lastTouchDistance = newDist;
            this.lastTouchCenter = newCenter;
          } else if (touches.length === 1 && this.ongoingTouches.length === 1) {
            let dx = touches[0].x - this.lastPanPoint.x;
            let dy = touches[0].y - this.lastPanPoint.y;
            this.viewport.viewOffsetX += dx;
            this.viewport.viewOffsetY += dy;
            this.lastPanPoint = touches[0];
          }
          this.ongoingTouches = touches;
          this.draw();
        }
        handleTouchEnd(evt) {
          evt.preventDefault();
          let touches = this.getTouchPos(evt);
          this.ongoingTouches = touches;
          if (touches.length < 2) {
            this.lastTouchDistance = null;
            this.lastTouchCenter = null;
          }
          if (touches.length === 0) this.isPanning = false;
        }
        // New: Zoom to a given entity based on its bounding box
        zoomToEntity(entity) {
          let bbox = getEntityBBox(entity);
          if (!bbox) return;
          const margin = 20;
          const canvasWidth = this.canvas.width;
          const canvasHeight = this.canvas.height;
          const entityWidth = bbox.maxX - bbox.minX || 1;
          const entityHeight = bbox.maxY - bbox.minY || 1;
          const scaleX = (canvasWidth - margin * 2) / entityWidth;
          const scaleY = (canvasHeight - margin * 2) / entityHeight;
          const newScale = Math.min(scaleX, scaleY);
          const cx = (bbox.minX + bbox.maxX) / 2;
          const cy = (bbox.minY + bbox.maxY) / 2;
          this.viewport.viewScale = newScale;
          this.viewport.viewOffsetX = canvasWidth / 2 - newScale * cx;
          this.viewport.viewOffsetY = canvasHeight / 2 + newScale * cy;
          this.draw();
        }
        // New: Update the entity list in the UI panel
        updateEntityList() {
          let entityListEl = document.getElementById("entityList");
          let ul = entityListEl.querySelector("ul");
          ul.innerHTML = "";
          this.dxfDoc.entities.forEach((entity, index) => {
            // Only list entities that are currently set to render.
            if (!renderSettings.entity[entity.type]) return;
            let li = document.createElement("li");
            li.textContent = entity.type;
            let layer = entity.raw["8"] || "default";
            let handle = entity.raw["5"] || "";
            li.title = `Type: ${entity.type}\nLayer: ${layer}\nHandle: ${handle}`;
            li.addEventListener("click", () => {
              this.zoomToEntity(entity);
            });
            ul.appendChild(li);
          });
        }
      }

            // ─────────────────────────────────────────────────────────────
      // Helper: Compute a simple bounding box for an entity
      // ─────────────────────────────────────────────────────────────
      function getEntityBBox(entity) {
        switch(entity.type) {
          case "LINE":
            return {
              minX: Math.min(entity.x1, entity.x2),
              maxX: Math.max(entity.x1, entity.x2),
              minY: Math.min(entity.y1, entity.y2),
              maxY: Math.max(entity.y1, entity.y2)
            };
          case "CIRCLE":
            return {
              minX: entity.cx - entity.r,
              maxX: entity.cx + entity.r,
              minY: entity.cy - entity.r,
              maxY: entity.cy + entity.r
            };
          case "ARC":
            let startRad = DXFUtils.degToRad(entity.startAngle);
            let endRad = DXFUtils.degToRad(entity.endAngle);
            let p1 = { x: entity.cx + entity.r * Math.cos(startRad), y: entity.cy + entity.r * Math.sin(startRad) };
            let p2 = { x: entity.cx + entity.r * Math.cos(endRad), y: entity.cy + entity.r * Math.sin(endRad) };
            return {
              minX: Math.min(entity.cx - entity.r, p1.x, p2.x),
              maxX: Math.max(entity.cx + entity.r, p1.x, p2.x),
              minY: Math.min(entity.cy - entity.r, p1.y, p2.y),
              maxY: Math.max(entity.cy + entity.r, p1.y, p2.y)
            };
          case "POLYLINE":
          case "LWPOLYLINE":
            if (entity.vertices && entity.vertices.length > 0) {
              let xs = entity.vertices.map(v => v.x);
              let ys = entity.vertices.map(v => v.y);
              return { minX: Math.min(...xs), maxX: Math.max(...xs), minY: Math.min(...ys), maxY: Math.max(...ys) };
            }
            break;
          case "HATCH":
            if (entity.boundaryLoops && entity.boundaryLoops.length > 0) {
              return computeBBox(entity.boundaryLoops);
            }
            break;
          case "DIMENSION":
            return {
              minX: Math.min(entity.p1.x, entity.p2.x),
              maxX: Math.max(entity.p1.x, entity.p2.x),
              minY: Math.min(entity.p1.y, entity.p2.y),
              maxY: Math.max(entity.p1.y, entity.p2.y)
            };
          case "MTEXT":
          case "TEXT":
          case "ATTRIB":
            return { minX: entity.position.x, maxX: entity.position.x, minY: entity.position.y, maxY: entity.position.y };
          case "SPLINE":
            if (entity.fitPoints && entity.fitPoints.length > 0) {
              let xs = entity.fitPoints.map(v => v.x);
              let ys = entity.fitPoints.map(v => v.y);
              return { minX: Math.min(...xs), maxX: Math.max(...xs), minY: Math.min(...ys), maxY: Math.max(...ys) };
            }
            break;
          case "INSERT":
            return { minX: entity.insertionPoint.x, maxX: entity.insertionPoint.x, minY: entity.insertionPoint.y, maxY: entity.insertionPoint.y };
          case "ELLIPSE":
            let rx = Math.sqrt(entity.mx * entity.mx + entity.my * entity.my);
            let ry = rx * (entity.ratio || 1);
            return { minX: entity.cx - rx, maxX: entity.cx + rx, minY: entity.cy - ry, maxY: entity.cy + ry };
          case "3DFACE":
          case "SOLID":
            if (entity.points && entity.points.length > 0) {
              let xs = entity.points.map(p => p.x);
              let ys = entity.points.map(p => p.y);
              return { minX: Math.min(...xs), maxX: Math.max(...xs), minY: Math.min(...ys), maxY: Math.max(...ys) };
            }
          case "VIEWPORT":
            return {
              minX: entity.lowerLeft.x,
              maxX: entity.upperRight.x,
              minY: entity.lowerLeft.y,
              maxY: entity.upperRight.y
            };
          default:
            return null;
        }
        return null;
      }

      // ─────────────────────────────────────────────────────────────
      // BOOTSTRAP
      // ─────────────────────────────────────────────────────────────
      const canvas = document.getElementById("canvas");
      const viewer = new DXFViewer(canvas);

      document.getElementById("layoutSelect").addEventListener("change", function(e) {
        viewer.activeLayout = e.target.value;
        viewer.draw();
      });

      document.getElementById("dxfFile").addEventListener("change", function (e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (event) {
          const text = event.target.result;
          viewer.loadDXF(text);
        };
        reader.readAsText(file);
      });
      document.getElementById("zoomExtents").addEventListener("click", () => viewer.zoomExtents());
      document.getElementById("toggleGrid").addEventListener("click", () => viewer.toggleGrid());
      document.getElementById("toggleEntityOptions").addEventListener("click", () => {
        document.getElementById("entityOptionsOverlay").style.display = "block";
      });
      document.getElementById("toggleOtherOptions").addEventListener("click", () => {
        document.getElementById("otherOptionsOverlay").style.display = "block";
      });
      document.getElementById("entityOptionsOverlay").addEventListener("click", (e) => {
        if (e.target === document.getElementById("entityOptionsOverlay")) {
          document.getElementById("entityOptionsOverlay").style.display = "none";
        }
      });
      document.getElementById("otherOptionsOverlay").addEventListener("click", (e) => {
        if (e.target === document.getElementById("otherOptionsOverlay")) {
          document.getElementById("otherOptionsOverlay").style.display = "none";
        }
      });
      document.getElementById("entityOptionsPopup").addEventListener("click", e => e.stopPropagation());
      document.getElementById("otherOptionsPopup").addEventListener("click", e => e.stopPropagation());
      document.querySelectorAll(".entity-toggle").forEach(checkbox => {
        checkbox.addEventListener("change", function (e) {
          const type = e.target.getAttribute("data-type");
          renderSettings.entity[type] = e.target.checked;
          viewer.draw();
          viewer.updateEntityList();
        });
      });
      document.getElementById("selectAllEntities").addEventListener("click", () => {
        document.querySelectorAll(".entity-toggle").forEach(cb => {
          cb.checked = true;
          const type = cb.getAttribute("data-type");
          renderSettings.entity[type] = true;
        });
        viewer.draw();
        viewer.updateEntityList();
      });
      document.getElementById("deselectAllEntities").addEventListener("click", () => {
        document.querySelectorAll(".entity-toggle").forEach(cb => {
          cb.checked = false;
          const type = cb.getAttribute("data-type");
          renderSettings.entity[type] = false;
        });
        viewer.draw();
        viewer.updateEntityList();
      });
      document.getElementById("toggleLinetype").addEventListener("change", function (e) {
        renderSettings.renderLinetype = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleColor").addEventListener("change", function (e) {
        renderSettings.renderColor = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleThickness").addEventListener("change", function (e) {
        renderSettings.renderThickness = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleWidth").addEventListener("change", function (e) {
        renderSettings.renderWidth = !e.target.checked;
        viewer.draw();
      });
      document.getElementById("toggleTransparency").addEventListener("change", function (e) {
        renderSettings.renderTransparency = !e.target.checked;
        viewer.draw();
      });
      viewer.draw();
      
       // New: Add canvas mousemove listener to show tooltip for entity under pointer
      canvas.addEventListener("mousemove", (e) => {
        if (!viewer.isPanning) {
          let rect = canvas.getBoundingClientRect();
          let mouseX = e.clientX - rect.left;
          let mouseY = e.clientY - rect.top;
          let worldPos = viewer.viewport.screenToWorld(mouseX, mouseY);
          let hoveredEntity = null;
          for (let entity of viewer.dxfDoc.entities) {
            if (!renderSettings.entity[entity.type]) continue;
            let bbox = getEntityBBox(entity);
            if (bbox &&
                worldPos.x >= bbox.minX && worldPos.x <= bbox.maxX &&
                worldPos.y >= bbox.minY && worldPos.y <= bbox.maxY) {
              hoveredEntity = entity;
              break;
            }
          }
          let tooltip = document.getElementById("entityTooltip");
          if (hoveredEntity) {
            let layer = hoveredEntity.raw["8"] || "default";
            let handle = hoveredEntity.raw["5"] || "";
            tooltip.textContent = `Type: ${hoveredEntity.type}, Layer: ${layer}, Handle: ${handle}`;
            tooltip.style.display = "block";
            tooltip.style.left = e.clientX + 10 + "px";
            tooltip.style.top = e.clientY + 10 + "px";
          } else {
            tooltip.style.display = "none";
          }
        }
      });
    </script>
  </body>
</html>
